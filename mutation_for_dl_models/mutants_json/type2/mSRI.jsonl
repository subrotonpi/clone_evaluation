{"idx": 1, "func": "public static BufferedImage scale (BufferedImage X1, int dWidth, int dHeight) {\n\n    BufferedImage scaledImage = null;\n\n    if (X1 != null) {\n\n        scaledImage = new BufferedImage (dWidth, dHeight, X1.getType ());\n\n        Graphics2D graphics2D = scaledImage.createGraphics ();\n\n        graphics2D.drawImage (X1, 0, 0, dWidth, dHeight, null);\n\n        graphics2D.dispose ();\n\n    }\n\n    return scaledImage;\n\n}\n"}
{"idx": 2, "func": "public static BufferedImage scale (BufferedImage sbi, int imageType, int dWidth, int dHeight, double X1, double fHeight) {\n\n    BufferedImage dbi = null;\n\n    if (sbi != null) {\n\n        dbi = new BufferedImage (dWidth, dHeight, imageType);\n\n        Graphics2D g = dbi.createGraphics ();\n\n        AffineTransform at = AffineTransform.getScaleInstance (X1, fHeight);\n\n        g.drawRenderedImage (sbi, at);\n\n    }\n\n    return dbi;\n\n}\n"}
{"idx": 10001, "func": "public void type (CharSequence chars, int X1) {\n\n    X1 = X1 > 0 ? X1 : 0;\n\n    for (int i = 0, len = chars.length ();\n\n    i < len; i ++) {\n\n        char c = chars.charAt (i);\n\n        AWTKeyStroke keyStroke = getKeyStroke (c);\n\n        int keyCode = keyStroke.getKeyCode ();\n\n        boolean shift = Character.isUpperCase (c) || keyStroke.getModifiers () == (SHIFT_DOWN_MASK + 1);\n\n        if (shift) {\n\n            robot.keyPress (KeyEvent.VK_SHIFT);\n\n        }\n\n        robot.keyPress (keyCode);\n\n        robot.keyRelease (keyCode);\n\n        if (shift) {\n\n            robot.keyRelease (KeyEvent.VK_SHIFT);\n\n        }\n\n        if (X1 > 0) {\n\n            robot.delay (X1);\n\n        }\n\n    }\n\n}\n"}
{"idx": 10002, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            X1 (VK_A);\n\n            break;\n\n        case 'b' :\n\n            X1 (VK_B);\n\n            break;\n\n        case 'c' :\n\n            X1 (VK_C);\n\n            break;\n\n        case 'd' :\n\n            X1 (VK_D);\n\n            break;\n\n        case 'e' :\n\n            X1 (VK_E);\n\n            break;\n\n        case 'f' :\n\n            X1 (VK_F);\n\n            break;\n\n        case 'g' :\n\n            X1 (VK_G);\n\n            break;\n\n        case 'h' :\n\n            X1 (VK_H);\n\n            break;\n\n        case 'i' :\n\n            X1 (VK_I);\n\n            break;\n\n        case 'j' :\n\n            X1 (VK_J);\n\n            break;\n\n        case 'k' :\n\n            X1 (VK_K);\n\n            break;\n\n        case 'l' :\n\n            X1 (VK_L);\n\n            break;\n\n        case 'm' :\n\n            X1 (VK_M);\n\n            break;\n\n        case 'n' :\n\n            X1 (VK_N);\n\n            break;\n\n        case 'o' :\n\n            X1 (VK_O);\n\n            break;\n\n        case 'p' :\n\n            X1 (VK_P);\n\n            break;\n\n        case 'q' :\n\n            X1 (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            X1 (VK_R);\n\n            break;\n\n        case 's' :\n\n            X1 (VK_S);\n\n            break;\n\n        case 't' :\n\n            X1 (VK_T);\n\n            break;\n\n        case 'u' :\n\n            X1 (VK_U);\n\n            break;\n\n        case 'v' :\n\n            X1 (VK_V);\n\n            break;\n\n        case 'w' :\n\n            X1 (VK_W);\n\n            break;\n\n        case 'x' :\n\n            X1 (VK_X);\n\n            break;\n\n        case 'y' :\n\n            X1 (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            X1 (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            X1 (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            X1 (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            X1 (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            X1 (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            X1 (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            X1 (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            X1 (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            X1 (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            X1 (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            X1 (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            X1 (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            X1 (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            X1 (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            X1 (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            X1 (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            X1 (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            X1 (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            X1 (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            X1 (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            X1 (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            X1 (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            X1 (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            X1 (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            X1 (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            X1 (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            X1 (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            X1 (VK_0);\n\n            break;\n\n        case '1' :\n\n            X1 (VK_1);\n\n            break;\n\n        case '2' :\n\n            X1 (VK_2);\n\n            break;\n\n        case '3' :\n\n            X1 (VK_3);\n\n            break;\n\n        case '4' :\n\n            X1 (VK_4);\n\n            break;\n\n        case '5' :\n\n            X1 (VK_5);\n\n            break;\n\n        case '6' :\n\n            X1 (VK_6);\n\n            break;\n\n        case '7' :\n\n            X1 (VK_7);\n\n            break;\n\n        case '8' :\n\n            X1 (VK_8);\n\n            break;\n\n        case '9' :\n\n            X1 (VK_9);\n\n            break;\n\n        case '-' :\n\n            X1 (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            X1 (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            X1 (VK_SHIFT, VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            X1 (VK_SHIFT, VK_AT);\n\n            break;\n\n        case '#' :\n\n            X1 (VK_SHIFT, VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            X1 (VK_SHIFT, VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            X1 (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            X1 (VK_SHIFT, VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            X1 (VK_SHIFT, VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            X1 (VK_SHIFT, VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            X1 (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            X1 (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            X1 (VK_SHIFT, VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            X1 (VK_SHIFT, VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            X1 (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            X1 (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            X1 (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            X1 (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            X1 (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            X1 (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            X1 (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            X1 (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            X1 (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            X1 (VK_SHIFT, VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            X1 (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            X1 (VK_SHIFT, VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            X1 (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            X1 (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            X1 (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            X1 (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            X1 (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            X1 (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            X1 (VK_SPACE);\n\n            break;\n\n        case '\\b' :\n\n            X1 (VK_BACK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 1001, "func": "public void replaceText (int start, int end, String X1) {\n\n    if (! characters.equals (\"\")) {\n\n        if (validateCh (X1)) {\n\n            X1 = check (X1);\n\n            super.replaceText (start, end, X1);\n\n            if (max > 0) verifyLengh ();\n\n        }\n\n    } else {\n\n        X1 = check (X1);\n\n        super.replaceText (start, end, X1);\n\n        if (max > 0) verifyLengh ();\n\n    }\n\n}\n"}
{"idx": 1002, "func": "public void replaceText (int start, int end, String X1) {\n\n    String oldValue = getText ();\n\n    if (! X1.matches (\"[A-Za-z]\") && ! X1.matches (\"[\\\\\\\\!\\\"#$%&()*+,./:;<=>?@\\\\[\\\\]^_{|}~]+\")) {\n\n        super.replaceText (start, end, X1);\n\n    }\n\n    if (getText ().length () > 2) {\n\n        setText (oldValue);\n\n    }\n\n}\n"}
{"idx": 101, "func": "public static void main (String [] args) {\n\n    String text = \"the quick brown fox jumps fox fox over the lazy dog brown\";\n\n    String [] keys = text.split (\" \");\n\n    String [] X1;\n\n    int count = 0;\n\n    System.out.println (text);\n\n    X1 = getUniqueKeys (keys);\n\n    for (String key : X1) {\n\n        if (null == key) {\n\n            break;\n\n        }\n\n        for (String s : keys) {\n\n            if (key.equals (s)) {\n\n                count ++;\n\n            }\n\n        }\n\n        System.out.println (\"Count of [\" + key + \"] is : \" + count);\n\n        count = 0;\n\n    }\n\n}\n"}
{"idx": 10101, "func": "public void type (CharSequence chars, int ms) {\n\n    ms = ms > 0 ? ms : 0;\n\n    for (int X1 = 0, len = chars.length ();\n\n    X1 < len; X1 ++) {\n\n        char c = chars.charAt (X1);\n\n        AWTKeyStroke keyStroke = getKeyStroke (c);\n\n        int keyCode = keyStroke.getKeyCode ();\n\n        boolean shift = Character.isUpperCase (c) || keyStroke.getModifiers () == (SHIFT_DOWN_MASK + 1);\n\n        if (shift) {\n\n            robot.keyPress (KeyEvent.VK_SHIFT);\n\n        }\n\n        robot.keyPress (keyCode);\n\n        robot.keyRelease (keyCode);\n\n        if (shift) {\n\n            robot.keyRelease (KeyEvent.VK_SHIFT);\n\n        }\n\n        if (ms > 0) {\n\n            robot.delay (ms);\n\n        }\n\n    }\n\n}\n"}
{"idx": 10102, "func": "public void type (String text) {\n\n    char c;\n\n    for (int X1 = 0;\n\n    X1 < text.length (); X1 ++) {\n\n        c = text.charAt (X1);\n\n        if (c <= 31 || c == 129) {\n\n            pressControlKey (c);\n\n        } else {\n\n            typeAsciiCode (c);\n\n        }\n\n    }\n\n}\n"}
{"idx": 102, "func": "public static void main (String [] args) {\n\n    String s = \"this is a this is this a this yes this is a this what it may be i do not care about this\";\n\n    String a [] = s.split (\" \");\n\n    Map < String, Integer > words = new HashMap < > ();\n\n    for (String X1 : a) {\n\n        if (words.containsKey (X1)) {\n\n            words.put (X1, 1 + words.get (X1));\n\n        } else {\n\n            words.put (X1, 1);\n\n        }\n\n    }\n\n    System.out.println (words);\n\n}\n"}
{"idx": 10201, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            X1 (VK_A);\n\n            break;\n\n        case 'b' :\n\n            X1 (VK_B);\n\n            break;\n\n        case 'c' :\n\n            X1 (VK_C);\n\n            break;\n\n        case 'd' :\n\n            X1 (VK_D);\n\n            break;\n\n        case 'e' :\n\n            X1 (VK_E);\n\n            break;\n\n        case 'f' :\n\n            X1 (VK_F);\n\n            break;\n\n        case 'g' :\n\n            X1 (VK_G);\n\n            break;\n\n        case 'h' :\n\n            X1 (VK_H);\n\n            break;\n\n        case 'i' :\n\n            X1 (VK_I);\n\n            break;\n\n        case 'j' :\n\n            X1 (VK_J);\n\n            break;\n\n        case 'k' :\n\n            X1 (VK_K);\n\n            break;\n\n        case 'l' :\n\n            X1 (VK_L);\n\n            break;\n\n        case 'm' :\n\n            X1 (VK_M);\n\n            break;\n\n        case 'n' :\n\n            X1 (VK_N);\n\n            break;\n\n        case 'o' :\n\n            X1 (VK_O);\n\n            break;\n\n        case 'p' :\n\n            X1 (VK_P);\n\n            break;\n\n        case 'q' :\n\n            X1 (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            X1 (VK_R);\n\n            break;\n\n        case 's' :\n\n            X1 (VK_S);\n\n            break;\n\n        case 't' :\n\n            X1 (VK_T);\n\n            break;\n\n        case 'u' :\n\n            X1 (VK_U);\n\n            break;\n\n        case 'v' :\n\n            X1 (VK_V);\n\n            break;\n\n        case 'w' :\n\n            X1 (VK_W);\n\n            break;\n\n        case 'x' :\n\n            X1 (VK_X);\n\n            break;\n\n        case 'y' :\n\n            X1 (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            X1 (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            X1 (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            X1 (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            X1 (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            X1 (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            X1 (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            X1 (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            X1 (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            X1 (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            X1 (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            X1 (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            X1 (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            X1 (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            X1 (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            X1 (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            X1 (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            X1 (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            X1 (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            X1 (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            X1 (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            X1 (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            X1 (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            X1 (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            X1 (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            X1 (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            X1 (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            X1 (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            X1 (VK_0);\n\n            break;\n\n        case '1' :\n\n            X1 (VK_1);\n\n            break;\n\n        case '2' :\n\n            X1 (VK_2);\n\n            break;\n\n        case '3' :\n\n            X1 (VK_3);\n\n            break;\n\n        case '4' :\n\n            X1 (VK_4);\n\n            break;\n\n        case '5' :\n\n            X1 (VK_5);\n\n            break;\n\n        case '6' :\n\n            X1 (VK_6);\n\n            break;\n\n        case '7' :\n\n            X1 (VK_7);\n\n            break;\n\n        case '8' :\n\n            X1 (VK_8);\n\n            break;\n\n        case '9' :\n\n            X1 (VK_9);\n\n            break;\n\n        case '-' :\n\n            X1 (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            X1 (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            X1 (VK_SHIFT, VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            X1 (VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            X1 (VK_AT);\n\n            break;\n\n        case '#' :\n\n            X1 (VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            X1 (VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            X1 (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            X1 (VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            X1 (VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            X1 (VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            X1 (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            X1 (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            X1 (VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            X1 (VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            X1 (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            X1 (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            X1 (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            X1 (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            X1 (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            X1 (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            X1 (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            X1 (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            X1 (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            X1 (VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            X1 (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            X1 (VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            X1 (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            X1 (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            X1 (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            X1 (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            X1 (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            X1 (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            X1 (VK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 10202, "func": "private void type (char X1) {\n\n    handleSpecialCharacter (X1);\n\n    if (Character.isLowerCase (X1)) {\n\n        typeCharacter (Character.toUpperCase (X1));\n\n    }\n\n    if (Character.isUpperCase (X1)) {\n\n        typeShiftCharacter (X1);\n\n    }\n\n    if (Character.isDigit (X1)) {\n\n        typeCharacter (X1);\n\n    }\n\n}\n"}
{"idx": 10301, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            X1 (VK_A);\n\n            break;\n\n        case 'b' :\n\n            X1 (VK_B);\n\n            break;\n\n        case 'c' :\n\n            X1 (VK_C);\n\n            break;\n\n        case 'd' :\n\n            X1 (VK_D);\n\n            break;\n\n        case 'e' :\n\n            X1 (VK_E);\n\n            break;\n\n        case 'f' :\n\n            X1 (VK_F);\n\n            break;\n\n        case 'g' :\n\n            X1 (VK_G);\n\n            break;\n\n        case 'h' :\n\n            X1 (VK_H);\n\n            break;\n\n        case 'i' :\n\n            X1 (VK_I);\n\n            break;\n\n        case 'j' :\n\n            X1 (VK_J);\n\n            break;\n\n        case 'k' :\n\n            X1 (VK_K);\n\n            break;\n\n        case 'l' :\n\n            X1 (VK_L);\n\n            break;\n\n        case 'm' :\n\n            X1 (VK_M);\n\n            break;\n\n        case 'n' :\n\n            X1 (VK_N);\n\n            break;\n\n        case 'o' :\n\n            X1 (VK_O);\n\n            break;\n\n        case 'p' :\n\n            X1 (VK_P);\n\n            break;\n\n        case 'q' :\n\n            X1 (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            X1 (VK_R);\n\n            break;\n\n        case 's' :\n\n            X1 (VK_S);\n\n            break;\n\n        case 't' :\n\n            X1 (VK_T);\n\n            break;\n\n        case 'u' :\n\n            X1 (VK_U);\n\n            break;\n\n        case 'v' :\n\n            X1 (VK_V);\n\n            break;\n\n        case 'w' :\n\n            X1 (VK_W);\n\n            break;\n\n        case 'x' :\n\n            X1 (VK_X);\n\n            break;\n\n        case 'y' :\n\n            X1 (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            X1 (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            X1 (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            X1 (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            X1 (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            X1 (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            X1 (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            X1 (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            X1 (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            X1 (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            X1 (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            X1 (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            X1 (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            X1 (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            X1 (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            X1 (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            X1 (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            X1 (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            X1 (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            X1 (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            X1 (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            X1 (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            X1 (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            X1 (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            X1 (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            X1 (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            X1 (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            X1 (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            X1 (VK_0);\n\n            break;\n\n        case '1' :\n\n            X1 (VK_1);\n\n            break;\n\n        case '2' :\n\n            X1 (VK_2);\n\n            break;\n\n        case '3' :\n\n            X1 (VK_3);\n\n            break;\n\n        case '4' :\n\n            X1 (VK_4);\n\n            break;\n\n        case '5' :\n\n            X1 (VK_5);\n\n            break;\n\n        case '6' :\n\n            X1 (VK_6);\n\n            break;\n\n        case '7' :\n\n            X1 (VK_7);\n\n            break;\n\n        case '8' :\n\n            X1 (VK_8);\n\n            break;\n\n        case '9' :\n\n            X1 (VK_9);\n\n            break;\n\n        case '-' :\n\n            X1 (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            X1 (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            X1 (VK_SHIFT, VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            X1 (VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            X1 (VK_AT);\n\n            break;\n\n        case '#' :\n\n            X1 (VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            X1 (VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            X1 (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            X1 (VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            X1 (VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            X1 (VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            X1 (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            X1 (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            X1 (VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            X1 (VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            X1 (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            X1 (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            X1 (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            X1 (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            X1 (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            X1 (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            X1 (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            X1 (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            X1 (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            X1 (VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            X1 (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            X1 (VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            X1 (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            X1 (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            X1 (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            X1 (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            X1 (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            X1 (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            X1 (VK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 10302, "func": "public void type (String X1) {\n\n    char c;\n\n    for (int ii = 0;\n\n    ii < X1.length (); ii ++) {\n\n        c = X1.charAt (ii);\n\n        if (c <= 31 || c == 129) {\n\n            pressControlKey (c);\n\n        } else {\n\n            typeAsciiCode (c);\n\n        }\n\n    }\n\n}\n"}
{"idx": 10401, "func": "private void type (char X1) {\n\n    handleSpecialCharacter (X1);\n\n    if (Character.isLowerCase (X1)) {\n\n        typeCharacter (Character.toUpperCase (X1));\n\n    }\n\n    if (Character.isUpperCase (X1)) {\n\n        typeShiftCharacter (X1);\n\n    }\n\n    if (Character.isDigit (X1)) {\n\n        typeCharacter (X1);\n\n    }\n\n}\n"}
{"idx": 10402, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            doType (VK_A);\n\n            break;\n\n        case 'b' :\n\n            doType (VK_B);\n\n            break;\n\n        case 'c' :\n\n            doType (VK_C);\n\n            break;\n\n        case 'd' :\n\n            doType (VK_D);\n\n            break;\n\n        case 'e' :\n\n            doType (VK_E);\n\n            break;\n\n        case 'f' :\n\n            doType (VK_F);\n\n            break;\n\n        case 'g' :\n\n            doType (VK_G);\n\n            break;\n\n        case 'h' :\n\n            doType (VK_H);\n\n            break;\n\n        case 'i' :\n\n            doType (VK_I);\n\n            break;\n\n        case 'j' :\n\n            doType (VK_J);\n\n            break;\n\n        case 'k' :\n\n            doType (VK_K);\n\n            break;\n\n        case 'l' :\n\n            doType (VK_L);\n\n            break;\n\n        case 'm' :\n\n            doType (VK_M);\n\n            break;\n\n        case 'n' :\n\n            doType (VK_N);\n\n            break;\n\n        case 'o' :\n\n            doType (VK_O);\n\n            break;\n\n        case 'p' :\n\n            doType (VK_P);\n\n            break;\n\n        case 'q' :\n\n            doType (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            doType (VK_R);\n\n            break;\n\n        case 's' :\n\n            doType (VK_S);\n\n            break;\n\n        case 't' :\n\n            doType (VK_T);\n\n            break;\n\n        case 'u' :\n\n            doType (X1);\n\n            break;\n\n        case 'v' :\n\n            doType (VK_V);\n\n            break;\n\n        case 'w' :\n\n            doType (VK_W);\n\n            break;\n\n        case 'x' :\n\n            doType (VK_X);\n\n            break;\n\n        case 'y' :\n\n            doType (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            doType (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            doType (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            doType (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            doType (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            doType (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            doType (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            doType (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            doType (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            doType (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            doType (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            doType (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            doType (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            doType (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            doType (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            doType (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            doType (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            doType (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            doType (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            doType (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            doType (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            doType (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            doType (VK_SHIFT, X1);\n\n            break;\n\n        case 'V' :\n\n            doType (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            doType (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            doType (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            doType (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            doType (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            doType (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            doType (VK_0);\n\n            break;\n\n        case '1' :\n\n            doType (VK_1);\n\n            break;\n\n        case '2' :\n\n            doType (VK_2);\n\n            break;\n\n        case '3' :\n\n            doType (VK_3);\n\n            break;\n\n        case '4' :\n\n            doType (VK_4);\n\n            break;\n\n        case '5' :\n\n            doType (VK_5);\n\n            break;\n\n        case '6' :\n\n            doType (VK_6);\n\n            break;\n\n        case '7' :\n\n            doType (VK_7);\n\n            break;\n\n        case '8' :\n\n            doType (VK_8);\n\n            break;\n\n        case '9' :\n\n            doType (VK_9);\n\n            break;\n\n        case '-' :\n\n            doType (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            doType (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            doType (VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            doType (VK_SHIFT, VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            doType (VK_SHIFT, VK_AT);\n\n            break;\n\n        case '#' :\n\n            doType (VK_SHIFT, VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            doType (VK_SHIFT, VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            doType (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            doType (VK_SHIFT, VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            doType (VK_SHIFT, VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            doType (VK_SHIFT, VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            doType (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            doType (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            doType (VK_SHIFT, VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            doType (VK_SHIFT, VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            doType (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            doType (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            doType (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            doType (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            doType (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            doType (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            doType (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            doType (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            doType (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            doType (VK_SHIFT, VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            doType (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            doType (VK_SHIFT, VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            doType (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            doType (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            doType (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            doType (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            doType (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            doType (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            doType (VK_SPACE);\n\n            break;\n\n        case '\\b' :\n\n            doType (VK_BACK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 10501, "func": "private void type (char X1) {\n\n    handleSpecialCharacter (X1);\n\n    if (Character.isLowerCase (X1)) {\n\n        typeCharacter (Character.toUpperCase (X1));\n\n    }\n\n    if (Character.isUpperCase (X1)) {\n\n        typeShiftCharacter (X1);\n\n    }\n\n    if (Character.isDigit (X1)) {\n\n        typeCharacter (X1);\n\n    }\n\n}\n"}
{"idx": 10502, "func": "public void type (String text) {\n\n    char c;\n\n    for (int X1 = 0;\n\n    X1 < text.length (); X1 ++) {\n\n        c = text.charAt (X1);\n\n        if (c <= 31 || c == 129) {\n\n            pressControlKey (c);\n\n        } else {\n\n            typeAsciiCode (c);\n\n        }\n\n    }\n\n}\n"}
{"idx": 10601, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            X1 (VK_A);\n\n            break;\n\n        case 'b' :\n\n            X1 (VK_B);\n\n            break;\n\n        case 'c' :\n\n            X1 (VK_C);\n\n            break;\n\n        case 'd' :\n\n            X1 (VK_D);\n\n            break;\n\n        case 'e' :\n\n            X1 (VK_E);\n\n            break;\n\n        case 'f' :\n\n            X1 (VK_F);\n\n            break;\n\n        case 'g' :\n\n            X1 (VK_G);\n\n            break;\n\n        case 'h' :\n\n            X1 (VK_H);\n\n            break;\n\n        case 'i' :\n\n            X1 (VK_I);\n\n            break;\n\n        case 'j' :\n\n            X1 (VK_J);\n\n            break;\n\n        case 'k' :\n\n            X1 (VK_K);\n\n            break;\n\n        case 'l' :\n\n            X1 (VK_L);\n\n            break;\n\n        case 'm' :\n\n            X1 (VK_M);\n\n            break;\n\n        case 'n' :\n\n            X1 (VK_N);\n\n            break;\n\n        case 'o' :\n\n            X1 (VK_O);\n\n            break;\n\n        case 'p' :\n\n            X1 (VK_P);\n\n            break;\n\n        case 'q' :\n\n            X1 (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            X1 (VK_R);\n\n            break;\n\n        case 's' :\n\n            X1 (VK_S);\n\n            break;\n\n        case 't' :\n\n            X1 (VK_T);\n\n            break;\n\n        case 'u' :\n\n            X1 (VK_U);\n\n            break;\n\n        case 'v' :\n\n            X1 (VK_V);\n\n            break;\n\n        case 'w' :\n\n            X1 (VK_W);\n\n            break;\n\n        case 'x' :\n\n            X1 (VK_X);\n\n            break;\n\n        case 'y' :\n\n            X1 (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            X1 (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            X1 (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            X1 (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            X1 (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            X1 (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            X1 (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            X1 (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            X1 (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            X1 (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            X1 (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            X1 (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            X1 (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            X1 (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            X1 (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            X1 (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            X1 (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            X1 (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            X1 (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            X1 (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            X1 (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            X1 (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            X1 (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            X1 (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            X1 (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            X1 (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            X1 (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            X1 (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            X1 (VK_0);\n\n            break;\n\n        case '1' :\n\n            X1 (VK_1);\n\n            break;\n\n        case '2' :\n\n            X1 (VK_2);\n\n            break;\n\n        case '3' :\n\n            X1 (VK_3);\n\n            break;\n\n        case '4' :\n\n            X1 (VK_4);\n\n            break;\n\n        case '5' :\n\n            X1 (VK_5);\n\n            break;\n\n        case '6' :\n\n            X1 (VK_6);\n\n            break;\n\n        case '7' :\n\n            X1 (VK_7);\n\n            break;\n\n        case '8' :\n\n            X1 (VK_8);\n\n            break;\n\n        case '9' :\n\n            X1 (VK_9);\n\n            break;\n\n        case '-' :\n\n            X1 (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            X1 (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            X1 (VK_SHIFT, VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            X1 (VK_SHIFT, VK_AT);\n\n            break;\n\n        case '#' :\n\n            X1 (VK_SHIFT, VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            X1 (VK_SHIFT, VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            X1 (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            X1 (VK_SHIFT, VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            X1 (VK_SHIFT, VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            X1 (VK_SHIFT, VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            X1 (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            X1 (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            X1 (VK_SHIFT, VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            X1 (VK_SHIFT, VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            X1 (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            X1 (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            X1 (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            X1 (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            X1 (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            X1 (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            X1 (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            X1 (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            X1 (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            X1 (VK_SHIFT, VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            X1 (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            X1 (VK_SHIFT, VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            X1 (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            X1 (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            X1 (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            X1 (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            X1 (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            X1 (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            X1 (VK_SPACE);\n\n            break;\n\n        case '\\b' :\n\n            X1 (VK_BACK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 10602, "func": "public void type (String text) {\n\n    char X1;\n\n    for (int ii = 0;\n\n    ii < text.length (); ii ++) {\n\n        X1 = text.charAt (ii);\n\n        if (X1 <= 31 || X1 == 129) {\n\n            pressControlKey (X1);\n\n        } else {\n\n            typeAsciiCode (X1);\n\n        }\n\n    }\n\n}\n"}
{"idx": 10701, "func": "public void run () {\n\n    try {\n\n        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());\n\n    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {\n\n    }\n\n    JFrame X1 = new JFrame ();\n\n    X1.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    X1.setLayout (new BorderLayout ());\n\n    X1.add (new BlinkPane ());\n\n    X1.pack ();\n\n    X1.setLocationRelativeTo (null);\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 10702, "func": "public void run () {\n\n    Blink X1 = new Blink (blinkPane, true);\n\n    Blink blinkOff = new Blink (blinkPane, false);\n\n    for (int index = 0;\n\n    index < 10; index ++) {\n\n        if (index % 2 == 0) {\n\n            SwingUtilities.invokeLater (X1);\n\n        } else {\n\n            SwingUtilities.invokeLater (blinkOff);\n\n        }\n\n        try {\n\n            Thread.sleep (125);\n\n        } catch (InterruptedException ex) {\n\n        }\n\n    }\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            blinkPane.reset ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 10801, "func": "public static File createTempDir () throws X1 {\n\n    final File sysTempDir = new File (System.getProperty (\"java.io.tmpdir\"));\n\n    File newTempDir;\n\n    final int maxAttempts = 9;\n\n    int attemptCount = 0;\n\n    do {\n\n        attemptCount ++;\n\n        if (attemptCount > maxAttempts) {\n\n            throw new X1 (\"The highly improbable has occurred! Failed to \" + \"create a unique temporary directory after \" + maxAttempts + \" attempts.\");\n\n        }\n\n        String dirName = UUID.randomUUID ().toString ();\n\n        newTempDir = new File (sysTempDir, dirName);\n\n    } while (newTempDir.exists ());\n\n    if (newTempDir.mkdirs ()) {\n\n        return newTempDir;\n\n    } else {\n\n        throw new X1 (\"Failed to create temp dir named \" + newTempDir.getAbsolutePath ());\n\n    }\n\n}\n"}
{"idx": 10802, "func": "public static File createTempDir () {\n\n    File baseDir = new File (System.getProperty (\"java.io.tmpdir\"));\n\n    String baseName = System.currentTimeMillis () + \"-\";\n\n    for (int counter = 0;\n\n    counter < TEMP_DIR_ATTEMPTS; counter ++) {\n\n        File X1 = new File (baseDir, baseName + counter);\n\n        if (X1.mkdir ()) {\n\n            return X1;\n\n        }\n\n    }\n\n    throw new IllegalStateException (\"Failed to create directory within \" + TEMP_DIR_ATTEMPTS + \" attempts (tried \" + baseName + \"0 to \" + baseName + (TEMP_DIR_ATTEMPTS - 1) + ')');\n\n}\n"}
{"idx": 10901, "func": "public static File createTempDir () throws IOException {\n\n    final File sysTempDir = new File (System.getProperty (\"java.io.tmpdir\"));\n\n    File newTempDir;\n\n    final int X1 = 9;\n\n    int attemptCount = 0;\n\n    do {\n\n        attemptCount ++;\n\n        if (attemptCount > X1) {\n\n            throw new IOException (\"The highly improbable has occurred! Failed to \" + \"create a unique temporary directory after \" + X1 + \" attempts.\");\n\n        }\n\n        String dirName = UUID.randomUUID ().toString ();\n\n        newTempDir = new File (sysTempDir, dirName);\n\n    } while (newTempDir.exists ());\n\n    if (newTempDir.mkdirs ()) {\n\n        return newTempDir;\n\n    } else {\n\n        throw new IOException (\"Failed to create temp dir named \" + newTempDir.getAbsolutePath ());\n\n    }\n\n}\n"}
{"idx": 10902, "func": "public static File createTempDir () {\n\n    final String baseTempPath = System.getProperty (\"java.io.tmpdir\");\n\n    Random rand = new Random ();\n\n    int X1 = 1 + rand.nextInt ();\n\n    File tempDir = new File (baseTempPath + File.separator + \"tempDir\" + X1);\n\n    if (tempDir.exists () == false) {\n\n        tempDir.mkdir ();\n\n    }\n\n    tempDir.deleteOnExit ();\n\n    return tempDir;\n\n}\n"}
{"idx": 11001, "func": "public static Node reverse (Node root) {\n\n    if (root == null || root.next == null) {\n\n        return root;\n\n    }\n\n    Node X1, prev, next;\n\n    X1 = root;\n\n    prev = next = null;\n\n    while (X1 != null) {\n\n        next = X1.next;\n\n        X1.next = prev;\n\n        prev = X1;\n\n        X1 = next;\n\n    }\n\n    return prev;\n\n}\n"}
{"idx": 11002, "func": "public ListNode reverse (ListNode toBeNextNode, ListNode X1) {\n\n    ListNode currentHead = X1;\n\n    if ((X1 == null || X1.next == null) && toBeNextNode == null) return currentHead;\n\n    if (X1.next != null) currentHead = reverse (X1, X1.next);\n\n    X1.next = toBeNextNode;\n\n    return currentHead;\n\n}\n"}
{"idx": 1101, "func": "public void replaceSelection (String text) {\n\n    if (! characters.equals (\"\")) {\n\n        if (validateCh (text)) {\n\n            text = check (text);\n\n            super.replaceSelection (text);\n\n            if (max > 0) X1 ();\n\n        }\n\n    } else {\n\n        text = check (text);\n\n        super.replaceSelection (text);\n\n        if (max > 0) X1 ();\n\n    }\n\n}\n"}
{"idx": 1102, "func": "public void replaceSelection (X1 text) {\n\n    X1 oldValue = getText ();\n\n    if (! text.matches (\"[A-Za-z]\") && ! text.matches (\"[\\\\\\\\!\\\"#$%&()*+,./:;<=>?@\\\\[\\\\]^_{|}~]+\")) {\n\n        super.replaceSelection (text);\n\n    }\n\n    if (getText ().length () > 2) {\n\n        setText (oldValue);\n\n    }\n\n}\n"}
{"idx": 11101, "func": "public static Node reverse (Node X1) {\n\n    if (X1 == null || X1.next == null) {\n\n        return X1;\n\n    }\n\n    Node curr, prev, next;\n\n    curr = X1;\n\n    prev = next = null;\n\n    while (curr != null) {\n\n        next = curr.next;\n\n        curr.next = prev;\n\n        prev = curr;\n\n        curr = next;\n\n    }\n\n    return prev;\n\n}\n"}
{"idx": 11102, "func": "Node reverse (Node n, Node p) {\n\n    if (n == null) return null;\n\n    if (n.X1 == null) {\n\n        n.X1 = p;\n\n        return n;\n\n    }\n\n    Node r = reverse (n.X1, n);\n\n    n.X1 = p;\n\n    return r;\n\n}\n"}
{"idx": 11201, "func": "public static Node reverse (Node root) {\n\n    if (root == null || root.next == null) {\n\n        return root;\n\n    }\n\n    Node curr, X1, next;\n\n    curr = root;\n\n    X1 = next = null;\n\n    while (curr != null) {\n\n        next = curr.next;\n\n        curr.next = X1;\n\n        X1 = curr;\n\n        curr = next;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 11202, "func": "public Node reverse (Node previous, Node current) {\n\n    if (previous == null) return null;\n\n    if (previous.equals (head)) previous.setNext (null);\n\n    if (current == null) {\n\n        head = previous;\n\n        return head;\n\n    } else {\n\n        Node X1 = current.getNext ();\n\n        current.setNext (previous);\n\n        reverse (current, X1);\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 11301, "func": "public ListNode reverse (ListNode toBeNextNode, ListNode X1) {\n\n    ListNode currentHead = X1;\n\n    if ((X1 == null || X1.next == null) && toBeNextNode == null) return currentHead;\n\n    if (X1.next != null) currentHead = reverse (X1, X1.next);\n\n    X1.next = toBeNextNode;\n\n    return currentHead;\n\n}\n"}
{"idx": 11302, "func": "X1 reverse (X1 n, X1 p) {\n\n    if (n == null) return null;\n\n    if (n.next == null) {\n\n        n.next = p;\n\n        return n;\n\n    }\n\n    X1 r = reverse (n.next, n);\n\n    n.next = p;\n\n    return r;\n\n}\n"}
{"idx": 11401, "func": "public ListNode reverse (ListNode toBeNextNode, ListNode currentNode) {\n\n    ListNode currentHead = currentNode;\n\n    if ((currentNode == null || currentNode.X1 == null) && toBeNextNode == null) return currentHead;\n\n    if (currentNode.X1 != null) currentHead = reverse (currentNode, currentNode.X1);\n\n    currentNode.X1 = toBeNextNode;\n\n    return currentHead;\n\n}\n"}
{"idx": 11402, "func": "public Node reverse (Node X1, Node current) {\n\n    if (X1 == null) return null;\n\n    if (X1.equals (head)) X1.setNext (null);\n\n    if (current == null) {\n\n        head = X1;\n\n        return head;\n\n    } else {\n\n        Node temp = current.getNext ();\n\n        current.setNext (X1);\n\n        reverse (current, temp);\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 11501, "func": "Node reverse (Node X1, Node p) {\n\n    if (X1 == null) return null;\n\n    if (X1.next == null) {\n\n        X1.next = p;\n\n        return X1;\n\n    }\n\n    Node r = reverse (X1.next, X1);\n\n    X1.next = p;\n\n    return r;\n\n}\n"}
{"idx": 11502, "func": "public Node reverse (Node previous, Node current) {\n\n    if (previous == null) return null;\n\n    if (previous.equals (X1)) previous.setNext (null);\n\n    if (current == null) {\n\n        X1 = previous;\n\n        return X1;\n\n    } else {\n\n        Node temp = current.getNext ();\n\n        current.setNext (previous);\n\n        reverse (current, temp);\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 11601, "func": "public static String camelCaser (String str) {\n\n    char [] X1 = str.toCharArray ();\n\n    X1 [0] = Character.toUpperCase (X1 [0]);\n\n    for (int i = 0;\n\n    i < X1.length; i ++) if (X1 [i] == '_') X1 [i + 1] = Character.toUpperCase (X1 [i + 1]);\n\n    String reply = new String (X1);\n\n    reply = reply.replace (\"_\", \"\");\n\n    return reply;\n\n}\n"}
{"idx": 11602, "func": "public static String camelCaser (String X1) {\n\n    String [] words = X1.split (\"_\");\n\n    String res = \"\";\n\n    for (String word : words) {\n\n        if (! word.isEmpty ()) {\n\n            res += Character.toUpperCase (word.charAt (0));\n\n            if (word.length () > 1) {\n\n                res += word.substring (1);\n\n            }\n\n        }\n\n    }\n\n    return res;\n\n}\n"}
{"idx": 11701, "func": "public static void main (String args []) {\n\n    System.out.println (\"Enter the date(dd/mm/yyyy):\");\n\n    Scanner scan = new Scanner (System.in);\n\n    String Date = scan.nextLine ();\n\n    try {\n\n        boolean dateValid = dateValidate (Date);\n\n        if (dateValid == true) {\n\n            SimpleDateFormat df = new SimpleDateFormat (\"dd/MM/yy\");\n\n            java.util.Date date = df.parse (Date);\n\n            df.applyPattern (\"EEE\");\n\n            String X1 = df.format (date);\n\n            if (X1.compareTo (\"Sat\") == 0 || X1.compareTo (\"Sun\") == 0) {\n\n                System.out.println (X1 + \": Weekend\");\n\n            } else {\n\n                System.out.println (X1 + \": Weekday\");\n\n            }\n\n        } else {\n\n            System.out.println (\"Invalid Date!!!\");\n\n        }\n\n    } catch (Exception e) {\n\n        System.out.println (\"Invalid Date Formats!!!\");\n\n    }\n\n}\n"}
{"idx": 11702, "func": "public static void main (String [] args) throws ParseException {\n\n    String month = \"08\";\n\n    String day = \"05\";\n\n    String year = \"2015\";\n\n    String inputDateStr = String.format (\"%s/%s/%s\", day, month, year);\n\n    Date X1 = new SimpleDateFormat (\"dd/MM/yyyy\").parse (inputDateStr);\n\n    Calendar calendar = Calendar.getInstance ();\n\n    calendar.setTime (X1);\n\n    String dayOfWeek = calendar.getDisplayName (Calendar.DAY_OF_WEEK, Calendar.LONG, Locale.US).toUpperCase ();\n\n    System.out.println (dayOfWeek);\n\n}\n"}
{"idx": 11801, "func": "public static void main (String args []) {\n\n    System.out.X1 (\"Enter the date(dd/mm/yyyy):\");\n\n    Scanner scan = new Scanner (System.in);\n\n    String Date = scan.nextLine ();\n\n    try {\n\n        boolean dateValid = dateValidate (Date);\n\n        if (dateValid == true) {\n\n            SimpleDateFormat df = new SimpleDateFormat (\"dd/MM/yy\");\n\n            java.util.Date date = df.parse (Date);\n\n            df.applyPattern (\"EEE\");\n\n            String day = df.format (date);\n\n            if (day.compareTo (\"Sat\") == 0 || day.compareTo (\"Sun\") == 0) {\n\n                System.out.X1 (day + \": Weekend\");\n\n            } else {\n\n                System.out.X1 (day + \": Weekday\");\n\n            }\n\n        } else {\n\n            System.out.X1 (\"Invalid Date!!!\");\n\n        }\n\n    } catch (Exception e) {\n\n        System.out.X1 (\"Invalid Date Formats!!!\");\n\n    }\n\n}\n"}
{"idx": 11802, "func": "public static void main (String [] args) throws ParseException, ParseException {\n\n    anchorDaysMap.put (X1.valueOf (0), new ArrayList < X1 > () {\n\n        {\n\n            add (X1.valueOf (1700));\n\n            add (X1.valueOf (2100));\n\n            add (X1.valueOf (2500));\n\n        }\n\n    }\n\n    );\n\n    anchorDaysMap.put (X1.valueOf (2), new ArrayList < X1 > () {\n\n        {\n\n            add (X1.valueOf (1600));\n\n            add (X1.valueOf (2000));\n\n            add (X1.valueOf (2400));\n\n        }\n\n    }\n\n    );\n\n    anchorDaysMap.put (X1.valueOf (3), new ArrayList < X1 > () {\n\n        {\n\n            add (X1.valueOf (1500));\n\n            add (X1.valueOf (1900));\n\n            add (X1.valueOf (2300));\n\n        }\n\n    }\n\n    );\n\n    anchorDaysMap.put (X1.valueOf (5), new ArrayList < X1 > () {\n\n        {\n\n            add (X1.valueOf (1800));\n\n            add (X1.valueOf (2200));\n\n            add (X1.valueOf (2600));\n\n        }\n\n    }\n\n    );\n\n    doomsdayDate.put (X1.valueOf (1), X1.valueOf (3));\n\n    doomsdayDate.put (X1.valueOf (2), X1.valueOf (14));\n\n    doomsdayDate.put (X1.valueOf (3), X1.valueOf (14));\n\n    doomsdayDate.put (X1.valueOf (4), X1.valueOf (4));\n\n    doomsdayDate.put (X1.valueOf (5), X1.valueOf (9));\n\n    doomsdayDate.put (X1.valueOf (6), X1.valueOf (6));\n\n    doomsdayDate.put (X1.valueOf (7), X1.valueOf (4));\n\n    doomsdayDate.put (X1.valueOf (8), X1.valueOf (8));\n\n    doomsdayDate.put (X1.valueOf (9), X1.valueOf (5));\n\n    doomsdayDate.put (X1.valueOf (10), X1.valueOf (10));\n\n    doomsdayDate.put (X1.valueOf (11), X1.valueOf (7));\n\n    doomsdayDate.put (X1.valueOf (12), X1.valueOf (12));\n\n    long time = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < 100000; i ++) {\n\n        int year = 1583 + new Random ().nextInt (500);\n\n        int month = 1 + new Random ().nextInt (12);\n\n        int day = 1 + new Random ().nextInt (7);\n\n        int twoDigitsYear = (year % 100);\n\n        int century = year - twoDigitsYear;\n\n        int adForCentury = getADCentury (century);\n\n        int dd = ((int) twoDigitsYear / 12) + twoDigitsYear % 12 + (int) ((twoDigitsYear % 12) / 4);\n\n        int referenceDay = doomsdayDate.get (month);\n\n        int gap = (day - referenceDay) % 7;\n\n        int result = (gap + adForCentury + dd) % 7;\n\n        if (result < 0) {\n\n            result *= - 1;\n\n        }\n\n        String dayDate = weekdays [(result + 1) % 8];\n\n    }\n\n    System.out.println (\"time (ms) : \" + (System.currentTimeMillis () - time));\n\n    time = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < 100000; i ++) {\n\n        Calendar c = Calendar.getInstance ();\n\n        c.setTime (new SimpleDateFormat (\"dd/MM/yyyy\").parse (\"12/04/1861\"));\n\n        int result2 = c.get (Calendar.DAY_OF_WEEK);\n\n    }\n\n    System.out.println (\"time (ms) : \" + (System.currentTimeMillis () - time));\n\n}\n"}
{"idx": 11901, "func": "public static void main (String [] args) throws ParseException {\n\n    String month = \"08\";\n\n    String day = \"05\";\n\n    String year = \"2015\";\n\n    String inputDateStr = String.format (\"%s/%s/%s\", day, month, year);\n\n    Date inputDate = new SimpleDateFormat (\"dd/MM/yyyy\").parse (inputDateStr);\n\n    Calendar X1 = Calendar.getInstance ();\n\n    X1.setTime (inputDate);\n\n    String dayOfWeek = X1.getDisplayName (Calendar.DAY_OF_WEEK, Calendar.LONG, Locale.US).toUpperCase ();\n\n    System.out.println (dayOfWeek);\n\n}\n"}
{"idx": 11902, "func": "public static void main (String [] args) throws ParseException, ParseException {\n\n    anchorDaysMap.X1 (Integer.valueOf (0), new ArrayList < Integer > () {\n\n        {\n\n            add (Integer.valueOf (1700));\n\n            add (Integer.valueOf (2100));\n\n            add (Integer.valueOf (2500));\n\n        }\n\n    }\n\n    );\n\n    anchorDaysMap.X1 (Integer.valueOf (2), new ArrayList < Integer > () {\n\n        {\n\n            add (Integer.valueOf (1600));\n\n            add (Integer.valueOf (2000));\n\n            add (Integer.valueOf (2400));\n\n        }\n\n    }\n\n    );\n\n    anchorDaysMap.X1 (Integer.valueOf (3), new ArrayList < Integer > () {\n\n        {\n\n            add (Integer.valueOf (1500));\n\n            add (Integer.valueOf (1900));\n\n            add (Integer.valueOf (2300));\n\n        }\n\n    }\n\n    );\n\n    anchorDaysMap.X1 (Integer.valueOf (5), new ArrayList < Integer > () {\n\n        {\n\n            add (Integer.valueOf (1800));\n\n            add (Integer.valueOf (2200));\n\n            add (Integer.valueOf (2600));\n\n        }\n\n    }\n\n    );\n\n    doomsdayDate.X1 (Integer.valueOf (1), Integer.valueOf (3));\n\n    doomsdayDate.X1 (Integer.valueOf (2), Integer.valueOf (14));\n\n    doomsdayDate.X1 (Integer.valueOf (3), Integer.valueOf (14));\n\n    doomsdayDate.X1 (Integer.valueOf (4), Integer.valueOf (4));\n\n    doomsdayDate.X1 (Integer.valueOf (5), Integer.valueOf (9));\n\n    doomsdayDate.X1 (Integer.valueOf (6), Integer.valueOf (6));\n\n    doomsdayDate.X1 (Integer.valueOf (7), Integer.valueOf (4));\n\n    doomsdayDate.X1 (Integer.valueOf (8), Integer.valueOf (8));\n\n    doomsdayDate.X1 (Integer.valueOf (9), Integer.valueOf (5));\n\n    doomsdayDate.X1 (Integer.valueOf (10), Integer.valueOf (10));\n\n    doomsdayDate.X1 (Integer.valueOf (11), Integer.valueOf (7));\n\n    doomsdayDate.X1 (Integer.valueOf (12), Integer.valueOf (12));\n\n    long time = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < 100000; i ++) {\n\n        int year = 1583 + new Random ().nextInt (500);\n\n        int month = 1 + new Random ().nextInt (12);\n\n        int day = 1 + new Random ().nextInt (7);\n\n        int twoDigitsYear = (year % 100);\n\n        int century = year - twoDigitsYear;\n\n        int adForCentury = getADCentury (century);\n\n        int dd = ((int) twoDigitsYear / 12) + twoDigitsYear % 12 + (int) ((twoDigitsYear % 12) / 4);\n\n        int referenceDay = doomsdayDate.get (month);\n\n        int gap = (day - referenceDay) % 7;\n\n        int result = (gap + adForCentury + dd) % 7;\n\n        if (result < 0) {\n\n            result *= - 1;\n\n        }\n\n        String dayDate = weekdays [(result + 1) % 8];\n\n    }\n\n    System.out.println (\"time (ms) : \" + (System.currentTimeMillis () - time));\n\n    time = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < 100000; i ++) {\n\n        Calendar c = Calendar.getInstance ();\n\n        c.setTime (new SimpleDateFormat (\"dd/MM/yyyy\").parse (\"12/04/1861\"));\n\n        int result2 = c.get (Calendar.DAY_OF_WEEK);\n\n    }\n\n    System.out.println (\"time (ms) : \" + (System.currentTimeMillis () - time));\n\n}\n"}
{"idx": 12001, "func": "public void onCreate (Bundle savedInstanceState) {\n\n    super.onCreate (savedInstanceState);\n\n    setContentView (R.layout.main);\n\n    X1 = (TextView) findViewById (R.id.empty);\n\n    mCountDownTimer = new CountDownTimer (mInitialTime, 1000) {\n\n        StringBuilder time = new StringBuilder ();\n\n        @Override\n\n        public void onFinish () {\n\n            X1.setText (DateUtils.formatElapsedTime (0));\n\n        }@Override\n\n        public void onTick (long millisUntilFinished) {\n\n            time.setLength (0);\n\n            if (millisUntilFinished > DateUtils.DAY_IN_MILLIS) {\n\n                long count = millisUntilFinished / DateUtils.DAY_IN_MILLIS;\n\n                if (count > 1) time.append (count).append (\" days \");\n\n                else time.append (count).append (\" day \");\n\n                millisUntilFinished %= DateUtils.DAY_IN_MILLIS;\n\n            }\n\n            time.append (DateUtils.formatElapsedTime (Math.round (millisUntilFinished / 1000d)));\n\n            X1.setText (time.toString ());\n\n        }}\n\n    .start ();\n\n}\n"}
{"idx": 12002, "func": "public void onCreate (Bundle savedInstanceState) {\n\n    super.onCreate (savedInstanceState);\n\n    tv = new TextView (this);\n\n    this.setContentView (tv);\n\n    SimpleDateFormat X1 = new SimpleDateFormat (\"dd.MM.yyyy, HH:mm\");\n\n    String oldTime = \"19.02.2018, 12:00\";\n\n    String NewTime = \"20.02.2018, 14:00\";\n\n    Date oldDate, newDate;\n\n    try {\n\n        oldDate = X1.parse (oldTime);\n\n        newDate = X1.parse (NewTime);\n\n        oldLong = oldDate.getTime ();\n\n        NewLong = newDate.getTime ();\n\n        diff = NewLong - oldLong;\n\n    } catch (ParseException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    MyCount counter = new MyCount (diff, 1000);\n\n    counter.start ();\n\n}\n"}
{"idx": 1201, "func": "public int countLines (String filename) throws IOException {\n\n    LineNumberReader reader = new LineNumberReader (new FileReader (filename));\n\n    int cnt = 0;\n\n    String X1 = \"\";\n\n    while ((X1 = reader.readLine ()) != null) {\n\n    }\n\n    cnt = reader.getLineNumber ();\n\n    reader.close ();\n\n    return cnt;\n\n}\n"}
{"idx": 1202, "func": "static long countLines (InputStream is) throws IOException {\n\n    try (LineNumberReader lnr = new LineNumberReader (new InputStreamReader (is))) {\n\n        char [] buf = new char [8192];\n\n        int X1, previousN = - 1;\n\n        while ((X1 = lnr.read (buf)) != - 1) {\n\n            previousN = X1;\n\n        }\n\n        int ln = lnr.getLineNumber ();\n\n        if (previousN == - 1) {\n\n            return 0;\n\n        } else {\n\n            char lastChar = buf [previousN - 1];\n\n            if (lastChar == '\\n' || lastChar == '\\r') {\n\n                return ln;\n\n            }\n\n        }\n\n        return ln + 1;\n\n    }\n\n}\n"}
{"idx": 12101, "func": "public static void main (String [] args) {\n\n    LinkedList < String > X1 = new LinkedList < > ();\n\n    while (! StdIn.isEmpty ()) {\n\n        String input = StdIn.readString ();\n\n        if (input.equals (\"print\")) {\n\n            StdOut.println (X1.toString ());\n\n            continue;\n\n        }\n\n        if (input.charAt (0) == ('+')) {\n\n            X1.add (input.substring (1));\n\n            continue;\n\n        }\n\n        if (input.charAt (0) == ('-')) {\n\n            X1.remove (input.substring (1));\n\n            continue;\n\n        }\n\n        break;\n\n    }\n\n}\n"}
{"idx": 12102, "func": "public static void main (String [] args) {\n\n    Node root = null;\n\n    DataInputStream reader = new DataInputStream (System.in);\n\n    int X1 = 0;\n\n    while (X1 != 6) {\n\n        try {\n\n            System.out.println (\"Enter Option:\\n1:Insert Front 2:Delete Front 3:Insert Rear 4:Delete Rear 5:Display List 6:Exit\");\n\n            X1 = Integer.parseInt (reader.readLine ());\n\n            switch (X1) {\n\n                case 1 :\n\n                    System.out.println (\"Enter Value: \");\n\n                    int val = Integer.parseInt (reader.readLine ());\n\n                    root = insertNodeFront (val, root);\n\n                    display (root);\n\n                    break;\n\n                case 2 :\n\n                    root = removeNodeFront (root);\n\n                    display (root);\n\n                    break;\n\n                case 3 :\n\n                    System.out.println (\"Enter Value: \");\n\n                    val = Integer.parseInt (reader.readLine ());\n\n                    root = insertNodeRear (val, root);\n\n                    display (root);\n\n                    break;\n\n                case 4 :\n\n                    root = removeNodeRear (root);\n\n                    display (root);\n\n                    break;\n\n                case 5 :\n\n                    display (root);\n\n                    break;\n\n                default :\n\n                    System.out.println (\"Invalid Option\");\n\n                    break;\n\n            }\n\n        } catch (Exception e) {\n\n            e.printStackTrace ();\n\n        }\n\n    }\n\n    System.out.println (\"Exited!!!\");\n\n    try {\n\n        reader.close ();\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 12201, "func": "private static void X1 (Node node) {\n\n    for (int i = 0;\n\n    i < node.childNodesSize ();) {\n\n        Node child = node.childNode (i);\n\n        if (child.nodeName ().equals (\"#comment\")) child.remove ();\n\n        else {\n\n            X1 (child);\n\n            i ++;\n\n        }\n\n    }\n\n}\n"}
{"idx": 12202, "func": "private void removeComments (Element article) {\n\n    article.filter (new NodeFilter () {\n\n        @Override\n\n        public FilterResult tail (X1 node, int depth) {\n\n            if (node instanceof Comment) {\n\n                return FilterResult.REMOVE;\n\n            }\n\n            return FilterResult.CONTINUE;\n\n        }@Override\n\n        public FilterResult head (X1 node, int depth) {\n\n            if (node instanceof Comment) {\n\n                return FilterResult.REMOVE;\n\n            }\n\n            return FilterResult.CONTINUE;\n\n        }}\n\n    );\n\n}\n"}
{"idx": 12301, "func": "public static void main (String [] args) {\n\n    for (int X1 = 0;\n\n    X1 < 5; X1 ++) {\n\n        Link.insert (X1 + 5);\n\n    }\n\n    Link.printList ();\n\n    Link.deletefromFirst ();\n\n    Link.printList ();\n\n}\n"}
{"idx": 12302, "func": "public static void main (String [] args) {\n\n    LinkList list = new LinkList ();\n\n    list.insert (1, 1.01);\n\n    list.insert (2, 2.02);\n\n    list.insert (3, 3.03);\n\n    list.insert (4, 4.04);\n\n    list.insert (5, 5.05);\n\n    list.printList ();\n\n    while (! list.isEmpty ()) {\n\n        Link X1 = list.delete ();\n\n        System.out.print (\"deleted: \");\n\n        X1.printLink ();\n\n        System.out.println (\"\");\n\n    }\n\n    list.printList ();\n\n}\n"}
{"idx": 12401, "func": "public static void main (String [] args) {\n\n    X1 : for (int i = 0;\n\n    i < 5; i ++) {\n\n        for (int j = 0;\n\n        j < 5; j ++) {\n\n            if (i * j > 6) {\n\n                System.out.println (\"Breaking\");\n\n                break X1;\n\n            }\n\n            System.out.println (i + \" \" + j);\n\n        }\n\n    }\n\n    System.out.println (\"Done\");\n\n}\n"}
{"idx": 12402, "func": "public static void main (String [] args) {\n\n    for (int i = 0;\n\n    i < 9; i ++) {\n\n        for (int X1 = 0;\n\n        X1 < 9; X1 ++) {\n\n            for (int k = 0;\n\n            k < 9; k ++) {\n\n                if (condition1) {\n\n                    System.out.println (\"Breaking from Loop K and J\");\n\n                    k = 9;\n\n                    X1 = 9;\n\n                }\n\n                if (condition2) {\n\n                    System.out.println (\"Breaking from Loop K, J and I\");\n\n                    k = 9;\n\n                    X1 = 9;\n\n                    i = 9;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    System.out.println (\"End of I , J , K\");\n\n}\n"}
{"idx": 12501, "func": "public static String center (String X1, int len) {\n\n    if (len <= X1.length ()) return X1.substring (0, len);\n\n    int before = (len - X1.length ()) / 2;\n\n    if (before == 0) return String.format (\"%-\" + len + \"s\", X1);\n\n    int rest = len - before;\n\n    return String.format (\"%\" + before + \"s%-\" + rest + \"s\", \"\", X1);\n\n}\n"}
{"idx": 12502, "func": "public static String center (String s, int size, char pad) {\n\n    if (s == null || size <= s.length ()) return s;\n\n    StringBuilder X1 = new StringBuilder (size);\n\n    for (int i = 0;\n\n    i < (size - s.length ()) / 2; i ++) {\n\n        X1.append (pad);\n\n    }\n\n    X1.append (s);\n\n    while (X1.length () < size) {\n\n        X1.append (pad);\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 12601, "func": "public void start (Stage X1) {\n\n    try {\n\n        stage = X1;\n\n        gotoLogin ();\n\n        X1.show ();\n\n    } catch (Exception ex) {\n\n        Logger.getLogger (App.class.getName ()).log (Level.SEVERE, null, ex);\n\n    }\n\n}\n"}
{"idx": 12602, "func": "@Override\n\npublic void start (Stage stage) throws Exception {\n\n    URL location = getClass ().getResource (\"Main.fxml\");\n\n    FXMLLoader fxmlLoader = new FXMLLoader ();\n\n    fxmlLoader.setLocation (location);\n\n    fxmlLoader.setBuilderFactory (new JavaFXBuilderFactory ());\n\n    Parent X1 = (Parent) fxmlLoader.load (location.openStream ());\n\n    Scene scene = new Scene (X1);\n\n    stage.setScene (scene);\n\n    MainController mainController = fxmlLoader.getController ();\n\n    mainController.setStage (stage);\n\n    mainController.showStage ();\n\n}\n"}
{"idx": 12701, "func": "int pow (int a, int X1) {\n\n    int res = 1;\n\n    int i1 = 31 - Integer.numberOfLeadingZeros (X1);\n\n    for (int i = i1;\n\n    i >= 0; -- i) {\n\n        res *= res;\n\n        if ((X1 & (1 << i)) > 0) res *= a;\n\n    }\n\n    return res;\n\n}\n"}
{"idx": 12702, "func": "long pow (long a, int X1) {\n\n    if (X1 == 0) return 1;\n\n    if (X1 == 1) return a;\n\n    if (isEven (X1)) return pow (a * a, X1 / 2);\n\n    else return a * pow (a * a, X1 / 2);\n\n}\n"}
{"idx": 12801, "func": "int pow (int a, int X1) {\n\n    int res = 1;\n\n    int i1 = 31 - Integer.numberOfLeadingZeros (X1);\n\n    for (int i = i1;\n\n    i >= 0; -- i) {\n\n        res *= res;\n\n        if ((X1 & (1 << i)) > 0) res *= a;\n\n    }\n\n    return res;\n\n}\n"}
{"idx": 12802, "func": "private static int pow (int x, int X1) {\n\n    if (X1 == 0) return 1;\n\n    if (X1 == 1) return x;\n\n    if (X1 < 0) {\n\n        if (x == 1 || (x == 2 && X1 == - 1)) return 1;\n\n        else return 0;\n\n    }\n\n    if ((X1 & 1) == 0) {\n\n        long num = pow (x * x, X1 / 2);\n\n        if (num > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n\n        return (int) num;\n\n    } else {\n\n        long num = x * pow (x * x, X1 / 2);\n\n        if (num > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n\n        return (int) num;\n\n    }\n\n}\n"}
{"idx": 12901, "func": "long pow (long X1, int b) {\n\n    if (b == 0) return 1;\n\n    if (b == 1) return X1;\n\n    if (isEven (b)) return pow (X1 * X1, b / 2);\n\n    else return X1 * pow (X1 * X1, b / 2);\n\n}\n"}
{"idx": 12902, "func": "private static int pow (int X1, int n) {\n\n    if (n == 0) return 1;\n\n    if (n == 1) return X1;\n\n    if (n < 0) {\n\n        if (X1 == 1 || (X1 == 2 && n == - 1)) return 1;\n\n        else return 0;\n\n    }\n\n    if ((n & 1) == 0) {\n\n        long num = pow (X1 * X1, n / 2);\n\n        if (num > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n\n        return (int) num;\n\n    } else {\n\n        long num = X1 * pow (X1 * X1, n / 2);\n\n        if (num > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n\n        return (int) num;\n\n    }\n\n}\n"}
{"idx": 13001, "func": "public static void main (String [] args) {\n\n    BigInteger acc = BigInteger.ZERO;\n\n    for (int k = 1;\n\n    k <= 1000; k ++) {\n\n        BigInteger X1 = BigInteger.valueOf (k).X1 (k);\n\n        acc = acc.add (X1);\n\n    }\n\n    System.out.println (acc);\n\n}\n"}
{"idx": 13002, "func": "public static void main (String [] args) {\n\n    long twoTo10 = 1024;\n\n    long X1 = 0;\n\n    for (long i = 1;\n\n    i <= 1000; i ++) {\n\n        X1 += pow (i, i, twoTo10);\n\n        X1 %= twoTo10;\n\n    }\n\n    long fiveTo10 = 9_765_625;\n\n    long sum510 = 0;\n\n    for (long i = 1;\n\n    i <= 1000; i ++) {\n\n        sum510 += pow (i, i, fiveTo10);\n\n        sum510 %= fiveTo10;\n\n    }\n\n    long tenTo10 = 10_000_000_000L;\n\n    long answer = X1 * inverse (fiveTo10, twoTo10) * fiveTo10 + sum510 * inverse (twoTo10, fiveTo10) * twoTo10;\n\n    answer %= tenTo10;\n\n    System.out.println (answer);\n\n}\n"}
{"idx": 1301, "func": "public int countLines (String filename) throws IOException {\n\n    LineNumberReader X1 = new LineNumberReader (new FileReader (filename));\n\n    int cnt = 0;\n\n    String lineRead = \"\";\n\n    while ((lineRead = X1.readLine ()) != null) {\n\n    }\n\n    cnt = X1.getLineNumber ();\n\n    X1.close ();\n\n    return cnt;\n\n}\n"}
{"idx": 1302, "func": "public static int countLines (File input) throws IOException {\n\n    try (InputStream is = new FileInputStream (input)) {\n\n        int X1 = 1;\n\n        for (int aChar = 0;\n\n        aChar != - 1; aChar = is.read ()) X1 += aChar == '\\n' ? 1 : 0;\n\n        return X1;\n\n    }\n\n}\n"}
{"idx": 13101, "func": "public static void main (String [] args) {\n\n    Scanner myScanner;\n\n    myScanner = new Scanner (System.in);\n\n    double X1, tues, wed, thurs, fri, sat, sun;\n\n    do {\n\n        try {\n\n            System.out.print (\"Expenses for Monday: \");\n\n            X1 = myScanner.nextDouble ();\n\n        } catch (Exception e) {\n\n            X1 = - 1;\n\n            myScanner.nextLine ();\n\n        }\n\n    } while (X1 < 0);\n\n    System.out.println (X1);\n\n}\n"}
{"idx": 13102, "func": "public static void main (String args []) {\n\n    Scanner X1 = new Scanner (System.in);\n\n    double mon = getExpensesForDay (X1, \"Monday\");\n\n    double tues = getExpensesForDay (X1, \"Tuesday\");\n\n    double wed = getExpensesForDay (X1, \"Wednesday\");\n\n    double thurs = getExpensesForDay (X1, \"Thursday\");\n\n    double fri = getExpensesForDay (X1, \"Friday\");\n\n    double sat = getExpensesForDay (X1, \"Saturday\");\n\n    double sun = getExpensesForDay (X1, \"Sunday\");\n\n}\n"}
{"idx": 13201, "func": "public static void main (String [] args) {\n\n    System.out.println (\"Enter name\");\n\n    Scanner kb = new Scanner (System.in);\n\n    String X1 = kb.next ();\n\n    if (null == X1 || X1.isEmpty ()) {\n\n        System.out.println (\"Text empty\");\n\n    } else if (X1.charAt (0) == (X1.toUpperCase ().charAt (0))) {\n\n        System.out.println (\"First letter in word \" + X1 + \" is upper case\");\n\n    }\n\n}\n"}
{"idx": 13202, "func": "public static void main (String [] args) {\n\n    String str1 = \"\";\n\n    String str2 = null;\n\n    String X1 = \"Starts with upper case\";\n\n    String str4 = \"starts with lower case\";\n\n    System.out.println (startWithUpperCase (str1));\n\n    System.out.println (startWithUpperCase (str2));\n\n    System.out.println (startWithUpperCase (X1));\n\n    System.out.println (startWithUpperCase (str4));\n\n}\n"}
{"idx": 13301, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame ();\n\n    JPanel panel = new JPanel ();\n\n    JPanel another = new JPanel ();\n\n    JPanel emptyPanel = new JPanel ();\n\n    emptyPanel.setPreferredSize (new Dimension (700, 50));\n\n    frame.setSize (700, 500);\n\n    panel.setMaximumSize (new Dimension (300, 200));\n\n    panel.setMinimumSize (new Dimension (300, 200));\n\n    panel.setPreferredSize (new Dimension (300, 200));\n\n    panel.setBackground (Color.green);\n\n    panel.setCursor (new Cursor (java.awt.Cursor.HAND_CURSOR));\n\n    frame.setDefaultCloseOperation (WindowConstants.EXIT_ON_CLOSE);\n\n    another.X1 (emptyPanel, BorderLayout.NORTH);\n\n    another.X1 (panel, BorderLayout.CENTER);\n\n    frame.X1 (another);\n\n    frame.setVisible (true);\n\n    frame.setLocationRelativeTo (null);\n\n}\n"}
{"idx": 13302, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            JFrame X1 = new FrameDemo ();\n\n            X1.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 13401, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            JFrame X1 = new FrameDemo ();\n\n            X1.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 13402, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame ();\n\n    frame.setDefaultCloseOperation (WindowConstants.EXIT_ON_CLOSE);\n\n    frame.getContentPane ().setLayout (new BorderLayout (0, 0));\n\n    JPanel centerPanel = new JPanel ();\n\n    centerPanel.setPreferredSize (new Dimension (300, 200));\n\n    centerPanel.setBackground (Color.green);\n\n    centerPanel.setCursor (new Cursor (java.awt.Cursor.HAND_CURSOR));\n\n    frame.getContentPane ().add (centerPanel);\n\n    JPanel northPanel = new JPanel ();\n\n    northPanel.setBackground (Color.RED);\n\n    northPanel.setForeground (Color.BLACK);\n\n    northPanel.setPreferredSize (new Dimension (0, 150));\n\n    frame.getContentPane ().add (northPanel, BorderLayout.NORTH);\n\n    JPanel X1 = new JPanel ();\n\n    X1.setBackground (Color.MAGENTA);\n\n    X1.setPreferredSize (new Dimension (200, 0));\n\n    frame.getContentPane ().add (X1, BorderLayout.WEST);\n\n    JPanel southPanel = new JPanel ();\n\n    southPanel.setBackground (Color.YELLOW);\n\n    southPanel.setPreferredSize (new Dimension (0, 150));\n\n    frame.getContentPane ().add (southPanel, BorderLayout.SOUTH);\n\n    JPanel eastPanel = new JPanel ();\n\n    eastPanel.setBackground (Color.BLUE);\n\n    eastPanel.setPreferredSize (new Dimension (200, 0));\n\n    frame.getContentPane ().add (eastPanel, BorderLayout.EAST);\n\n    frame.pack ();\n\n    frame.setVisible (true);\n\n    frame.setLocationRelativeTo (null);\n\n}\n"}
{"idx": 13501, "func": "public static int [] [] getRows (int i, int X1, int [] [] array) {\n\n    int [] [] ret = new int [X1 - i] [];\n\n    for (int k = i;\n\n    k < X1; k ++) {\n\n        ret [k - i] = new int [array [k].length];\n\n        for (int m = 0;\n\n        m < ret [k - i].length; m ++) {\n\n            ret [k - i] [m] = array [k] [m];\n\n        }\n\n    }\n\n    return ret;\n\n}\n"}
{"idx": 13502, "func": "public static int [] [] getRows (int i, int j, int [] [] X1) {\n\n    int [] [] another = new int [j - i + 1] [];\n\n    while (i <= j) {\n\n        for (int k = 0;\n\n        k < another.length; k ++) {\n\n            another [k] = X1 [i];\n\n            i ++;\n\n        }\n\n    }\n\n    return another;\n\n}\n"}
{"idx": 13601, "func": "public void onActivityResult (int X1, int resultCode, Intent data) {\n\n    super.onActivityResult (X1, resultCode, data);\n\n    if (resultCode == RESULT_OK) {\n\n        switch (X1) {\n\n            case SELECT_IMAGE :\n\n                String imagePath = getPath (data.getData ());\n\n                Savingimagepath (imagePath);\n\n                img.setImageDrawable (Drawable.createFromPath (imagePath));\n\n                break;\n\n        }\n\n    }\n\n}\n"}
{"idx": 13602, "func": "@Override\n\nprotected void X1 (int requestCode, int resultCode, Intent data) {\n\n    super.X1 (requestCode, resultCode, data);\n\n    if (requestCode == IMAGE_CAPTURE && resultCode == Activity.RESULT_OK) {\n\n        DBHelper dbHelper = new DBHelper (this);\n\n        SQLiteDatabase sql = dbHelper.getWritableDatabase ();\n\n        sql.execSQL (\"insert statement for inserting path to database\");\n\n        sql.close ();\n\n        dbHelper.close ();\n\n    }\n\n}\n"}
{"idx": 13701, "func": "@Override\n\nprotected void X1 (int requestCode, int resultCode, Intent data) {\n\n    super.X1 (requestCode, resultCode, data);\n\n    if (requestCode == IMAGE_CAPTURE && resultCode == Activity.RESULT_OK) {\n\n        DBHelper dbHelper = new DBHelper (this);\n\n        SQLiteDatabase sql = dbHelper.getWritableDatabase ();\n\n        sql.execSQL (\"insert statement for inserting path to database\");\n\n        sql.close ();\n\n        dbHelper.close ();\n\n    }\n\n}\n"}
{"idx": 13702, "func": "public static void main (final String args []) {\n\n    EventQueue.invokeLater (new Runnable () {\n\n        public void run () {\n\n            try {\n\n                UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n            JFrame f = new JFrame (\"JScrollableToolTip\");\n\n            f.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n            f.setSize (300, 200);\n\n            f.setLocationRelativeTo (null);\n\n            ToolTipManager.sharedInstance ().setInitialDelay (500);\n\n            ToolTipManager.sharedInstance ().setDismissDelay (10000);\n\n            ToolTipManager.sharedInstance ().mousePressed (null);\n\n            X1 table = new X1 (50, 4) {\n\n                private static final long serialVersionUID = 1L;\n\n                @Override\n\n                public JToolTip createToolTip () {\n\n                    JScrollableToolTip tip = new JScrollableToolTip (3, 20);\n\n                    tip.setComponent (this);\n\n                    return tip;\n\n                }}\n\n            ;\n\n            table.setDefaultRenderer (Object.class, new DefaultTableCellRenderer () {\n\n                private static final long serialVersionUID = 1L;\n\n                @Override\n\n                public Component getTableCellRendererComponent (X1 table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n\n                    super.getTableCellRendererComponent (table, value, isSelected, hasFocus, row, column);\n\n                    setToolTipText (\"Row \" + row + \" Column \" + column + \"\\nUsed to display a 'Tip' for a Component. \" + \"Typically components provide api to automate the process of \" + \"using ToolTips. For example, any Swing component can use the \" + \"JComponent  setToolTipText method to specify the text for a standard tooltip.\");\n\n                    return this;\n\n                }}\n\n            );\n\n            f.add (new JScrollPane (table));\n\n            f.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 13801, "func": "public synchronized void add (M msg) {\n\n    Queue < M > X1 = threadQueue.get ();\n\n    if (X1 == null) {\n\n        X1 = new LinkedList < > ();\n\n        queues.add (X1);\n\n        threadQueue.set (X1);\n\n    }\n\n    X1.add (msg);\n\n    notify ();\n\n}\n"}
{"idx": 13802, "func": "public boolean add (P producer, E item) {\n\n    X1.X1 ();\n\n    try {\n\n        if (! queues.containsKey (producer)) {\n\n            queues.put (producer, new PriorityBlockingQueue < > ());\n\n        }\n\n        added.signalAll ();\n\n        return queues.get (producer).add (item);\n\n    } finally {\n\n        X1.unlock ();\n\n    }\n\n}\n"}
{"idx": 13901, "func": "public static void main (String [] args) {\n\n    java.awt.EventQueue.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 evaluator = new X1 ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 13902, "func": "public static void main (String [] args) {\n\n    Runnable r = new Runnable () {\n\n        public void run () {\n\n            final JCheckBox show = new JCheckBox (\"Have Text\", false);\n\n            JPanel ui = new JPanel (new FlowLayout (FlowLayout.CENTER, 5, 5));\n\n            ui.add (show);\n\n            final CardLayout cl = new CardLayout ();\n\n            final JPanel X1 = new JPanel (cl);\n\n            ui.add (X1);\n\n            X1.add (new JPanel (), \"notext\");\n\n            X1.add (new JTextField (8), \"text\");\n\n            ItemListener al = new ItemListener () {\n\n                public void itemStateChanged (ItemEvent ie) {\n\n                    if (show.isSelected ()) {\n\n                        cl.show (X1, \"text\");\n\n                    } else {\n\n                        cl.show (X1, \"notext\");\n\n                    }\n\n                }}\n\n            ;\n\n            show.addItemListener (al);\n\n            JOptionPane.showMessageDialog (null, ui);\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (r);\n\n}\n"}
{"idx": 14001, "func": "public static void main (String [] args) {\n\n    int n = 6;\n\n    int radius = 100;\n\n    Point centre = new Point (200, 200);\n\n    double angle = Math.toRadians (360 / n);\n\n    List < Point > points = new ArrayList < Point > ();\n\n    points.add (centre);\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        double X1 = i * angle;\n\n        int dx = (int) (radius * Math.sin (X1));\n\n        int dy = (int) (- radius * Math.cos (X1));\n\n        Point p = new Point (centre.x + dx, centre.y + dy);\n\n        points.add (p);\n\n    }\n\n    draw (points);\n\n}\n"}
{"idx": 14002, "func": "public static void main (String [] args) {\n\n    int n = 6;\n\n    int radius = 100;\n\n    Point centre = new Point (200, 200);\n\n    double angle = Math.toRadians (360 / n);\n\n    List < Point > points = new ArrayList < Point > ();\n\n    points.add (centre);\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        double X1 = i * angle;\n\n        int dx = (int) (radius * Math.sin (X1));\n\n        int dy = (int) (- radius * Math.cos (X1));\n\n        Point p = new Point (centre.x + dx, centre.y + dy);\n\n        points.add (p);\n\n    }\n\n    draw (points);\n\n}\n"}
{"idx": 1401, "func": "static long countLines (InputStream is) throws IOException {\n\n    try (LineNumberReader lnr = new LineNumberReader (new InputStreamReader (is))) {\n\n        char [] buf = new char [8192];\n\n        int n, previousN = - 1;\n\n        while ((n = lnr.read (buf)) != - 1) {\n\n            previousN = n;\n\n        }\n\n        int ln = lnr.getLineNumber ();\n\n        if (previousN == - 1) {\n\n            return 0;\n\n        } else {\n\n            char X1 = buf [previousN - 1];\n\n            if (X1 == '\\n' || X1 == '\\r') {\n\n                return ln;\n\n            }\n\n        }\n\n        return ln + 1;\n\n    }\n\n}\n"}
{"idx": 1402, "func": "public static int countLines (File input) throws IOException {\n\n    try (InputStream is = new FileInputStream (input)) {\n\n        int count = 1;\n\n        for (int X1 = 0;\n\n        X1 != - 1; X1 = is.read ()) count += X1 == '\\n' ? 1 : 0;\n\n        return count;\n\n    }\n\n}\n"}
{"idx": 14101, "func": "public int sum () {\n\n    sum = 0;\n\n    final IntPredicate positive = v -> v > 0;\n\n    final Index positiveIndex = new Index (positive);\n\n    final Index negativeIndex = new Index (positive.negate ());\n\n    while (positiveIndex.index < X1.length || negativeIndex.index < X1.length) {\n\n        sum += sum < 0 ? sum (positiveIndex, negativeIndex) : sum (negativeIndex, positiveIndex);\n\n    }\n\n    return sum;\n\n}\n"}
{"idx": 14102, "func": "private int sum (@NotNull\n\nIndex mainIndex,@NotNull\n\nIndex secondaryIndex) {\n\n    int localSum = 0;\n\n    while (mainIndex.X1 < array.length && secondaryIndex.sign.test (array [mainIndex.X1])) {\n\n        mainIndex.X1 ++;\n\n    }\n\n    if (mainIndex.X1 < array.length) {\n\n        localSum += array [mainIndex.X1 ++];\n\n    } else {\n\n        for (; secondaryIndex.X1 < array.length; secondaryIndex.X1 ++) {\n\n            if (secondaryIndex.sign.test (array [secondaryIndex.X1])) {\n\n                localSum += array [secondaryIndex.X1];\n\n            }\n\n        }\n\n    }\n\n    return localSum;\n\n}\n"}
{"idx": 14201, "func": "public void actionPerformed (ActionEvent X1) {\n\n    JFrame owner = (JFrame) SwingUtilities.getWindowAncestor ((Component) X1.getSource ());\n\n    final JDialog dialog = new JDialog (owner, \"Dialog\", ModalityType.APPLICATION_MODAL);\n\n    dialog.getContentPane ().add (panel);\n\n    dialog.pack ();\n\n    dialog.setLocation (0, 0);\n\n    int delay = 20;\n\n    new Timer (delay, new ActionListener () {\n\n        int x = 0;\n\n        int y = 0;\n\n        Dimension scrn = Toolkit.getDefaultToolkit ().getScreenSize ();\n\n        @Override\n\n        public void actionPerformed (ActionEvent X1) {\n\n            int maxX = scrn.width - dialog.getWidth ();\n\n            int maxY = scrn.height - dialog.getHeight ();\n\n            if (x < maxX && y < maxY) {\n\n                x ++;\n\n                y ++;\n\n                dialog.setLocation (x, y);\n\n            } else {\n\n                ((Timer) X1.getSource ()).stop ();\n\n            }\n\n        }}\n\n    ).start ();\n\n    dialog.setVisible (true);\n\n}\n"}
{"idx": 14202, "func": "public void actionPerformed (ActionEvent e) {\n\n    int maxX = scrn.width - X1.getWidth ();\n\n    int maxY = scrn.height - X1.getHeight ();\n\n    if (x < maxX && y < maxY) {\n\n        x ++;\n\n        y ++;\n\n        X1.setLocation (x, y);\n\n    } else {\n\n        ((Timer) e.getSource ()).stop ();\n\n    }\n\n}\n"}
{"idx": 14301, "func": "public static void main (String [] args) {\n\n    Map < Example, Number > m = new HashMap < > ();\n\n    Example X1 = new Example (100);\n\n    Example e2 = new Example (200);\n\n    Example e3 = new Example (300);\n\n    m.put (X1, 10);\n\n    m.put (e2, 20);\n\n    m.put (e3, 30);\n\n    System.out.println (m);\n\n}\n"}
{"idx": 14302, "func": "public static void main (String [] args) {\n\n    HashMap < A, String > map = new HashMap < A, String > (4);\n\n    map.put (new A (), \"abc\");\n\n    map.put (new A (), \"def\");\n\n    Class clazz = map.getClass ();\n\n    Field X1 = clazz.getDeclaredField (\"table\");\n\n    X1.setAccessible (true);\n\n    Map.Entry < Integer, String > [] realTable = (Map.Entry < Integer, String > []) X1.get (map);\n\n    for (int i = 0;\n\n    i < realTable.length; i ++) {\n\n        System.out.println (String.format (\"Bucket : %d, Entry: %s\", i, bucketToString (realTable [i])));\n\n    }\n\n}\n"}
{"idx": 14401, "func": "public void authenticate (String apiKeyAndSessionKey, String host, String X1) throws IOException, XMPPException {\n\n    if (apiKeyAndSessionKey == null || X1 == null) {\n\n        throw new IllegalArgumentException (\"Invalid parameters\");\n\n    }\n\n    String [] keyArray = apiKeyAndSessionKey.split (\"\\\\|\", 2);\n\n    if (keyArray.length < 2) {\n\n        throw new IllegalArgumentException (\"API key or session key is not present\");\n\n    }\n\n    this.apiKey = keyArray [0];\n\n    this.X1 = X1;\n\n    this.sessionKey = keyArray [1];\n\n    this.authenticationId = sessionKey;\n\n    this.password = X1;\n\n    this.hostname = host;\n\n    String [] mechanisms = {\"DIGEST-MD5\"};\n\n    Map < String, String > props = new HashMap < String, String > ();\n\n    this.sc = Sasl.createSaslClient (mechanisms, null, \"xmpp\", host, props, this);\n\n    authenticate ();\n\n}\n"}
{"idx": 14402, "func": "public void authenticate (String X1, String host, String password) throws IOException, XMPPException {\n\n    authenticationId = X1;\n\n    this.password = password;\n\n    hostname = host;\n\n    String mechanisms [] = {getName ()};\n\n    java.util.Map props = new HashMap ();\n\n    sc = Sasl.createSaslClient (mechanisms, null, \"xmpp\", host, props, this);\n\n    super.authenticate ();\n\n}\n"}
{"idx": 14501, "func": "private static void merge (int [] a, int [] b, int [] all) {\n\n    int i = 0, j = 0, k = 0;\n\n    while (i < a.X1 && j < b.X1) {\n\n        if (a [i] < b [j]) {\n\n            all [k] = a [i];\n\n            i ++;\n\n        } else {\n\n            all [k] = b [j];\n\n            j ++;\n\n        }\n\n        k ++;\n\n    }\n\n    while (i < a.X1) {\n\n        all [k ++] = a [i ++];\n\n    }\n\n    while (j < b.X1) {\n\n        all [k ++] = b [j ++];\n\n    }\n\n}\n"}
{"idx": 14502, "func": "static void merge (int [] a, int [] l, int [] r) {\n\n    int totElem = l.length + r.length;\n\n    int i, X1, ri;\n\n    i = X1 = ri = 0;\n\n    while (i < totElem) {\n\n        if ((X1 < l.length) && (ri < r.length)) {\n\n            if (l [X1] < r [ri]) {\n\n                a [i] = l [X1];\n\n                i ++;\n\n                X1 ++;\n\n            } else {\n\n                a [i] = r [ri];\n\n                i ++;\n\n                ri ++;\n\n            }\n\n        } else {\n\n            if (X1 >= l.length) {\n\n                while (ri < r.length) {\n\n                    a [i] = r [ri];\n\n                    i ++;\n\n                    ri ++;\n\n                }\n\n            }\n\n            if (ri >= r.length) {\n\n                while (X1 < l.length) {\n\n                    a [i] = l [X1];\n\n                    X1 ++;\n\n                    i ++;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 14601, "func": "void permute (char [] alphabet, int k) {\n\n    int permutationNumber = (int) Math.pow (alphabet.length, k);\n\n    for (int i = 0;\n\n    i < permutationNumber; i ++) {\n\n        for (int X1 = 0;\n\n        X1 < k; X1 ++) {\n\n            System.out.print (alphabet [(i + (X1 * i / alphabet.length)) % alphabet.length]);\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 14602, "func": "static void permute (int X1, String prefix) {\n\n    if (X1 == 0) {\n\n        System.out.println (prefix);\n\n        return;\n\n    }\n\n    for (int i = 0;\n\n    i < s.length (); i ++) permute (X1 - 1, prefix + s.charAt (i));\n\n}\n"}
{"idx": 14701, "func": "public static String replace (String old, String newWord, String X1) {\n\n    int i = X1.indexOf (old);\n\n    if (i < 0) {\n\n        return X1;\n\n    }\n\n    String partBefore = X1.substring (0, i);\n\n    String partAfter = X1.substring (i + old.length ());\n\n    return partBefore + newWord + replace (old, newWord, partAfter);\n\n}\n"}
{"idx": 14702, "func": "public static String replace (String oldStr, String newStr, String X1) {\n\n    StringBuilder sb = new StringBuilder ();\n\n    int i;\n\n    int prev = 0;\n\n    while ((i = X1.indexOf (oldStr, prev)) >= 0) {\n\n        sb.append (X1.substring (prev, i)).append (newStr);\n\n        prev = i + oldStr.length ();\n\n    }\n\n    sb.append (X1.substring (prev));\n\n    return sb.toString ();\n\n}\n"}
{"idx": 14801, "func": "public static void main (String [] args) {\n\n    Scanner X1 = new Scanner (System.in);\n\n    String inString;\n\n    int decimal;\n\n    System.out.println (\"Enter a binary number: \");\n\n    inString = X1.nextLine ();\n\n    while (inString != \"-1\") {\n\n        int i;\n\n        int binaryLength;\n\n        binaryLength = inString.length ();\n\n        for (i = 0, decimal = 0; i < binaryLength; i ++) {\n\n            decimal = decimal * 2 + (Character.getNumericValue (inString.charAt (i)) - 0);\n\n            System.out.print (decimal);\n\n        }\n\n        System.out.println (\"Enter a binary number: \");\n\n        inString = X1.nextLine ();\n\n    }\n\n    System.out.println (\"All set !\");\n\n}\n"}
{"idx": 14802, "func": "public static void main (String [] args) {\n\n    final Scanner input = new Scanner (System.in);\n\n    String X1;\n\n    while (true) {\n\n        System.out.println (\"Enter a binary number: \");\n\n        X1 = input.nextLine ();\n\n        if (X1.equals (\"-1\")) break;\n\n        System.out.println (Integer.parseInt (X1, 2));\n\n    }\n\n    System.out.println (\"All set !\");\n\n}\n"}
{"idx": 14901, "func": "public static void main (String [] args) {\n\n    Random rand = new Random ();\n\n    List < Item > items = new ArrayList < > ();\n\n    int a = 1, b = 1, c = 1, d = 1, e = 1;\n\n    for (int i = 0;\n\n    i < 100; i ++) {\n\n        int randomNumber = rand.nextInt (5) + 1;\n\n        CATEGORY_TYPE categoryType = null;\n\n        int num = 0;\n\n        switch (randomNumber) {\n\n            case 1 :\n\n                categoryType = CATEGORY_TYPE.A;\n\n                num = a ++;\n\n                break;\n\n            case 2 :\n\n                categoryType = CATEGORY_TYPE.B;\n\n                num = b ++;\n\n                break;\n\n            case 3 :\n\n                categoryType = CATEGORY_TYPE.C;\n\n                num = c ++;\n\n                break;\n\n            case 4 :\n\n                categoryType = CATEGORY_TYPE.D;\n\n                num = d ++;\n\n                break;\n\n            case 5 :\n\n                categoryType = CATEGORY_TYPE.E;\n\n                num = e ++;\n\n                break;\n\n        }\n\n        String dummyData = \"Item \" + categoryType.toString () + num;\n\n        Item item = new Item (dummyData, categoryType);\n\n        items.add (item);\n\n    }\n\n    List < Item > categoryAItemsList = new ArrayList < > ();\n\n    List < Item > categoryBItemsList = new ArrayList < > ();\n\n    List < Item > categoryCItemsList = new ArrayList < > ();\n\n    List < Item > categoryDItemsList = new ArrayList < > ();\n\n    List < Item > categoryEItemsList = new ArrayList < > ();\n\n    for (Item item : items) {\n\n        if (item.getCategoryType () == CATEGORY_TYPE.A) categoryAItemsList.add (item);\n\n        else if (item.getCategoryType () == CATEGORY_TYPE.B) categoryBItemsList.add (item);\n\n        else if (item.getCategoryType () == CATEGORY_TYPE.C) categoryCItemsList.add (item);\n\n        else if (item.getCategoryType () == CATEGORY_TYPE.D) categoryDItemsList.add (item);\n\n        else if (item.getCategoryType () == CATEGORY_TYPE.E) categoryEItemsList.add (item);\n\n    }\n\n    List < Item [] > subsetStoringListA = new ArrayList < > ();\n\n    List < Item [] > subsetStoringListB = new ArrayList < > ();\n\n    List < Item [] > subsetStoringListC = new ArrayList < > ();\n\n    List < Item [] > subsetStoringListD = new ArrayList < > ();\n\n    List < Item [] > subsetStoringListE = new ArrayList < > ();\n\n    X1 (categoryAItemsList.toArray (new Item [0]), 2, subsetStoringListA);\n\n    X1 (categoryBItemsList.toArray (new Item [0]), 2, subsetStoringListB);\n\n    X1 (categoryCItemsList.toArray (new Item [0]), 2, subsetStoringListC);\n\n    X1 (categoryDItemsList.toArray (new Item [0]), 2, subsetStoringListD);\n\n    X1 (categoryEItemsList.toArray (new Item [0]), 1, subsetStoringListE);\n\n    System.out.println (\" A groups number: \" + subsetStoringListA.size ());\n\n    System.out.println (\" B groups number: \" + subsetStoringListB.size ());\n\n    System.out.println (\" C groups number: \" + subsetStoringListC.size ());\n\n    System.out.println (\" D groups number: \" + subsetStoringListD.size ());\n\n    System.out.println (\" E groups number: \" + subsetStoringListE.size ());\n\n}\n"}
{"idx": 14902, "func": "public static void main (String [] args) {\n\n    int [] constraints = {2, 1, 0, 1};\n\n    List < boolean [] > items = new ArrayList < boolean [] > ();\n\n    boolean [] i1 = {true, false, true, false};\n\n    boolean [] i2 = {true, false, false, false};\n\n    boolean [] i3 = {false, true, false, true};\n\n    boolean [] i4 = {false, false, false, true};\n\n    items.X1 (i1);\n\n    items.X1 (i2);\n\n    items.X1 (i3);\n\n    items.X1 (i4);\n\n    backtrack (constraints, items);\n\n}\n"}
{"idx": 15001, "func": "public void add (View v) {\n\n    X1 = findViewById (R.id.X1);\n\n    second = findViewById (R.id.second);\n\n    TextView result = findViewById (R.id.result);\n\n    double r;\n\n    if (Validates ()) {\n\n        double s = Double.parseDouble (second.getText ().toString ());\n\n        double f = Double.parseDouble (X1.getText ().toString ());\n\n        r = f + s;\n\n        result.setText (\"\" + r);\n\n    }\n\n}\n"}
{"idx": 15002, "func": "public void add (View v) {\n\n    EditText first = findViewById (R.X1.first);\n\n    EditText second = findViewById (R.X1.second);\n\n    TextView result = findViewById (R.X1.result);\n\n    double r;\n\n    if (TextUtils.isEmpty (first.getText ().toString ())) {\n\n        first.setError (\"This field can't be empty\");\n\n    } else if (TextUtils.isEmpty (second.getText ().toString ())) {\n\n        second.setError (\"This field can't be empty\");\n\n    } else {\n\n        double s = Double.parseDouble (second.getText ().toString ());\n\n        double f = Double.parseDouble (first.getText ().toString ());\n\n        r = f + s;\n\n        result.setText (\"\" + r);\n\n    }\n\n}\n"}
{"idx": 1501, "func": "public int getLastFriday (int month, int year) {\n\n    Calendar X1 = Calendar.getInstance ();\n\n    X1.set (year, month, 1, 0, 0, 0);\n\n    X1.set (Calendar.MILLISECOND, 0);\n\n    int friday = - 1;\n\n    while (X1.get (Calendar.MONTH) == month) {\n\n        if (X1.get (Calendar.DAY_OF_WEEK) == Calendar.FRIDAY) {\n\n            friday = X1.get (Calendar.DAY_OF_MONTH);\n\n            X1.add (Calendar.DAY_OF_MONTH, 7);\n\n        } else {\n\n            X1.add (Calendar.DAY_OF_MONTH, 1);\n\n        }\n\n    }\n\n    return friday;\n\n}\n"}
{"idx": 1502, "func": "public static Calendar getLastFriday (Calendar cal, int offset) {\n\n    int dayofweek;\n\n    cal.set (Calendar.MONTH, cal.get (Calendar.MONTH) + offset);\n\n    cal.set (Calendar.X1, cal.getActualMaximum (Calendar.X1));\n\n    dayofweek = cal.get (Calendar.DAY_OF_WEEK);\n\n    if (dayofweek < Calendar.FRIDAY) cal.set (Calendar.X1, cal.get (Calendar.X1) - 7 + Calendar.FRIDAY - dayofweek);\n\n    else cal.set (Calendar.X1, cal.get (Calendar.X1) + Calendar.FRIDAY - dayofweek);\n\n    return cal;\n\n}\n"}
{"idx": 15101, "func": "public int maxBlock (String str) {\n\n    X1 pattern = X1.compile (\"(.)(\\\\1)*\");\n\n    Matcher matcher = pattern.matcher (str);\n\n    int max = 0;\n\n    while (matcher.find ()) {\n\n        max = Math.max (max, matcher.group ().length ());\n\n    }\n\n    return max;\n\n}\n"}
{"idx": 15102, "func": "public int maxBlock (String str) {\n\n    int max = 0;\n\n    int count = 1;\n\n    char o = ' ';\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        char X1 = str.charAt (i);\n\n        if (X1 == o) {\n\n            count ++;\n\n            if (count > max) {\n\n                max = count;\n\n            }\n\n        } else {\n\n            count = 1;\n\n            if (count > max) {\n\n                max = count;\n\n            }\n\n        }\n\n        o = X1;\n\n    }\n\n    return max;\n\n}\n"}
{"idx": 15201, "func": "public int maxBlock (String X1) {\n\n    Pattern pattern = Pattern.compile (\"(.)(\\\\1)*\");\n\n    Matcher matcher = pattern.matcher (X1);\n\n    int max = 0;\n\n    while (matcher.find ()) {\n\n        max = Math.max (max, matcher.group ().length ());\n\n    }\n\n    return max;\n\n}\n"}
{"idx": 15202, "func": "public static int maxBlock (String str) {\n\n    int maxCounter = 1;\n\n    int X1 = 1;\n\n    if (str.length () == 0) {\n\n        return 0;\n\n    }\n\n    for (int i = 1;\n\n    i < str.length (); i ++) {\n\n        if (str.charAt (i - 1) == str.charAt (i)) {\n\n            X1 ++;\n\n        } else {\n\n            if (X1 > maxCounter) {\n\n                maxCounter = X1;\n\n            }\n\n            X1 = 1;\n\n        }\n\n    }\n\n    return Math.max (maxCounter, X1);\n\n}\n"}
{"idx": 15301, "func": "public void actionPerformed (ActionEvent e) {\n\n    JPanel panel = new JPanel ();\n\n    panel.X1 (new JLabel (\"Hello\"));\n\n    panel.setBorder (new MatteBorder (0, 0, 1, 0, Color.GRAY));\n\n    GridBagConstraints gbc = new GridBagConstraints ();\n\n    gbc.gridwidth = GridBagConstraints.REMAINDER;\n\n    gbc.weightx = 1;\n\n    gbc.fill = GridBagConstraints.HORIZONTAL;\n\n    mainList.X1 (panel, gbc, 0);\n\n    validate ();\n\n    repaint ();\n\n}\n"}
{"idx": 15302, "func": "public void actionPerformed (ActionEvent e) {\n\n    final JPanel newPanel = new JPanel ();\n\n    newPanel.add (new JLabel (\"Label \" + i ++));\n\n    X1.add (newPanel);\n\n    X1.revalidate ();\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            newPanel.scrollRectToVisible (newPanel.getBounds ());\n\n        }}\n\n    );\n\n}\n"}
{"idx": 15401, "func": "public static void throwException (final String key) throws Throwable {\n\n    ExceptionMapping exceptionMapping = exceptionMappings.getExceptionMappings ().get (key);\n\n    if (exceptionMapping != null) {\n\n        try {\n\n            Class < Throwable > exceptionClass = (Class < Throwable >) Class.forName (exceptionMapping.getClassName ());\n\n            try {\n\n                throw exceptionClass.cast (exceptionClass.newInstance ());\n\n            } catch (InstantiationException X1) {\n\n                X1.printStackTrace ();\n\n            } catch (IllegalAccessException X1) {\n\n                X1.printStackTrace ();\n\n            }\n\n        } catch (ClassNotFoundException X1) {\n\n            X1.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 15402, "func": "static void throwException (final String exClassName) throws CheckedException, UncheckedException {\n\n    Class < ? > clazz;\n\n    try {\n\n        clazz = Class.forName (exClassName);\n\n    } catch (ClassNotFoundException cnfe) {\n\n        throw new InternalError (exClassName, cnfe);\n\n    }\n\n    if (CheckedException.class.isAssignableFrom (clazz)) {\n\n        throw newException (clazz.X1 (CheckedException.class));\n\n    } else if (UncheckedException.class.isAssignableFrom (clazz)) {\n\n        throw newException (clazz.X1 (UncheckedException.class));\n\n    } else {\n\n        throw new InternalError (exClassName + \" is not a valid exception\");\n\n    }\n\n}\n"}
{"idx": 15501, "func": "public static void throwException (final String key) throws Throwable {\n\n    ExceptionMapping exceptionMapping = exceptionMappings.getExceptionMappings ().get (key);\n\n    if (exceptionMapping != null) {\n\n        try {\n\n            Class < Throwable > X1 = (Class < Throwable >) Class.forName (exceptionMapping.getClassName ());\n\n            try {\n\n                throw X1.cast (X1.newInstance ());\n\n            } catch (InstantiationException e) {\n\n                e.printStackTrace ();\n\n            } catch (IllegalAccessException e) {\n\n                e.printStackTrace ();\n\n            }\n\n        } catch (ClassNotFoundException e) {\n\n            e.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 15502, "func": "public static void throwException (String className) throws CheckedException, UncheckedException {\n\n    X1 < ? > exceptionClass;\n\n    try {\n\n        exceptionClass = X1.forName (className);\n\n    } catch (ClassNotFoundException e) {\n\n        throw new IllegalArgumentException (e);\n\n    }\n\n    try {\n\n        if (CheckedException.class.isAssignableFrom (exceptionClass)) {\n\n            throw exceptionClass.asSubclass (CheckedException.class).newInstance ();\n\n        } else if (UncheckedException.class.isAssignableFrom (exceptionClass)) {\n\n            throw exceptionClass.asSubclass (UncheckedException.class).newInstance ();\n\n        } else {\n\n            throw new IllegalArgumentException (\"Not a valid exception type: \" + exceptionClass.getName ());\n\n        }\n\n    } catch (InstantiationException | IllegalAccessException e) {\n\n        throw new IllegalStateException (e);\n\n    }\n\n}\n"}
{"idx": 15601, "func": "static void throwException (final String exClassName) throws X1, UncheckedException {\n\n    Class < ? > clazz;\n\n    try {\n\n        clazz = Class.forName (exClassName);\n\n    } catch (ClassNotFoundException cnfe) {\n\n        throw new InternalError (exClassName, cnfe);\n\n    }\n\n    if (X1.class.isAssignableFrom (clazz)) {\n\n        throw newException (clazz.asSubclass (X1.class));\n\n    } else if (UncheckedException.class.isAssignableFrom (clazz)) {\n\n        throw newException (clazz.asSubclass (UncheckedException.class));\n\n    } else {\n\n        throw new InternalError (exClassName + \" is not a valid exception\");\n\n    }\n\n}\n"}
{"idx": 15602, "func": "public static void throwException (String className) throws CheckedException, UncheckedException {\n\n    Class < ? > X1;\n\n    try {\n\n        X1 = Class.forName (className);\n\n    } catch (ClassNotFoundException e) {\n\n        throw new IllegalArgumentException (e);\n\n    }\n\n    try {\n\n        if (CheckedException.class.isAssignableFrom (X1)) {\n\n            throw X1.asSubclass (CheckedException.class).newInstance ();\n\n        } else if (UncheckedException.class.isAssignableFrom (X1)) {\n\n            throw X1.asSubclass (UncheckedException.class).newInstance ();\n\n        } else {\n\n            throw new IllegalArgumentException (\"Not a valid exception type: \" + X1.getName ());\n\n        }\n\n    } catch (InstantiationException | IllegalAccessException e) {\n\n        throw new IllegalStateException (e);\n\n    }\n\n}\n"}
{"idx": 15701, "func": "public static void main (String [] args) {\n\n    JFrame X1 = new JFrame ();\n\n    X1.setLayout (new GridLayout (9, 9));\n\n    X1.getContentPane ().setPreferredSize (new Dimension (300, 300));\n\n    final Random random = new Random ();\n\n    for (int i = 0;\n\n    i < 9; i ++) {\n\n        for (int j = 0;\n\n        j < 9; j ++) {\n\n            final JLabel label = new JLabel (\"\", JLabel.CENTER);\n\n            label.setBorder (BorderFactory.createLineBorder (Color.LIGHT_GRAY));\n\n            label.addMouseListener (new MouseAdapter () {\n\n                public void mousePressed (MouseEvent e) {\n\n                    label.setText (\"\" + random.nextInt (100));\n\n                }}\n\n            );\n\n            X1.add (label);\n\n        }\n\n    }\n\n    X1.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    X1.pack ();\n\n    X1.setLocationRelativeTo (null);\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 15702, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            X1 selected = getImage (true);\n\n            X1 unselected = getImage (false);\n\n            int row = 2;\n\n            int col = 5;\n\n            JPanel p = new JPanel (new GridLayout (row, col));\n\n            for (int ii = 0;\n\n            ii < row * col; ii ++) {\n\n                p.add (getButton (selected, unselected));\n\n            }\n\n            JOptionPane.showMessageDialog (null, p);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 15801, "func": "public void insertNodeAfter (E nVal, E curVal) {\n\n    Node < E > X1 = new Node < E > (nVal);\n\n    Node < E > curr = head;\n\n    while (curr != null) {\n\n        if (curr.getNodeValue ().equals (curVal)) {\n\n            X1.setNext (curr.getNext ());\n\n            curr.setNext (X1);\n\n            break;\n\n        } else {\n\n            curr = curr.getNext ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 15802, "func": "public void insertNodeAfter (E nVal, E curVal) {\n\n    Node < E > X1 = findPrevOf (curVal);\n\n    Node < E > curr = null;\n\n    if (X1 == null) {\n\n        curr = head;\n\n    } else {\n\n        curr = X1.getNext ();\n\n    }\n\n    Node < E > newNode = new Node < E > (nVal);\n\n    insert (curr, (curr == null ? curr : curr.getNext ()), newNode);\n\n}\n"}
{"idx": 15901, "func": "private void addPersonButtonActionPerformed (java.awt.event.ActionEvent evt) {\n\n    String firstName = firstNameTextField.getText ();\n\n    String lastName = lastNameTextField.getText ();\n\n    String emailAddress = emailTextField.getText ();\n\n    if (X1 (firstName, \"First name\") && X1 (lastName, \"Last name\") && isEmailValid (emailAddress, \"Email address\")) {\n\n        personArrayList.add (new Person (firstName, lastName, emailAddress));\n\n        System.out.println (\"Person added!\");\n\n    }\n\n}\n"}
{"idx": 15902, "func": "private void addPersonButtonActionPerformed (java.awt.event.ActionEvent evt) {\n\n    String firstName = firstNameTextField.getText ();\n\n    String lastName = lastNameTextField.getText ();\n\n    String emailAddress = emailTextField.getText ();\n\n    boolean valid = true;\n\n    if (firstName.equals (\"\")) {\n\n        System.out.X1 (\"First Name is missing\");\n\n        valid = false;\n\n    }\n\n    if (lastName.equals (\"\")) {\n\n        System.out.X1 (\"Last Name is missing\");\n\n        valid = false;\n\n    }\n\n    if (emailAddress.equals (\"\")) {\n\n        System.out.X1 (\"E-Mail address is missing\");\n\n        valid = false;\n\n    }\n\n    if (! Email.isValid (emailAddress)) {\n\n        System.out.X1 (\"E-Mail address is invalid\");\n\n        valid = false;\n\n    }\n\n    if (valid) {\n\n        personArrayList.add (new Person (firstName, lastName, emailAddress));\n\n        System.out.X1 (\"Person added!\");\n\n    }\n\n}\n"}
{"idx": 16001, "func": "public boolean checkZero (Class clazz) {\n\n    boolean X1 = true;\n\n    Field [] fields = clazz.getDeclaredFields ();\n\n    boolean X1 = true;\n\n    List < Class > numberClasses = new ArrayList < Class > ();\n\n    numberClasses.add (Number.class);\n\n    numberClasses.add (Integer.class);\n\n    numberClasses.add (Long.class);\n\n    numberClasses.add (Double.class);\n\n    numberClasses.add (Float.class);\n\n    if (fields.length > 0) {\n\n        for (Field field : fields) {\n\n            if (numberClasses.contains (field.getType ())) {\n\n                X1 = false;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 16002, "func": "public static boolean checkZero (Object toCheck) {\n\n    final Class < ? > numerics = new Class < ? > [] {int.class, double.class, float.class, long.class, short.class, byte.class, Integer.class, Double.class, Float.class, Long.class, Short.class, Byte.class};\n\n    try {\n\n        Class < ? > clazz = toCheck.getClass ();\n\n        Field [] fields = clazz.getDeclaredFields ();\n\n        for (Field field : fields) {\n\n            Class < ? > type = field.getType ();\n\n            boolean isNumeric = false;\n\n            for (Class < ? > numeric : numerics) {\n\n                if (type.equals (numeric)) {\n\n                    isNumeric = true;\n\n                    break;\n\n                }\n\n            }\n\n            if (isNumeric) {\n\n                Object value = field.get (toCheck);\n\n                if (value == 0) {\n\n                    return true;\n\n                }\n\n            }\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 1601, "func": "public static void main (String [] args) {\n\n    ObjectMapper mapper = new ObjectMapper ();\n\n    try {\n\n        File json = new File (\"test.json\");\n\n        CollectionType tweetListType = mapper.getTypeFactory ().constructCollectionType (ArrayList.class, Tweet.class);\n\n        List < Tweet > tweets = mapper.readValue (json, tweetListType);\n\n        System.out.X1 (\"Java objects created from JSON String:\");\n\n        tweets.forEach (System.out :: X1);\n\n    } catch (IOException ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 1602, "func": "public static void main (String [] args) throws Exception {\n\n    Tweet [] tweets;\n\n    ObjectMapper X1 = new ObjectMapper ();\n\n    try {\n\n        File json = new File (\"test.json\");\n\n        tweets = X1.readValue (json, Tweet [].class);\n\n        System.out.println (\"Java object created from JSON String :\");\n\n        Arrays.asList (tweets).forEach (System.out :: println);\n\n    } catch (IOException ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 16101, "func": "public static boolean isPermutation (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    int checker = 0;\n\n    for (int X1 = 0;\n\n    X1 < s1.length (); X1 ++) {\n\n        checker ^= s1.charAt (X1) ^ s2.charAt (X1);\n\n    }\n\n    return checker == 0;\n\n}\n"}
{"idx": 16102, "func": "public static boolean isPermutation (String str1, String str2) {\n\n    char [] x = str1.toCharArray ();\n\n    char [] X1 = str2.toCharArray ();\n\n    Arrays.sort (x);\n\n    Arrays.sort (X1);\n\n    if (Arrays.equals (x, X1)) return true;\n\n    return false;\n\n}\n"}
{"idx": 16201, "func": "public static void main (String [] args) throws Exception {\n\n    Robot robot = new Robot ();\n\n    final Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();\n\n    final BufferedImage screen = robot.createScreenCapture (new Rectangle (screenSize));\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            JLabel screenLabel = new JLabel (new ImageIcon (screen));\n\n            JScrollPane screenScroll = new JScrollPane (screenLabel);\n\n            screenScroll.setPreferredSize (new Dimension ((int) (screenSize.getWidth () / 2), (int) (screenSize.getHeight () / 2)));\n\n            final Point pointOfInterest = new Point ();\n\n            X1 panel = new X1 (new BorderLayout ());\n\n            panel.add (screenScroll, BorderLayout.CENTER);\n\n            final JLabel pointLabel = new JLabel (\"Click on any point in the screen shot!\");\n\n            panel.add (pointLabel, BorderLayout.SOUTH);\n\n            screenLabel.addMouseListener (new MouseAdapter () {\n\n                public void mouseClicked (MouseEvent me) {\n\n                    pointOfInterest.setLocation (me.getPoint ());\n\n                    pointLabel.setText (\"Point: \" + pointOfInterest.getX () + \"x\" + pointOfInterest.getY ());\n\n                }}\n\n            );\n\n            JOptionPane.showMessageDialog (null, panel);\n\n            System.out.println (\"Point of interest: \" + pointOfInterest);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 16202, "func": "public static void main (String [] args) {\n\n    String windowName = \"Document - WordPad\";\n\n    int [] X1;\n\n    try {\n\n        X1 = GetWindowRect.getRect (windowName);\n\n        System.out.printf (\"The corner locations for the window \\\"%s\\\" are %s\", windowName, Arrays.toString (X1));\n\n    } catch (GetWindowRect.WindowNotFoundException e) {\n\n        e.printStackTrace ();\n\n    } catch (GetWindowRect.GetWindowRectException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 16301, "func": "boolean unsignedMultiplyOverflows (final long a, final long X1) {\n\n    if ((a == 0L) || (X1 == 0L)) {\n\n        return false;\n\n    }\n\n    if ((a == 1L) || (X1 == 1L)) {\n\n        return false;\n\n    }\n\n    if ((a < 0L) || (X1 < 0L)) {\n\n        return true;\n\n    }\n\n    final boolean unsignedMultiplyOverflows = (a > ((Long.MAX_VALUE / X1) * 2L) + ((((Long.MAX_VALUE % X1) * 2L) + 1L) / X1));\n\n    return unsignedMultiplyOverflows;\n\n}\n"}
{"idx": 16302, "func": "static boolean unsignedMultiplyOverflows (final long a, final long b) {\n\n    if (a == 0 || b == 0) {\n\n        return false;\n\n    }\n\n    final long aHalf = a>>> 1;\n\n    final long bHalf = b>>> 1;\n\n    final byte aLastBit = (byte) (a & 1);\n\n    final byte bLastBit = (byte) (b & 1);\n\n    if (aLastBit == 0) {\n\n        return X1.MAX_VALUE / b < aHalf;\n\n    } else if (bLastBit == 0) {\n\n        return X1.MAX_VALUE / a < bHalf;\n\n    } else {\n\n        return (X1.MAX_VALUE - bHalf) / b < aHalf;\n\n    }\n\n}\n"}
{"idx": 16401, "func": "public static void main (String [] args) throws IOException, UnsupportedAudioFileException, LineUnavailableException {\n\n    File in = new File (\"C:\\\\Users\\\\Sandra\\\\Desktop\\\\music\\\\rags.wav\");\n\n    AudioInputStream X1 = AudioSystem.getAudioInputStream (in);\n\n    Clip play = AudioSystem.getClip ();\n\n    play.open (X1);\n\n    FloatControl volume = (FloatControl) play.getControl (FloatControl.Type.MASTER_GAIN);\n\n    volume.setValue (1.0f);\n\n    play.start ();\n\n    play.drain ();\n\n    play.close ();\n\n}\n"}
{"idx": 16402, "func": "public static void main (String [] args) throws Exception {\n\n    File in = new File (\"C:\\\\Users\\\\Sandra\\\\Desktop\\\\music\\\\rags.wav\");\n\n    AudioInputStream audioInputStream = AudioSystem.getAudioInputStream (in);\n\n    Clip play = AudioSystem.getClip ();\n\n    play.open (audioInputStream);\n\n    FloatControl X1 = (FloatControl) play.getControl (FloatControl.Type.MASTER_GAIN);\n\n    X1.setValue (1.0f);\n\n    play.start ();\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            JOptionPane.showMessageDialog (null, \"Close to exit!\");\n\n        }}\n\n    );\n\n}\n"}
{"idx": 16501, "func": "public static void main (String [] args) throws IOException, UnsupportedAudioFileException, LineUnavailableException {\n\n    File in = new File (\"C:\\\\Users\\\\Sandra\\\\Desktop\\\\music\\\\rags.wav\");\n\n    AudioInputStream audioInputStream = AudioSystem.getAudioInputStream (in);\n\n    Clip X1 = AudioSystem.getClip ();\n\n    X1.open (audioInputStream);\n\n    FloatControl volume = (FloatControl) X1.getControl (FloatControl.Type.MASTER_GAIN);\n\n    volume.setValue (1.0f);\n\n    X1.start ();\n\n    X1.drain ();\n\n    X1.close ();\n\n}\n"}
{"idx": 16502, "func": "public static void main (String [] args) throws InterruptedException {\n\n    Clip play = null;\n\n    try {\n\n        File in = new File (\"C:\\\\Users\\\\Public\\\\Music\\\\Sample Music\\\\Kalimba.wav\");\n\n        AudioInputStream audioInputStream = AudioSystem.getAudioInputStream (in);\n\n        play = AudioSystem.getClip ();\n\n        play.open (audioInputStream);\n\n        FloatControl X1 = (FloatControl) play.getControl (FloatControl.Type.MASTER_GAIN);\n\n        X1.setValue (1.0f);\n\n        play.start ();\n\n        play.drain ();\n\n    } catch (UnsupportedAudioFileException | IOException | LineUnavailableException ex) {\n\n        ex.printStackTrace ();\n\n    } finally {\n\n        try {\n\n            play.close ();\n\n        } catch (Exception exp) {\n\n        }\n\n    }\n\n    System.out.println (\"...\");\n\n}\n"}
{"idx": 16601, "func": "public RemoveDialogOnRuntime () {\n\n    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    setPreferredSize (new Dimension (300, 300));\n\n    setTitle (\"Remove Dialog On Runtime\");\n\n    setLocation (150, 150);\n\n    pack ();\n\n    setVisible (true);\n\n    Point X1 = this.getLocation ();\n\n    top += X1.x;\n\n    left += X1.y;\n\n    AddNewDialog ();\n\n}\n"}
{"idx": 16602, "func": "public RemoveDialogOnRuntime () {\n\n    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    setPreferredSize (new Dimension (300, 300));\n\n    setTitle (\"Remove Dialog On Runtime\");\n\n    setLocation (150, 150);\n\n    pack ();\n\n    setVisible (true);\n\n    Point X1 = this.getLocation ();\n\n    top += X1.x;\n\n    left += X1.y;\n\n    AddNewDialog ();\n\n}\n"}
{"idx": 16701, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.stop ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    } else {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    }\n\n}\n"}
{"idx": 16702, "func": "public void actionPerformed (ActionEvent e) {\n\n    X1.out.println ();\n\n    X1.out.println (\"Display Dialogs\");\n\n    for (Window window : Window.getWindows ()) {\n\n        if (window instanceof JDialog) {\n\n            JDialog dialog = (JDialog) window;\n\n            X1.out.println (\"\\t\" + dialog.getTitle () + \" \" + dialog.isDisplayable ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 16801, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.stop ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    } else {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    }\n\n}\n"}
{"idx": 16802, "func": "public void actionPerformed (ActionEvent e) {\n\n    System.out.println ();\n\n    System.out.println (\"Create Dialog\");\n\n    JDialog dialog = new JDialog ();\n\n    dialog.getContentPane ().setLayout (null);\n\n    for (int i = 0;\n\n    i < 200; i ++) {\n\n        dialog.add (new JTextField (\"some text\"));\n\n    }\n\n    dialog.setTitle (\"Dialog \" + X1 ++);\n\n    dialog.setLocation (X1 * 25, X1 * 25);\n\n    dialog.setVisible (true);\n\n    System.out.println (\"\\tCreated \" + dialog.getTitle ());\n\n}\n"}
{"idx": 16901, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.stop ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    } else {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    }\n\n}\n"}
{"idx": 16902, "func": "public void actionPerformed (ActionEvent e) {\n\n    X1.out.println ();\n\n    X1.out.println (\"Close Dialogs\");\n\n    for (Window window : Window.getWindows ()) {\n\n        if (window instanceof JDialog) {\n\n            JDialog dialog = (JDialog) window;\n\n            X1.out.println (\"\\tClosing \" + dialog.getTitle ());\n\n            dialog.dispose ();\n\n        }\n\n    }\n\n    Runtime.getRuntime ().gc ();\n\n}\n"}
{"idx": 17001, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.stop ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    } else {\n\n        X1 doRun = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                remWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    }\n\n}\n"}
{"idx": 17002, "func": "public void actionPerformed (ActionEvent e) {\n\n    if (runProcess) {\n\n        for (Window win : Window.getWindows ()) {\n\n            if (win instanceof JDialog) {\n\n                X1.out.println (\"    Trying to Remove JDialog\");\n\n                win.dispose ();\n\n            }\n\n        }\n\n        X1.out.println (\"    Remove Cycle Done :-)\");\n\n        runProcess = false;\n\n        new Thread () {\n\n            @Override\n\n            public void run () {\n\n                try {\n\n                    Thread.sleep (100);\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n                Runtime.getRuntime ().gc ();\n\n            }}\n\n        .start ();\n\n    } else {\n\n        pastRemWins ();\n\n        runProcess = true;\n\n    }\n\n}\n"}
{"idx": 1701, "func": "public String longestSequenceOfChar (String str) {\n\n    String result = \"\";\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int X1 = i;\n\n        while (X1 < str.length () && str.charAt (X1) == str.charAt (i)) {\n\n            X1 ++;\n\n        }\n\n        if (X1 - i > result.length ()) {\n\n            result = str.substring (i, X1);\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 1702, "func": "public String longestSequenceOfChar (String str) {\n\n    String interimresult = \"\";\n\n    String result = \"\";\n\n    for (int i = 0;\n\n    i < str.X1 (); i ++) {\n\n        char ch = str.charAt (i);\n\n        interimresult += ch;\n\n        for (int j = i + 1;\n\n        j < str.X1 (); j ++) {\n\n            char ch1 = str.charAt (j);\n\n            if (ch != ch1) {\n\n                break;\n\n            }\n\n            interimresult += ch;\n\n        }\n\n        if (interimresult.X1 () > result.X1 ()) result = interimresult;\n\n        interimresult = \"\";\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 17101, "func": "private void remWins () {\n\n    Runtime runtime = Runtime.getRuntime ();\n\n    long total = runtime.totalMemory ();\n\n    long free = runtime.freeMemory ();\n\n    long max = runtime.maxMemory ();\n\n    long used = total - free;\n\n    System.out.println (Math.round (used / 1e3) + \" KB used before GC\");\n\n    Window [] wins = Window.getWindows ();\n\n    for (int X1 = 0;\n\n    X1 < wins.length; X1 ++) {\n\n        if (wins [X1] instanceof JDialog) {\n\n            System.out.println (\"    Trying to Remove JDialog\");\n\n            wins [X1].setVisible (false);\n\n            wins [X1].dispose ();\n\n            WindowEvent windowClosing = new WindowEvent (wins [X1], WindowEvent.WINDOW_CLOSING);\n\n            wins [X1].dispatchEvent (windowClosing);\n\n            Toolkit.getDefaultToolkit ().getSystemEventQueue ().postEvent (windowClosing);\n\n            runtime = Runtime.getRuntime ();\n\n            runtime.gc ();\n\n            runtime.runFinalization ();\n\n        }\n\n    }\n\n    wins = null;\n\n    System.out.println (\"    Remove Cycle Done :-)\");\n\n    runtime.runFinalization ();\n\n    runtime.gc ();\n\n    runtime = Runtime.getRuntime ();\n\n    total = runtime.totalMemory ();\n\n    free = runtime.freeMemory ();\n\n    max = runtime.maxMemory ();\n\n    used = total - free;\n\n    System.out.println (Math.round (used / 1e3) + \" KB used after GC\");\n\n    startOO ();\n\n}\n"}
{"idx": 17102, "func": "private void remWins () {\n\n    runProcess = true;\n\n    timer = new Timer (1000, new ActionListener () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent X1) {\n\n            if (runProcess) {\n\n                for (Window win : Window.getWindows ()) {\n\n                    if (win instanceof JDialog) {\n\n                        System.out.println (\"    Trying to Remove JDialog\");\n\n                        win.dispose ();\n\n                    }\n\n                }\n\n                System.out.println (\"    Remove Cycle Done :-)\");\n\n                runProcess = false;\n\n                new Thread () {\n\n                    @Override\n\n                    public void run () {\n\n                        try {\n\n                            Thread.sleep (100);\n\n                        } catch (InterruptedException X1) {\n\n                            X1.printStackTrace ();\n\n                        }\n\n                        Runtime.getRuntime ().gc ();\n\n                    }}\n\n                .start ();\n\n            } else {\n\n                pastRemWins ();\n\n                runProcess = true;\n\n            }\n\n        }}\n\n    );\n\n    timer.setRepeats (true);\n\n    timer.start ();\n\n}\n"}
{"idx": 17201, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.stop ();\n\n    timer.stop ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        Runnable X1 = new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (X1);\n\n    } else {\n\n        Runnable X1 = new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (X1);\n\n    }\n\n}\n"}
{"idx": 17202, "func": "public void actionPerformed (ActionEvent e) {\n\n    System.out.println ();\n\n    System.out.println (\"Display Dialogs\");\n\n    for (Window window : Window.getWindows ()) {\n\n        if (window instanceof X1) {\n\n            X1 dialog = (X1) window;\n\n            System.out.println (\"\\t\" + dialog.getTitle () + \" \" + dialog.isDisplayable ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 17301, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.stop ();\n\n    timer.stop ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        Runnable doRun = new Runnable () {\n\n            @X1\n\n            public void run () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    } else {\n\n        Runnable doRun = new Runnable () {\n\n            @X1\n\n            public void run () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    }\n\n}\n"}
{"idx": 17302, "func": "public void actionPerformed (ActionEvent e) {\n\n    X1.out.println ();\n\n    X1.out.println (\"Create Dialog\");\n\n    JDialog dialog = new JDialog ();\n\n    dialog.getContentPane ().setLayout (null);\n\n    for (int i = 0;\n\n    i < 200; i ++) {\n\n        dialog.add (new JTextField (\"some text\"));\n\n    }\n\n    dialog.setTitle (\"Dialog \" + count ++);\n\n    dialog.setLocation (count * 25, count * 25);\n\n    dialog.setVisible (true);\n\n    X1.out.println (\"\\tCreated \" + dialog.getTitle ());\n\n}\n"}
{"idx": 17401, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.stop ();\n\n    timer.stop ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        Runnable doRun = new Runnable () {\n\n            @Override\n\n            public void X1 () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    } else {\n\n        Runnable doRun = new Runnable () {\n\n            @Override\n\n            public void X1 () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    }\n\n}\n"}
{"idx": 17402, "func": "public void actionPerformed (ActionEvent e) {\n\n    System.X1.println ();\n\n    System.X1.println (\"Close Dialogs\");\n\n    for (Window window : Window.getWindows ()) {\n\n        if (window instanceof JDialog) {\n\n            JDialog dialog = (JDialog) window;\n\n            System.X1.println (\"\\tClosing \" + dialog.getTitle ());\n\n            dialog.dispose ();\n\n        }\n\n    }\n\n    Runtime.getRuntime ().gc ();\n\n}\n"}
{"idx": 17501, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.X1 ();\n\n    timer.X1 ();\n\n    if (SwingUtilities.isEventDispatchThread ()) {\n\n        Runnable doRun = new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    } else {\n\n        Runnable doRun = new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                pastRemWins ();\n\n            }}\n\n        ;\n\n        SwingUtilities.invokeLater (doRun);\n\n    }\n\n}\n"}
{"idx": 17502, "func": "public void actionPerformed (ActionEvent e) {\n\n    if (runProcess) {\n\n        for (X1 win : X1.getWindows ()) {\n\n            if (win instanceof JDialog) {\n\n                System.out.println (\"    Trying to Remove JDialog\");\n\n                win.dispose ();\n\n            }\n\n        }\n\n        System.out.println (\"    Remove Cycle Done :-)\");\n\n        runProcess = false;\n\n        new Thread () {\n\n            @Override\n\n            public void run () {\n\n                try {\n\n                    Thread.sleep (100);\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n                Runtime.getRuntime ().gc ();\n\n            }}\n\n        .start ();\n\n    } else {\n\n        pastRemWins ();\n\n        runProcess = true;\n\n    }\n\n}\n"}
{"idx": 17601, "func": "public void actionPerformed (ActionEvent e) {\n\n    System.out.println ();\n\n    System.out.println (\"Display Dialogs\");\n\n    for (X1 window : X1.getWindows ()) {\n\n        if (window instanceof JDialog) {\n\n            JDialog dialog = (JDialog) window;\n\n            System.out.println (\"\\t\" + dialog.getTitle () + \" \" + dialog.isDisplayable ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 17602, "func": "public void actionPerformed (ActionEvent e) {\n\n    System.out.println ();\n\n    System.out.println (\"Create Dialog\");\n\n    JDialog X1 = new JDialog ();\n\n    X1.getContentPane ().setLayout (null);\n\n    for (int i = 0;\n\n    i < 200; i ++) {\n\n        X1.add (new JTextField (\"some text\"));\n\n    }\n\n    X1.setTitle (\"Dialog \" + count ++);\n\n    X1.setLocation (count * 25, count * 25);\n\n    X1.setVisible (true);\n\n    System.out.println (\"\\tCreated \" + X1.getTitle ());\n\n}\n"}
{"idx": 17701, "func": "public void actionPerformed (ActionEvent e) {\n\n    System.out.X1 ();\n\n    System.out.X1 (\"Display Dialogs\");\n\n    for (Window window : Window.getWindows ()) {\n\n        if (window instanceof JDialog) {\n\n            JDialog dialog = (JDialog) window;\n\n            System.out.X1 (\"\\t\" + dialog.getTitle () + \" \" + dialog.isDisplayable ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 17702, "func": "public void actionPerformed (ActionEvent e) {\n\n    if (runProcess) {\n\n        for (Window win : Window.getWindows ()) {\n\n            if (win instanceof JDialog) {\n\n                System.X1.println (\"    Trying to Remove JDialog\");\n\n                win.dispose ();\n\n            }\n\n        }\n\n        System.X1.println (\"    Remove Cycle Done :-)\");\n\n        runProcess = false;\n\n        new Thread () {\n\n            @Override\n\n            public void run () {\n\n                try {\n\n                    Thread.sleep (100);\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n                Runtime.getRuntime ().gc ();\n\n            }}\n\n        .start ();\n\n    } else {\n\n        pastRemWins ();\n\n        runProcess = true;\n\n    }\n\n}\n"}
{"idx": 17801, "func": "public void actionPerformed (ActionEvent e) {\n\n    X1.out.println ();\n\n    X1.out.println (\"Create Dialog\");\n\n    JDialog dialog = new JDialog ();\n\n    dialog.getContentPane ().setLayout (null);\n\n    for (int i = 0;\n\n    i < 200; i ++) {\n\n        dialog.add (new JTextField (\"some text\"));\n\n    }\n\n    dialog.setTitle (\"Dialog \" + count ++);\n\n    dialog.setLocation (count * 25, count * 25);\n\n    dialog.setVisible (true);\n\n    X1.out.println (\"\\tCreated \" + dialog.getTitle ());\n\n}\n"}
{"idx": 17802, "func": "public void actionPerformed (ActionEvent X1) {\n\n    if (runProcess) {\n\n        for (Window win : Window.getWindows ()) {\n\n            if (win instanceof JDialog) {\n\n                System.out.println (\"    Trying to Remove JDialog\");\n\n                win.dispose ();\n\n            }\n\n        }\n\n        System.out.println (\"    Remove Cycle Done :-)\");\n\n        runProcess = false;\n\n        new Thread () {\n\n            @Override\n\n            public void run () {\n\n                try {\n\n                    Thread.sleep (100);\n\n                } catch (InterruptedException X1) {\n\n                    X1.printStackTrace ();\n\n                }\n\n                Runtime.getRuntime ().gc ();\n\n            }}\n\n        .start ();\n\n    } else {\n\n        pastRemWins ();\n\n        runProcess = true;\n\n    }\n\n}\n"}
{"idx": 17901, "func": "public void actionPerformed (ActionEvent e) {\n\n    System.out.println ();\n\n    System.out.println (\"Close Dialogs\");\n\n    for (Window window : Window.getWindows ()) {\n\n        if (window instanceof X1) {\n\n            X1 dialog = (X1) window;\n\n            System.out.println (\"\\tClosing \" + dialog.getTitle ());\n\n            dialog.dispose ();\n\n        }\n\n    }\n\n    Runtime.getRuntime ().gc ();\n\n}\n"}
{"idx": 17902, "func": "public void actionPerformed (ActionEvent X1) {\n\n    if (runProcess) {\n\n        for (Window win : Window.getWindows ()) {\n\n            if (win instanceof JDialog) {\n\n                System.out.println (\"    Trying to Remove JDialog\");\n\n                win.dispose ();\n\n            }\n\n        }\n\n        System.out.println (\"    Remove Cycle Done :-)\");\n\n        runProcess = false;\n\n        new Thread () {\n\n            @Override\n\n            public void run () {\n\n                try {\n\n                    Thread.sleep (100);\n\n                } catch (InterruptedException X1) {\n\n                    X1.printStackTrace ();\n\n                }\n\n                Runtime.getRuntime ().gc ();\n\n            }}\n\n        .start ();\n\n    } else {\n\n        pastRemWins ();\n\n        runProcess = true;\n\n    }\n\n}\n"}
{"idx": 18001, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    System.out.X1 (\"How many numbers do you want to enter?\");\n\n    int num = input.nextInt ();\n\n    int array [] = new int [num];\n\n    System.out.X1 (\"Enter the \" + num + \" numbers now.\");\n\n    for (int i = 0;\n\n    i < array.length; i ++) {\n\n        array [i] = input.nextInt ();\n\n    }\n\n    System.out.X1 (\"These are the numbers you have entered.\");\n\n    printArray (array);\n\n    input.close ();\n\n}\n"}
{"idx": 18002, "func": "public static void main (String [] args) {\n\n    List < String > list = new ArrayList < String > ();\n\n    Scanner stdin = new Scanner (System.in);\n\n    do {\n\n        System.out.println (\"Current list is \" + list);\n\n        System.out.println (\"Add more? (y/n)\");\n\n        if (stdin.next ().startsWith (\"y\")) {\n\n            System.out.println (\"Enter : \");\n\n            list.add (stdin.next ());\n\n        } else {\n\n            break;\n\n        }\n\n    } while (true);\n\n    stdin.close ();\n\n    System.out.println (\"List is \" + list);\n\n    String [] X1 = list.toArray (new String [0]);\n\n    System.out.println (\"Array is \" + Arrays.toString (X1));\n\n}\n"}
{"idx": 1801, "func": "public void serialize (Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n\n    jgen.writeStartObject ();\n\n    JavaType X1 = provider.constructType (CustomClass.class);\n\n    BeanDescription beanDesc = provider.getConfig ().introspect (X1);\n\n    JsonSerializer < Object > serializer = BeanSerializerFactory.instance.findBeanSerializer (provider, X1, beanDesc);\n\n    serializer.unwrappingSerializer (null).serialize (value, jgen, provider);\n\n    jgen.writeObjectField (\"my_extra_field\", \"some data\");\n\n    jgen.writeEndObject ();\n\n}\n"}
{"idx": 1802, "func": "@Override\n\npublic void serialize (Test value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {\n\n    jgen.writeStartObject ();\n\n    Field [] fields = value.getClass ().getDeclaredFields ();\n\n    for (Field X1 : fields) {\n\n        try {\n\n            jgen.writeObjectField (X1.getName (), X1.get (value));\n\n        } catch (IllegalArgumentException | IllegalAccessException e) {\n\n            e.printStackTrace ();\n\n        }\n\n    }\n\n    jgen.writeObjectField (\"extra_field\", \"whatever_value\");\n\n    jgen.writeEndObject ();\n\n}\n"}
{"idx": 18101, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    System.out.println (\"how many number you want to put in the pot?\");\n\n    int num = input.nextInt ();\n\n    int numbers [] = new int [num];\n\n    for (int X1 = 0;\n\n    X1 < num; X1 ++) {\n\n        System.out.println (\"number\" + X1 + \":\");\n\n        numbers [X1] = input.nextInt ();\n\n    }\n\n    for (int temp : numbers) {\n\n        System.out.print (temp + \"\\t\");\n\n    }\n\n    input.close ();\n\n}\n"}
{"idx": 18102, "func": "public static void main (String [] args) {\n\n    List < String > list = new ArrayList < String > ();\n\n    Scanner stdin = new Scanner (System.in);\n\n    do {\n\n        System.out.X1 (\"Current list is \" + list);\n\n        System.out.X1 (\"Add more? (y/n)\");\n\n        if (stdin.next ().startsWith (\"y\")) {\n\n            System.out.X1 (\"Enter : \");\n\n            list.add (stdin.next ());\n\n        } else {\n\n            break;\n\n        }\n\n    } while (true);\n\n    stdin.close ();\n\n    System.out.X1 (\"List is \" + list);\n\n    String [] arr = list.toArray (new String [0]);\n\n    System.out.X1 (\"Array is \" + Arrays.toString (arr));\n\n}\n"}
{"idx": 18201, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    System.X1.println (\"how many number you want to put in the pot?\");\n\n    int num = input.nextInt ();\n\n    int numbers [] = new int [num];\n\n    for (int i = 0;\n\n    i < num; i ++) {\n\n        System.X1.println (\"number\" + i + \":\");\n\n        numbers [i] = input.nextInt ();\n\n    }\n\n    for (int temp : numbers) {\n\n        System.X1.print (temp + \"\\t\");\n\n    }\n\n    input.close ();\n\n}\n"}
{"idx": 18202, "func": "public static void main (String [] args) {\n\n    int arr [];\n\n    X1 scan = new X1 (System.in);\n\n    for (int i = 0;\n\n    i < 5; i ++) {\n\n        System.out.print (\"Enter number \" + (i + 1) + \": \");\n\n        arr [i] = scan.nextInt ();\n\n    }\n\n    for (int i = 0;\n\n    i < 5; i ++) System.out.println (\"Number \" + (i + 1) + \": \" + arr [i]);\n\n}\n"}
{"idx": 18301, "func": "public static void main (String [] args) {\n\n    List < String > list = new ArrayList < String > ();\n\n    Scanner stdin = new Scanner (System.in);\n\n    do {\n\n        System.out.println (\"Current list is \" + list);\n\n        System.out.println (\"Add more? (y/n)\");\n\n        if (stdin.X1 ().startsWith (\"y\")) {\n\n            System.out.println (\"Enter : \");\n\n            list.add (stdin.X1 ());\n\n        } else {\n\n            break;\n\n        }\n\n    } while (true);\n\n    stdin.close ();\n\n    System.out.println (\"List is \" + list);\n\n    String [] arr = list.toArray (new String [0]);\n\n    System.out.println (\"Array is \" + Arrays.toString (arr));\n\n}\n"}
{"idx": 18302, "func": "public static void main (String [] args) {\n\n    int arr [];\n\n    Scanner scan = new Scanner (System.in);\n\n    for (int X1 = 0;\n\n    X1 < 5; X1 ++) {\n\n        System.out.print (\"Enter number \" + (X1 + 1) + \": \");\n\n        arr [X1] = scan.nextInt ();\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < 5; X1 ++) System.out.println (\"Number \" + (X1 + 1) + \": \" + arr [X1]);\n\n}\n"}
{"idx": 18401, "func": "public void run () {\n\n    System.out.println (\"Outer launched\");\n\n    System.out.println (\"Obtaining lock\");\n\n    synchronized (lock) {\n\n        Thread X1 = new Thread (new InnerTask (lock), \"inner\");\n\n        X1.start ();\n\n        try {\n\n            X1.join ();\n\n        } catch (InterruptedException e) {\n\n            e.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 18402, "func": "public void run () {\n\n    String X1 = Thread.currentThread ().getName ();\n\n    try {\n\n        first.lock ();\n\n        latch.countDown ();\n\n        System.out.println (X1 + \": locked first lock\");\n\n        latch.await ();\n\n        System.out.println (X1 + \": attempting to lock second lock\");\n\n        second.lock ();\n\n        System.out.println (X1 + \": never reached\");\n\n    } catch (InterruptedException e) {\n\n        throw new RuntimeException (e);\n\n    }\n\n}\n"}
{"idx": 18501, "func": "public void run () {\n\n    try {\n\n        Thread X1 = new Thread (new Lock ());\n\n        X1.start ();\n\n        X1.join ();\n\n    } catch (InterruptedException ex) {\n\n        System.out.println (\"won't see me\");\n\n    }\n\n}\n"}
{"idx": 18502, "func": "public void run () {\n\n    System.X1.println (\"Thread \" + Thread.currentThread ().getId () + \" starting\");\n\n    synchronized (BadRunnable.class) {\n\n        System.X1.println (\"Thread \" + Thread.currentThread ().getId () + \" acquired the monitor on BadRunnable.class\");\n\n        latch.countDown ();\n\n        while (true) {\n\n            try {\n\n                latch.await ();\n\n            } catch (InterruptedException ex) {\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    System.X1.println (\"Thread \" + Thread.currentThread ().getId () + \" released the monitor on BadRunnable.class\");\n\n    System.X1.println (\"Thread \" + Thread.currentThread ().getId () + \" ending\");\n\n}\n"}
{"idx": 18601, "func": "public void run () {\n\n    synchronized (obj1) {\n\n        X1.countDown ();\n\n        try {\n\n            X1.await ();\n\n        } catch (InterruptedException e) {\n\n            throw new RuntimeException ();\n\n        }\n\n        synchronized (obj2) {\n\n            System.out.println (\"Thread finished\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 18602, "func": "public void run () {\n\n    System.out.println (\"Thread \" + X1.currentThread ().getId () + \" starting\");\n\n    synchronized (BadRunnable.class) {\n\n        System.out.println (\"Thread \" + X1.currentThread ().getId () + \" acquired the monitor on BadRunnable.class\");\n\n        latch.countDown ();\n\n        while (true) {\n\n            try {\n\n                latch.await ();\n\n            } catch (InterruptedException ex) {\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    System.out.println (\"Thread \" + X1.currentThread ().getId () + \" released the monitor on BadRunnable.class\");\n\n    System.out.println (\"Thread \" + X1.currentThread ().getId () + \" ending\");\n\n}\n"}
{"idx": 18701, "func": "public void run () {\n\n    synchronized (obj1) {\n\n        X1.countDown ();\n\n        try {\n\n            X1.await ();\n\n        } catch (InterruptedException e) {\n\n            throw new RuntimeException ();\n\n        }\n\n        synchronized (obj2) {\n\n            System.out.println (\"Thread finished\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 18702, "func": "public void run () {\n\n    String threadName = Thread.currentThread ().getName ();\n\n    try {\n\n        first.lock ();\n\n        latch.countDown ();\n\n        System.out.println (threadName + \": locked first lock\");\n\n        latch.await ();\n\n        System.out.println (threadName + \": attempting to lock second lock\");\n\n        second.lock ();\n\n        System.out.println (threadName + \": never reached\");\n\n    } catch (InterruptedException X1) {\n\n        throw new RuntimeException (X1);\n\n    }\n\n}\n"}
{"idx": 18801, "func": "public void run () {\n\n    System.out.X1 (\"Thread \" + Thread.currentThread ().getId () + \" starting\");\n\n    synchronized (BadRunnable.class) {\n\n        System.out.X1 (\"Thread \" + Thread.currentThread ().getId () + \" acquired the monitor on BadRunnable.class\");\n\n        latch.countDown ();\n\n        while (true) {\n\n            try {\n\n                latch.await ();\n\n            } catch (InterruptedException ex) {\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    System.out.X1 (\"Thread \" + Thread.currentThread ().getId () + \" released the monitor on BadRunnable.class\");\n\n    System.out.X1 (\"Thread \" + Thread.currentThread ().getId () + \" ending\");\n\n}\n"}
{"idx": 18802, "func": "public void run () {\n\n    String X1 = Thread.currentThread ().getName ();\n\n    try {\n\n        first.lock ();\n\n        latch.countDown ();\n\n        System.out.println (X1 + \": locked first lock\");\n\n        latch.await ();\n\n        System.out.println (X1 + \": attempting to lock second lock\");\n\n        second.lock ();\n\n        System.out.println (X1 + \": never reached\");\n\n    } catch (InterruptedException e) {\n\n        throw new RuntimeException (e);\n\n    }\n\n}\n"}
{"idx": 18901, "func": "public static void main (String [] args) {\n\n    X1 [] threads = new X1 [2];\n\n    CountDownLatch latch = new CountDownLatch (threads.length);\n\n    for (int i = 0;\n\n    i < threads.length; ++ i) {\n\n        threads [i] = new X1 (new BadRunnable (latch));\n\n        threads [i].start ();\n\n    }\n\n}\n"}
{"idx": 18902, "func": "public static void main (String [] args) {\n\n    final Friend alphonse = new Friend (\"Alphonse\");\n\n    final Friend gaston = new Friend (\"Gaston\");\n\n    new Thread (new Runnable () {\n\n        public void run () {\n\n            alphonse.X1 (gaston);\n\n        }}\n\n    ).start ();\n\n    new Thread (new Runnable () {\n\n        public void run () {\n\n            gaston.X1 (alphonse);\n\n        }}\n\n    ).start ();\n\n}\n"}
{"idx": 19001, "func": "public static void printSquare (int min, int max) {\n\n    int X1 = max - min + 1;\n\n    for (int i = min;\n\n    i <= max; i ++) {\n\n        int counter = i;\n\n        for (int j = 0;\n\n        j < X1; j ++) {\n\n            System.out.print (counter);\n\n            counter = counter >= max ? min : counter + 1;\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 19002, "func": "public void printSquare (int min, int max) {\n\n    for (int X1 = min;\n\n    X1 <= max; X1 ++) {\n\n        for (int j = X1;\n\n        j <= max; j ++) {\n\n            System.out.print (j);\n\n        }\n\n        for (int k = min;\n\n        k < X1; k ++) {\n\n            System.out.print (k);\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 1901, "func": "public void serialize (Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n\n    jgen.writeStartObject ();\n\n    JavaType X1 = provider.constructType (CustomClass.class);\n\n    BeanDescription beanDesc = provider.getConfig ().introspect (X1);\n\n    JsonSerializer < Object > serializer = BeanSerializerFactory.instance.findBeanSerializer (provider, X1, beanDesc);\n\n    serializer.unwrappingSerializer (null).serialize (value, jgen, provider);\n\n    jgen.writeObjectField (\"my_extra_field\", \"some data\");\n\n    jgen.writeEndObject ();\n\n}\n"}
{"idx": 1902, "func": "public void serialize (final Object X1, final JsonGenerator jgen, final SerializerProvider provider) throws IOException, JsonGenerationException {\n\n    jgen.writeStartObject ();\n\n    if (_propertyFilterId != null) {\n\n        serializeFieldsFiltered (X1, jgen, provider);\n\n    } else {\n\n        serializeFields (X1, jgen, provider);\n\n    }\n\n    serializerListener.postSerialization (X1, jgen);\n\n    jgen.writeEndObject ();\n\n}\n"}
{"idx": 19101, "func": "public boolean handleMessage (SOAPMessageContext X1) {\n\n    Boolean isRequest = (Boolean) X1.get (MessageContext.MESSAGE_OUTBOUND_PROPERTY);\n\n    if (isRequest) {\n\n        System.out.println (\"is Request\");\n\n    } else {\n\n        System.out.println (\"is Response\");\n\n    }\n\n    SOAPMessage message = X1.getMessage ();\n\n    try {\n\n        SOAPEnvelope envelope = message.getSOAPPart ().getEnvelope ();\n\n        SOAPHeader header = envelope.getHeader ();\n\n        message.writeTo (System.out);\n\n    } catch (SOAPException | IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 19102, "func": "public boolean handleMessage (SOAPMessageContext X1) {\n\n    SOAPMessage msg = X1.getMessage ();\n\n    try {\n\n        msg.writeTo (System.out);\n\n    } catch (Exception ex) {\n\n        Logger.getLogger (LogMessageHandler.class.getName ()).log (Level.SEVERE, null, ex);\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 19201, "func": "public void actionPerformed (ActionEvent e) {\n\n    float X1 = softButton1.getAlpha () + incrementer;\n\n    if (X1 < 0) {\n\n        X1 = 0;\n\n        incrementer = - incrementer;\n\n    } else if (X1 > 1f) {\n\n        X1 = 1f;\n\n        incrementer = - incrementer;\n\n    }\n\n    softButton1.setAlpha (X1);\n\n    softButton2.setAlpha (X1);\n\n}\n"}
{"idx": 19202, "func": "public void actionPerformed (ActionEvent e) {\n\n    try {\n\n        UIManager.setLookAndFeel (laf [X1].getClassName ());\n\n        SwingUtilities.updateComponentTreeUI (frame);\n\n    } catch (Exception exc) {\n\n        exc.printStackTrace ();\n\n    }\n\n    X1 = (X1 + 1) % laf.length;\n\n}\n"}
{"idx": 19301, "func": "public static String compressBad (String X1) {\n\n    if (X1.length () == 1) return X1 + \"1\";\n\n    int countConsecutive = 0;\n\n    String compressedString = \"\";\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        if (i > 0) {\n\n            countConsecutive ++;\n\n            if (X1.charAt (i) != X1.charAt (i - 1)) {\n\n                compressedString += \"\" + X1.charAt (i - 1) + countConsecutive;\n\n                countConsecutive = 0;\n\n            }\n\n            if (i == X1.length () - 1) {\n\n                countConsecutive ++;\n\n                compressedString += \"\" + X1.charAt (i) + countConsecutive;\n\n            }\n\n        }\n\n    }\n\n    return compressedString;\n\n}\n"}
{"idx": 19302, "func": "public static String compressBad (String str) {\n\n    String X1 = \"\";\n\n    if (str != null && str.length () > 0) {\n\n        int countConsecutive = 1;\n\n        char prevChar = str.charAt (0);\n\n        for (int i = 1;\n\n        i < str.length (); i ++) {\n\n            if (str.charAt (i) != prevChar) {\n\n                X1 += String.valueOf (prevChar) + countConsecutive;\n\n                prevChar = str.charAt (i);\n\n                countConsecutive = 1;\n\n                continue;\n\n            }\n\n            countConsecutive ++;\n\n        }\n\n        X1 += String.valueOf (prevChar) + countConsecutive;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 19401, "func": "public static String compressBad (String str) {\n\n    String compressedString = \"\";\n\n    if (str != null && str.length () > 0) {\n\n        int countConsecutive = 1;\n\n        char X1 = str.charAt (0);\n\n        for (int i = 1;\n\n        i < str.length (); i ++) {\n\n            if (str.charAt (i) != X1) {\n\n                compressedString += String.valueOf (X1) + countConsecutive;\n\n                X1 = str.charAt (i);\n\n                countConsecutive = 1;\n\n                continue;\n\n            }\n\n            countConsecutive ++;\n\n        }\n\n        compressedString += String.valueOf (X1) + countConsecutive;\n\n    }\n\n    return compressedString;\n\n}\n"}
{"idx": 19402, "func": "public static X1 compressBad (X1 str) {\n\n    int countConsecutive = 0;\n\n    X1 compressedString = \"\";\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        countConsecutive ++;\n\n        if (str.length () == (i + 1)) {\n\n            compressedString += \"\" + str.charAt (i) + countConsecutive;\n\n            countConsecutive = 0;\n\n            break;\n\n        } else if (str.charAt (i) != str.charAt (i + 1)) {\n\n            compressedString += \"\" + str.charAt (i) + countConsecutive;\n\n            countConsecutive = 0;\n\n        }\n\n    }\n\n    return compressedString;\n\n}\n"}
{"idx": 19501, "func": "private byte [] read (final File file) {\n\n    if (file.isDirectory ()) throw new RuntimeException (\"Unsupported operation, file \" + file.getAbsolutePath () + \" is a directory\");\n\n    if (file.length () > Integer.MAX_VALUE) throw new RuntimeException (\"Unsupported operation, file \" + file.getAbsolutePath () + \" is too big\");\n\n    Throwable pending = null;\n\n    FileInputStream in = null;\n\n    final byte X1 [] = new byte [(int) file.length ()];\n\n    try {\n\n        in = new FileInputStream (file);\n\n        in.read (X1);\n\n    } catch (Exception e) {\n\n        pending = new RuntimeException (\"Exception occured on reading file \" + file.getAbsolutePath (), e);\n\n    } finally {\n\n        if (in != null) {\n\n            try {\n\n                in.close ();\n\n            } catch (Exception e) {\n\n                if (pending == null) {\n\n                    pending = new RuntimeException (\"Exception occured on closing file\" + file.getAbsolutePath (), e);\n\n                }\n\n            }\n\n        }\n\n        if (pending != null) {\n\n            throw new RuntimeException (pending);\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 19502, "func": "public byte [] read (File file) throws IOException, FileTooBigException {\n\n    if (file.length () > MAX_FILE_SIZE) {\n\n        throw new FileTooBigException (file);\n\n    }\n\n    ByteArrayOutputStream X1 = null;\n\n    InputStream ios = null;\n\n    try {\n\n        byte [] buffer = new byte [4096];\n\n        X1 = new ByteArrayOutputStream ();\n\n        ios = new FileInputStream (file);\n\n        int read = 0;\n\n        while ((read = ios.read (buffer)) != - 1) {\n\n            X1.write (buffer, 0, read);\n\n        }\n\n    } finally {\n\n        try {\n\n            if (X1 != null) X1.close ();\n\n        } catch (IOException e) {\n\n        }\n\n        try {\n\n            if (ios != null) ios.close ();\n\n        } catch (IOException e) {\n\n        }\n\n    }\n\n    return X1.toByteArray ();\n\n}\n"}
{"idx": 19601, "func": "public static byte [] readBytes (InputStream inputStream) throws IOException {\n\n    byte [] b = new byte [1024];\n\n    ByteArrayOutputStream os = new ByteArrayOutputStream ();\n\n    int X1;\n\n    while ((X1 = inputStream.read (b)) != - 1) {\n\n        os.write (b, 0, X1);\n\n    }\n\n    return os.toByteArray ();\n\n}\n"}
{"idx": 19602, "func": "public static byte [] readBytes (InputStream inputStream) throws IOException {\n\n    byte [] X1 = new byte [32 * 1024];\n\n    int bufferSize = 0;\n\n    for (;;) {\n\n        int read = inputStream.read (X1, bufferSize, X1.length - bufferSize);\n\n        if (read == - 1) {\n\n            return Arrays.copyOf (X1, bufferSize);\n\n        }\n\n        bufferSize += read;\n\n        if (bufferSize == X1.length) {\n\n            X1 = Arrays.copyOf (X1, bufferSize * 2);\n\n        }\n\n    }\n\n}\n"}
{"idx": 19701, "func": "public Object next () throws NoSuchElementException {\n\n    formNextPermutation ();\n\n    int i = size - 1;\n\n    while (permutation [i] > permutation [i + 1]) i --;\n\n    if (i == 0) {\n\n        next = false;\n\n        for (int j = 0;\n\n        j < size + 1; j ++) {\n\n            permutation [j] = j;\n\n        }\n\n        return ar;\n\n    }\n\n    int j = size;\n\n    while (permutation [i] > permutation [j]) j --;\n\n    swap (i, j);\n\n    int r = size;\n\n    int X1 = i + 1;\n\n    while (r > X1) {\n\n        swap (r, X1);\n\n        r --;\n\n        X1 ++;\n\n    }\n\n    return ar;\n\n}\n"}
{"idx": 19702, "func": "public E [] next () {\n\n    if (! has_next) throw new NoSuchElementException ();\n\n    for (int i = 0;\n\n    i < ind.length; i ++) {\n\n        output [i] = arr [ind [i]];\n\n    }\n\n    has_next = false;\n\n    for (int X1 = ind.length - 1;\n\n    X1 > 0; X1 --) {\n\n        if (ind [X1 - 1] < ind [X1]) {\n\n            int s = ind.length - 1;\n\n            while (ind [X1 - 1] >= ind [s]) s --;\n\n            swap (ind, X1 - 1, s);\n\n            for (int i = X1, j = ind.length - 1;\n\n            i < j; i ++, j --) {\n\n                swap (ind, i, j);\n\n            }\n\n            has_next = true;\n\n            break;\n\n        }\n\n    }\n\n    return output;\n\n}\n"}
{"idx": 19801, "func": "public Command deserialize (X1 json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n\n    try {\n\n        JsonObject commandObject = json.getAsJsonObject ();\n\n        X1 commandTypeElement = commandObject.get (commandElementName);\n\n        Class < ? extends Command > commandInstanceClass = commandRegistry.get (commandTypeElement.getAsString ());\n\n        Command command = gson.fromJson (json, commandInstanceClass);\n\n        return command;\n\n    } catch (Exception e) {\n\n        throw new RuntimeException (e);\n\n    }\n\n}\n"}
{"idx": 19802, "func": "public IAnimal X1 (JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n\n    JsonObject jsonObject = json.getAsJsonObject ();\n\n    JsonPrimitive prim = (JsonPrimitive) jsonObject.get (CLASSNAME);\n\n    String className = prim.getAsString ();\n\n    Class < ? > klass = null;\n\n    try {\n\n        klass = Class.forName (className);\n\n    } catch (ClassNotFoundException e) {\n\n        e.printStackTrace ();\n\n        throw new JsonParseException (e.getMessage ());\n\n    }\n\n    return context.X1 (jsonObject.get (INSTANCE), klass);\n\n}\n"}
{"idx": 19901, "func": "public Command deserialize (JsonElement X1, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n\n    try {\n\n        JsonObject commandObject = X1.getAsJsonObject ();\n\n        JsonElement commandTypeElement = commandObject.get (commandElementName);\n\n        Class < ? extends Command > commandInstanceClass = commandRegistry.get (commandTypeElement.getAsString ());\n\n        Command command = gson.fromJson (X1, commandInstanceClass);\n\n        return command;\n\n    } catch (Exception e) {\n\n        throw new RuntimeException (e);\n\n    }\n\n}\n"}
{"idx": 19902, "func": "public IAnimal X1 (JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n\n    JsonObject jsonObject = json.getAsJsonObject ();\n\n    JsonPrimitive prim = (JsonPrimitive) jsonObject.get (CLASSNAME);\n\n    String className = prim.getAsString ();\n\n    Class < ? > klass = null;\n\n    try {\n\n        klass = Class.forName (className);\n\n    } catch (ClassNotFoundException e) {\n\n        e.printStackTrace ();\n\n        throw new JsonParseException (e.getMessage ());\n\n    }\n\n    return context.X1 (jsonObject.get (INSTANCE), klass);\n\n}\n"}
{"idx": 20001, "func": "public IAnimal X1 (JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n\n    JsonObject jsonObject = json.getAsJsonObject ();\n\n    JsonPrimitive prim = (JsonPrimitive) jsonObject.get (CLASSNAME);\n\n    String className = prim.getAsString ();\n\n    Class < ? > klass = null;\n\n    try {\n\n        klass = Class.forName (className);\n\n    } catch (ClassNotFoundException e) {\n\n        e.printStackTrace ();\n\n        throw new JsonParseException (e.getMessage ());\n\n    }\n\n    return context.X1 (jsonObject.get (INSTANCE), klass);\n\n}\n"}
{"idx": 20002, "func": "public static void main (String Args []) {\n\n    X1 testing = new X1 ();\n\n    testing.setDefaultCloseOperation (X1.EXIT_ON_CLOSE);\n\n    testing.setSize (1000, 1000);\n\n    testing.setVisible (true);\n\n    JLabel countDownLabel = new JLabel ();\n\n    countDownLabel.setText (\"Now it's : \" + Globals.seconds);\n\n    testing.add (countDownLabel);\n\n    CountDown countdown = new CountDown (countDownLabel);\n\n    Timer timer = new Timer (5000, countDown);\n\n    timer.start ();\n\n}\n"}
{"idx": 2001, "func": "@Override\n\npublic void serialize (Test value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {\n\n    jgen.writeStartObject ();\n\n    Field [] fields = value.getClass ().getDeclaredFields ();\n\n    for (Field X1 : fields) {\n\n        try {\n\n            jgen.writeObjectField (X1.getName (), X1.get (value));\n\n        } catch (IllegalArgumentException | IllegalAccessException e) {\n\n            e.printStackTrace ();\n\n        }\n\n    }\n\n    jgen.writeObjectField (\"extra_field\", \"whatever_value\");\n\n    jgen.writeEndObject ();\n\n}\n"}
{"idx": 2002, "func": "public void serialize (final Object bean, final JsonGenerator jgen, final SerializerProvider X1) throws IOException, JsonGenerationException {\n\n    jgen.writeStartObject ();\n\n    if (_propertyFilterId != null) {\n\n        serializeFieldsFiltered (bean, jgen, X1);\n\n    } else {\n\n        serializeFields (bean, jgen, X1);\n\n    }\n\n    serializerListener.postSerialization (bean, jgen);\n\n    jgen.writeEndObject ();\n\n}\n"}
{"idx": 201, "func": "static private void copyFolder (File src, File X1) {\n\n    if (src == null || X1 == null) return;\n\n    if (! src.isDirectory ()) return;\n\n    if (X1.exists ()) {\n\n        if (! X1.isDirectory ()) {\n\n            return;\n\n        }\n\n    } else {\n\n        X1.mkdir ();\n\n    }\n\n    if (src.listFiles () == null || src.listFiles ().length == 0) return;\n\n    for (File file : src.listFiles ()) {\n\n        File fileDest = new File (X1, file.getName ());\n\n        if (file.isDirectory ()) {\n\n            copyFolder (file, fileDest);\n\n        } else {\n\n            if (fileDest.exists ()) continue;\n\n            try {\n\n                Files.copy (file.toPath (), fileDest.toPath ());\n\n            } catch (IOException e) {\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 20101, "func": "public void mirroeView () {\n\n    BSTNode node = mirroeView (root);\n\n    preorder (node);\n\n    System.out.X1 ();\n\n    inorder (node);\n\n    System.out.X1 ();\n\n    postorder (node);\n\n    System.out.X1 ();\n\n}\n"}
{"idx": 20102, "func": "private BSTNode mirroeView (BSTNode X1) {\n\n    if (X1 == null || (X1.left == null && X1.rigth == null)) return X1;\n\n    BSTNode temp = X1.left;\n\n    X1.left = X1.rigth;\n\n    X1.rigth = temp;\n\n    mirroeView (X1.left);\n\n    mirroeView (X1.rigth);\n\n    return X1;\n\n}\n"}
{"idx": 202, "func": "public void copyFolder (X1 src, X1 dest) throws IOException {\n\n    try (Stream < Path > stream = Files.walk (src.toPath ())) {\n\n        stream.forEachOrdered (sourcePath -> {\n\n            try {\n\n                Files.copy (sourcePath, src.toPath ().resolve (dest.toPath ().relativize (sourcePath)));\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        });\n\n    }\n\n}\n"}
{"idx": 20201, "func": "public static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    char [] c1 = s1.toCharArray ();\n\n    char [] c2 = s2.toCharArray ();\n\n    Arrays.sort (c1);\n\n    Arrays.sort (c2);\n\n    for (int X1 = 0;\n\n    X1 < c1.length; X1 ++) {\n\n        if (c1 [X1] != c2 [X1]) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20202, "func": "public static boolean isAnagram (String s1, String s2) {\n\n    if (s1.X1 () != s2.X1 ()) {\n\n        return false;\n\n    }\n\n    for (int i = 0;\n\n    i < s2.X1 (); i ++) {\n\n        if (! s1.contains (\"\" + s2.charAt (i))) {\n\n            return false;\n\n        }\n\n        s1 = s1.replaceFirst (\"\" + s2.charAt (i), \"\");\n\n        s2 = s2.replaceFirst (\"\" + s2.charAt (i), \"\");\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20301, "func": "public static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    char [] c1 = s1.toCharArray ();\n\n    char [] c2 = s2.toCharArray ();\n\n    Arrays.sort (c1);\n\n    Arrays.sort (c2);\n\n    for (int X1 = 0;\n\n    X1 < c1.length; X1 ++) {\n\n        if (c1 [X1] != c2 [X1]) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20302, "func": "public static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) {\n\n        return false;\n\n    }\n\n    s1 = s1.toLowerCase ();\n\n    s2 = s2.toLowerCase ();\n\n    char [] c1 = s1.toCharArray ();\n\n    char [] c2 = s2.toCharArray ();\n\n    X1.sort (c1);\n\n    X1.sort (c2);\n\n    String sc1 = new String (c1);\n\n    String sc2 = new String (c2);\n\n    return sc1.equals (sc2);\n\n}\n"}
{"idx": 20401, "func": "static boolean isAnagram (X1 a, X1 b) {\n\n    a = a.toLowerCase ();\n\n    b = b.toLowerCase ();\n\n    if (a.length () != b.length ()) {\n\n        return false;\n\n    }\n\n    char [] chars = a.toCharArray ();\n\n    for (char c : chars) {\n\n        int index = b.indexOf (c);\n\n        if (index != - 1) {\n\n            b = b.substring (0, index) + b.substring (index + 1, b.length ());\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n    return b.isEmpty ();\n\n}\n"}
{"idx": 20402, "func": "public static boolean isAnagram (String s1, String X1) {\n\n    if (s1.length () != X1.length ()) {\n\n        return false;\n\n    }\n\n    s1 = s1.toLowerCase ();\n\n    X1 = X1.toLowerCase ();\n\n    char [] c1 = s1.toCharArray ();\n\n    char [] c2 = X1.toCharArray ();\n\n    Arrays.sort (c1);\n\n    Arrays.sort (c2);\n\n    String sc1 = new String (c1);\n\n    String sc2 = new String (c2);\n\n    return sc1.equals (sc2);\n\n}\n"}
{"idx": 20501, "func": "static boolean isAnagram (String a, String X1) {\n\n    a = a.toLowerCase ();\n\n    X1 = X1.toLowerCase ();\n\n    if (a.length () != X1.length ()) {\n\n        return false;\n\n    }\n\n    char [] chars = a.toCharArray ();\n\n    for (char c : chars) {\n\n        int index = X1.indexOf (c);\n\n        if (index != - 1) {\n\n            X1 = X1.substring (0, index) + X1.substring (index + 1, X1.length ());\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n    return X1.isEmpty ();\n\n}\n"}
{"idx": 20502, "func": "static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    int n = s1.length ();\n\n    int [] X1 = new int [256];\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        char c1 = s1.charAt (i);\n\n        X1 [c1] ++;\n\n        char c2 = s2.charAt (i);\n\n        X1 [c2] --;\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] != 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20601, "func": "public static boolean isAnagram (String s1, String X1) {\n\n    if (s1.length () != X1.length ()) {\n\n        return false;\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        if (! s1.contains (\"\" + X1.charAt (i))) {\n\n            return false;\n\n        }\n\n        s1 = s1.replaceFirst (\"\" + X1.charAt (i), \"\");\n\n        X1 = X1.replaceFirst (\"\" + X1.charAt (i), \"\");\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20602, "func": "public static boolean isAnagram (X1 s1, X1 s2) {\n\n    if (s1.length () != s2.length ()) {\n\n        return false;\n\n    }\n\n    s1 = s1.toLowerCase ();\n\n    s2 = s2.toLowerCase ();\n\n    char [] c1 = s1.toCharArray ();\n\n    char [] c2 = s2.toCharArray ();\n\n    Arrays.sort (c1);\n\n    Arrays.sort (c2);\n\n    X1 sc1 = new X1 (c1);\n\n    X1 sc2 = new X1 (c2);\n\n    return sc1.equals (sc2);\n\n}\n"}
{"idx": 20701, "func": "public static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) {\n\n        return false;\n\n    }\n\n    for (int i = 0;\n\n    i < s2.length (); i ++) {\n\n        if (! s1.contains (\"\" + s2.X1 (i))) {\n\n            return false;\n\n        }\n\n        s1 = s1.replaceFirst (\"\" + s2.X1 (i), \"\");\n\n        s2 = s2.replaceFirst (\"\" + s2.X1 (i), \"\");\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20702, "func": "static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    int n = s1.length ();\n\n    int [] X1 = new int [256];\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        char c1 = s1.charAt (i);\n\n        X1 [c1] ++;\n\n        char c2 = s2.charAt (i);\n\n        X1 [c2] --;\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] != 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20801, "func": "public static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) {\n\n        return false;\n\n    }\n\n    s1 = s1.toLowerCase ();\n\n    s2 = s2.toLowerCase ();\n\n    char [] X1 = s1.toCharArray ();\n\n    char [] c2 = s2.toCharArray ();\n\n    Arrays.sort (X1);\n\n    Arrays.sort (c2);\n\n    String sc1 = new String (X1);\n\n    String sc2 = new String (c2);\n\n    return sc1.equals (sc2);\n\n}\n"}
{"idx": 20802, "func": "static boolean isAnagram (X1 s1, X1 s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    int n = s1.length ();\n\n    int [] charMap = new int [256];\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        char c1 = s1.charAt (i);\n\n        charMap [c1] ++;\n\n        char c2 = s2.charAt (i);\n\n        charMap [c2] --;\n\n    }\n\n    for (int i = 0;\n\n    i < charMap.length; i ++) {\n\n        if (charMap [i] != 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 20901, "func": "public static int singleNumber (int [] nums) {\n\n    int temp = 0;\n\n    int answer = 0;\n\n    for (int i = 0;\n\n    i < nums.length; i ++) {\n\n        boolean X1 = true;\n\n        temp = nums [i];\n\n        for (int j = 0;\n\n        j < nums.length; j ++) {\n\n            if (temp == nums [j]) {\n\n                if (i != j) {\n\n                    X1 = false;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (X1 == true) {\n\n            answer = temp;\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 20902, "func": "public static int singleNumber (int [] nums) {\n\n    Set < Integer > X1 = new HashSet < > ();\n\n    for (int num : nums) {\n\n        if (! X1.add (num)) {\n\n            X1.remove (num);\n\n        }\n\n    }\n\n    return X1.iterator ().next ();\n\n}\n"}
{"idx": 21001, "func": "public static int singleNumber (int [] nums) {\n\n    int temp = 0;\n\n    int answer = 0;\n\n    for (int i = 0;\n\n    i < nums.length; i ++) {\n\n        boolean X1 = true;\n\n        temp = nums [i];\n\n        for (int j = 0;\n\n        j < nums.length; j ++) {\n\n            if (temp == nums [j]) {\n\n                if (i != j) {\n\n                    X1 = false;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (X1 == true) {\n\n            answer = temp;\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 21002, "func": "public static int singleNumber (int [] nums) {\n\n    int answer = 0;\n\n    ArrayList al = new ArrayList ();\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        al.add (nums [X1]);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        int test = nums [X1];\n\n        if (al.indexOf (test) == al.lastIndexOf (test)) {\n\n            answer = nums [X1];\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 2101, "func": "public static void main (String [] args) {\n\n    double X1 = 10;\n\n    long exceptionPlusCatchTime = 0, excepTime = 0, strTime = 0, throwTime = 0;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        exceptionPlusCatchTime += exceptionPlusCatchBlock ();\n\n        excepTime += createException ();\n\n        throwTime += catchBlock ();\n\n        strTime += createString ();\n\n    }\n\n    System.out.println (\"new Exception + throw/catch = \" + exceptionPlusCatchTime / X1);\n\n    System.out.println (\"new Exception only          = \" + excepTime / X1);\n\n    System.out.println (\"throw/catch only            = \" + throwTime / X1);\n\n    System.out.println (\"new String (benchmark)      = \" + strTime / X1);\n\n}\n"}
{"idx": 2102, "func": "public static void main (String [] args) {\n\n    long throwCatchTime = 0, newExceptionTime = 0, X1 = 0, noStackExceptionTime = 0;\n\n    for (int i = 0;\n\n    i < 30; i ++) {\n\n        throwCatchTime += throwCatchLoop ();\n\n        newExceptionTime += newExceptionLoop ();\n\n        X1 += newObjectLoop ();\n\n        noStackExceptionTime += newNoStackExceptionLoop ();\n\n    }\n\n    System.out.println (\"throwCatchTime = \" + throwCatchTime / 30);\n\n    System.out.println (\"newExceptionTime = \" + newExceptionTime / 30);\n\n    System.out.println (\"newStringTime = \" + X1 / 30);\n\n    System.out.println (\"noStackExceptionTime = \" + noStackExceptionTime / 30);\n\n}\n"}
{"idx": 21101, "func": "public static int singleNumber (int [] nums) {\n\n    Set < Integer > X1 = new HashSet < > ();\n\n    for (int num : nums) {\n\n        if (! X1.add (num)) {\n\n            X1.remove (num);\n\n        }\n\n    }\n\n    return X1.iterator ().next ();\n\n}\n"}
{"idx": 21102, "func": "public static int singleNumber (int [] nums) {\n\n    int answer = 0;\n\n    ArrayList al = new ArrayList ();\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        al.add (nums [X1]);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        int test = nums [X1];\n\n        if (al.indexOf (test) == al.lastIndexOf (test)) {\n\n            answer = nums [X1];\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 21201, "func": "public static boolean X1 (String s) {\n\n    boolean X1 = true;\n\n    for (int i = 0;\n\n    i < s.length () && X1; i ++) {\n\n        char c = s.charAt (i);\n\n        X1 = X1 & ((c >= '0' && c <= '9') || (c == '.') || (c == 'e') || (c == 'E') || (c == ''));\n\n    }\n\n    return isInteger;\n\n}\n"}
{"idx": 21202, "func": "public static boolean isNumber (String str) {\n\n    int X1 = 0, len = str.length ();\n\n    boolean a = false, b = false, c = false, d = false;\n\n    if (X1 < len && (str.charAt (X1) == '+' || str.charAt (X1) == '-')) X1 ++;\n\n    while (X1 < len && isDigit (str.charAt (X1))) {\n\n        X1 ++;\n\n        a = true;\n\n    }\n\n    if (X1 < len && (str.charAt (X1) == '.')) X1 ++;\n\n    while (X1 < len && isDigit (str.charAt (X1))) {\n\n        X1 ++;\n\n        b = true;\n\n    }\n\n    if (X1 < len && (str.charAt (X1) == 'e' || str.charAt (X1) == 'E') && (a || b)) {\n\n        X1 ++;\n\n        c = true;\n\n    }\n\n    if (X1 < len && (str.charAt (X1) == '+' || str.charAt (X1) == '-') && c) X1 ++;\n\n    while (X1 < len && isDigit (str.charAt (X1))) {\n\n        X1 ++;\n\n        d = true;\n\n    }\n\n    return X1 == len && (a || b) && (! c || (c && d));\n\n}\n"}
{"idx": 21301, "func": "static X1 encrypt (X1 data) {\n\n    X1 encrypted = new X1 (\"\");\n\n    for (char c : data.toCharArray ()) {\n\n        char newC = c + 2;\n\n        if (newC > 'z') newC -= 26;\n\n        encrypted += newC;\n\n    }\n\n    return encrpyted;\n\n}\n"}
{"idx": 21302, "func": "static String encrypt (String data) {\n\n    String X1 = new String (\"\");\n\n    for (char h : data.toCharArray ()) {\n\n        if (h == 'a') X1 += \" a', 'c\";\n\n        if (h == 'b') X1 += \"d\";\n\n        if (h == 'c') X1 += \"e\";\n\n        if (h == 'd') X1 += \"f\";\n\n        if (h == 'e') X1 += \"g\";\n\n        if (h == 'f') X1 += \"h\";\n\n        if (h == 'g') X1 += \"i\";\n\n        if (h == 'h') X1 += \"j\";\n\n        if (h == 'i') X1 += \"k\";\n\n        if (h == 'j') X1 += \"l\";\n\n        if (h == 'k') X1 += \"m\";\n\n        if (h == 'l') X1 += \"n\";\n\n        if (h == 'm') X1 += \"o\";\n\n        if (h == 'n') X1 += \"p\";\n\n        if (h == 'o') X1 += \"q\";\n\n        if (h == 'p') X1 += \"r\";\n\n        if (h == 'q') X1 += \"s\";\n\n        if (h == 'r') X1 += \"t\";\n\n        if (h == 's') X1 += \"u\";\n\n        if (h == 't') X1 += \"v\";\n\n        if (h == 'u') X1 += \"w\";\n\n        if (h == 'v') X1 += \"x\";\n\n        if (h == 'w') X1 += \"y\";\n\n        if (h == 'x') X1 += \"z\";\n\n        if (h == 'y') X1 += \"a\";\n\n        if (h == 'z') X1 += \"b\";\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 21401, "func": "public static void main (String [] args) {\n\n    X1 manager = new X1 ();\n\n    ScriptEngine engine = manager.getEngineByName (\"js\");\n\n    engine.put (\"a\", 1);\n\n    engine.put (\"b\", 2);\n\n    try {\n\n        String expression = \"(a + b) > 2\";\n\n        Object result = engine.eval (expression);\n\n        System.out.println (expression + \" ? \" + result);\n\n    } catch (ScriptException se) {\n\n        se.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 21402, "func": "public static void main (String [] args) {\n\n    long a = 5;\n\n    long b = 4;\n\n    String theExpression = \"a * b\";\n\n    JexlEngine jexl = new JexlEngine ();\n\n    Expression X1 = jexl.createExpression (theExpression);\n\n    JexlContext context = new MapContext ();\n\n    context.set (\"a\", a);\n\n    context.set (\"b\", b);\n\n    Long result = (Long) X1.evaluate (context);\n\n    System.out.println (\"The answer : \" + result);\n\n}\n"}
{"idx": 21501, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set set = new Set (X);\n\n    int ai;\n\n    int counter = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if ((ai = A [X1]) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (ai <= X && ! set.contains (ai)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return X1;\n\n            }\n\n            set.put (ai);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21502, "func": "public static int solution (int X, int [] A) {\n\n    Set < Integer > values = new HashSet < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (values.add (A [X1])) X --;\n\n        if (X == 0) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21601, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set set = new Set (X);\n\n    int ai;\n\n    int X1 = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((ai = A [i]) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (ai <= X && ! set.contains (ai)) {\n\n            X1 --;\n\n            if (X1 == 0) {\n\n                return i;\n\n            }\n\n            set.put (ai);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21602, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        try {\n\n            count [A [X1] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (X1 >= X - 1) {\n\n            for (int j = 0;\n\n            j < count.length; j ++) {\n\n                if (count [j] == 0) {\n\n                    break;\n\n                }\n\n                if (j == count.length - 1) {\n\n                    return X1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21701, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set set = new Set (X);\n\n    int X1;\n\n    int counter = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((X1 = A [i]) < NUMBER_LOWER || X1 > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (X1 <= X && ! set.contains (X1)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            set.put (X1);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21702, "func": "public static int solution (int X, int [] A) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (counter [A [X1]] == 0) {\n\n            counter [A [X1]] = A [X1];\n\n            x += 1;\n\n            if (x == X) {\n\n                return X1;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 21801, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set X1 = new Set (X);\n\n    int ai;\n\n    int counter = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((ai = A [i]) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (ai <= X && ! X1.contains (ai)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            X1.put (ai);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21802, "func": "public int solution (int X, int [] A) {\n\n    int list [] = A;\n\n    int X1 = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < list.length; iii ++) {\n\n        if (list [iii] <= searchedValue && ! arrayList.contains (list [iii])) {\n\n            X1 += list [iii];\n\n            if (X1 == sumV) {\n\n                return iii;\n\n            }\n\n            arrayList.add (list [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21901, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set set = new Set (X);\n\n    int X1;\n\n    int counter = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((X1 = A [i]) < NUMBER_LOWER || X1 > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (X1 <= X && ! set.contains (X1)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            set.put (X1);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 21902, "func": "public int solution (int X, int [] A) {\n\n    HashSet < Integer > hset = new HashSet < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (A [X1] <= X) hset.add (A [X1]);\n\n        if (hset.size () == X) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22001, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set set = new Set (X);\n\n    int ai;\n\n    int counter = X;\n\n    final int X1 = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((ai = A [i]) < NUMBER_LOWER || ai > X1) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (ai <= X && ! set.contains (ai)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            set.put (ai);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22002, "func": "public int solution (final int X, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int X1 = 1;\n\n    X1 <= X; X1 ++) {\n\n        emptyPosition.add (X1);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        emptyPosition.remove (A [X1]);\n\n        if (emptyPosition.size () == 0) {\n\n            return X1;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 2201, "func": "public static void main (String [] args) {\n\n    List < Integer > numberList = new ArrayList < > ();\n\n    List < String > strList = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < args.length; i ++) {\n\n        if (Pattern.matches (\"-?\\\\d+\", args [i])) {\n\n            numberList.add (Integer.parseInt (args [i]));\n\n        } else {\n\n            strList.add (args [i]);\n\n        }\n\n    }\n\n    String [] colors = strList.X1 (new String [0]);\n\n    int [] number = ArrayUtils.toPrimitive (numberList.X1 (new Integer [numberList.size ()]));\n\n}\n"}
{"idx": 2202, "func": "public static void main (String [] X1) {\n\n    String [] colors = new String [X1.length];\n\n    int color_ix = 0;\n\n    int number_idx = 0;\n\n    Integer [] number = new Integer [X1.length];\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] == null) {\n\n            continue;\n\n        }\n\n        try {\n\n            number [number_idx] = Integer.parseInt (X1 [i]);\n\n            number_idx ++;\n\n        } catch (NumberFormatException e) {\n\n            colors [color_ix] = X1 [i];\n\n            color_ix ++;\n\n        }\n\n    }\n\n    System.out.println (\"-----Number-----\");\n\n    for (int i = 0;\n\n    i < number_idx; i ++) {\n\n        System.out.println (number [i]);\n\n    }\n\n    System.out.println (\"-----Colors-----\");\n\n    for (int i = 0;\n\n    i < color_ix; i ++) {\n\n        System.out.println (colors [i]);\n\n    }\n\n}\n"}
{"idx": 22101, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set set = new Set (X);\n\n    int ai;\n\n    int counter = X;\n\n    final int X1 = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((ai = A [i]) < NUMBER_LOWER || ai > X1) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (ai <= X && ! set.contains (ai)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            set.put (ai);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22102, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int X1 = 0;\n\n    X1 < size; X1 ++) {\n\n        int temp = A [X1];\n\n        if (temp <= X) {\n\n            if (check [temp - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [temp - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = X1;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 22201, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set X1 = new Set (X);\n\n    int ai;\n\n    int counter = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((ai = A [i]) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (ai <= X && ! X1.contains (ai)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            X1.put (ai);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22202, "func": "public int solution (int X, int [] A) {\n\n    int len = A.length;\n\n    if (X > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        int X1 = A [i];\n\n        if (X1 <= X) {\n\n            if (isFilled [X1 - 1] == 0) {\n\n                isFilled [X1 - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22301, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set set = new Set (X);\n\n    int X1;\n\n    int counter = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((X1 = A [i]) < NUMBER_LOWER || X1 > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (X1 <= X && ! set.contains (X1)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            set.put (X1);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22302, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, X1 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (set.contains (A [i])) continue;\n\n        set.add (A [i]);\n\n        X1 += A [i];\n\n        if (sum1 == X1) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22401, "func": "public static final int solution (final int X, final int [] A) {\n\n    if (A.length < ARRAY_SIZE_LOWER || A.length > ARRAY_SIZE_UPPER) {\n\n        throw new RuntimeException (\"Array size out of bounds\");\n\n    }\n\n    Set X1 = new Set (X);\n\n    int ai;\n\n    int counter = X;\n\n    final int NUMBER_REAL_UPPER = min (NUMBER_UPPER, X);\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if ((ai = A [i]) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER) {\n\n            throw new RuntimeException (\"Number out of bounds\");\n\n        } else if (ai <= X && ! X1.contains (ai)) {\n\n            counter --;\n\n            if (counter == 0) {\n\n                return i;\n\n            }\n\n            X1.put (ai);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22402, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > X1 = new HashSet < > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        X1.add (A [i]);\n\n        if (X1.contains (X) && X1.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22501, "func": "public static int solution (int X1, int [] A) {\n\n    Set < Integer > values = new HashSet < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (values.add (A [i])) X1 --;\n\n        if (X1 == 0) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22502, "func": "public static int solution (int X, int [] A) {\n\n    int [] X1 = new int [X];\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        try {\n\n            X1 [A [i] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (i >= X - 1) {\n\n            for (int j = 0;\n\n            j < X1.length; j ++) {\n\n                if (X1 [j] == 0) {\n\n                    break;\n\n                }\n\n                if (j == X1.length - 1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22601, "func": "public static int solution (int X, int [] A) {\n\n    Set < Integer > values = new HashSet < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (values.add (A [X1])) X --;\n\n        if (X == 0) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22602, "func": "public static int solution (int X, int [] A) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (counter [A [X1]] == 0) {\n\n            counter [A [X1]] = A [X1];\n\n            x += 1;\n\n            if (x == X) {\n\n                return X1;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 22701, "func": "public static int solution (int X1, int [] A) {\n\n    Set < Integer > values = new HashSet < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (values.add (A [i])) X1 --;\n\n        if (X1 == 0) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22702, "func": "public int solution (int X, int [] A) {\n\n    int list [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < list.length; X1 ++) {\n\n        if (list [X1] <= searchedValue && ! arrayList.contains (list [X1])) {\n\n            sum += list [X1];\n\n            if (sum == sumV) {\n\n                return X1;\n\n            }\n\n            arrayList.add (list [X1]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22801, "func": "public static int solution (int X, int [] A) {\n\n    Set < Integer > values = new HashSet < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (values.add (A [X1])) X --;\n\n        if (X == 0) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22802, "func": "public int solution (int X, int [] A) {\n\n    HashSet < X1 > hset = new HashSet < X1 > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= X) hset.add (A [i]);\n\n        if (hset.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22901, "func": "public static int solution (int X, int [] A) {\n\n    Set < Integer > X1 = new HashSet < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (X1.add (A [i])) X --;\n\n        if (X == 0) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 22902, "func": "public int solution (final int X, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int X1 = 1;\n\n    X1 <= X; X1 ++) {\n\n        emptyPosition.add (X1);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        emptyPosition.remove (A [X1]);\n\n        if (emptyPosition.size () == 0) {\n\n            return X1;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23001, "func": "public static int solution (int X1, int [] A) {\n\n    Set < Integer > values = new HashSet < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (values.add (A [i])) X1 --;\n\n        if (X1 == 0) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23002, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int x = 0;\n\n    x < size; x ++) {\n\n        int X1 = A [x];\n\n        if (X1 <= X) {\n\n            if (check [X1 - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [X1 - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = x;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 2301, "func": "public double getSum () {\n\n    if (subAccounts != null) {\n\n        Double sum = 0.0;\n\n        for (int i = 0;\n\n        i < subAccounts.size (); i ++) {\n\n            sum += subAccounts.get (i).getSum ();\n\n        }\n\n        return X1 + sum;\n\n    } else {\n\n        return X1;\n\n    }\n\n}\n"}
{"idx": 2302, "func": "public double getSum () {\n\n    double result = this.amount;\n\n    if (this.X1 != null) {\n\n        for (Balance subAccount : this.X1) {\n\n            result = result + subAccount.getSum ();\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 23101, "func": "public static int solution (int X, int [] A) {\n\n    Set < X1 > values = new HashSet < X1 > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (values.add (A [i])) X --;\n\n        if (X == 0) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23102, "func": "public int solution (int X, int [] A) {\n\n    int len = A.length;\n\n    if (X > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int X1 = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        int x = A [i];\n\n        if (x <= X) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                X1 += 1;\n\n                if (X1 == X) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23201, "func": "public static int solution (int X, int [] A) {\n\n    Set < X1 > values = new HashSet < X1 > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (values.add (A [i])) X --;\n\n        if (X == 0) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23202, "func": "public int solution (int X1, int [] A) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, sum2 = 0;\n\n    for (int i = 0;\n\n    i <= X1; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (set.contains (A [i])) continue;\n\n        set.add (A [i]);\n\n        sum2 += A [i];\n\n        if (sum1 == sum2) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23301, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        try {\n\n            count [A [X1] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (X1 >= X - 1) {\n\n            for (int j = 0;\n\n            j < count.length; j ++) {\n\n                if (count [j] == 0) {\n\n                    break;\n\n                }\n\n                if (j == count.length - 1) {\n\n                    return X1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23302, "func": "public static int solution (int X, int [] X1) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (counter [X1 [i]] == 0) {\n\n            counter [X1 [i]] = X1 [i];\n\n            x += 1;\n\n            if (x == X) {\n\n                return i;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 23401, "func": "public static int solution (int X, int [] A) {\n\n    int [] X1 = new int [X];\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        try {\n\n            X1 [A [i] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (i >= X - 1) {\n\n            for (int j = 0;\n\n            j < X1.length; j ++) {\n\n                if (X1 [j] == 0) {\n\n                    break;\n\n                }\n\n                if (j == X1.length - 1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23402, "func": "public int solution (int X1, int [] A) {\n\n    int list [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X1;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < list.length; iii ++) {\n\n        if (list [iii] <= searchedValue && ! arrayList.contains (list [iii])) {\n\n            sum += list [iii];\n\n            if (sum == sumV) {\n\n                return iii;\n\n            }\n\n            arrayList.add (list [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23501, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        try {\n\n            count [A [i] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (i >= X - 1) {\n\n            for (int X1 = 0;\n\n            X1 < count.length; X1 ++) {\n\n                if (count [X1] == 0) {\n\n                    break;\n\n                }\n\n                if (X1 == count.length - 1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23502, "func": "public int solution (int X, int [] A) {\n\n    X1 < Integer > hset = new X1 < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= X) hset.add (A [i]);\n\n        if (hset.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23601, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        try {\n\n            count [A [i] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (i >= X - 1) {\n\n            for (int X1 = 0;\n\n            X1 < count.length; X1 ++) {\n\n                if (count [X1] == 0) {\n\n                    break;\n\n                }\n\n                if (X1 == count.length - 1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23602, "func": "public int solution (final int X1, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int i = 1;\n\n    i <= X1; i ++) {\n\n        emptyPosition.add (i);\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        emptyPosition.remove (A [i]);\n\n        if (emptyPosition.size () == 0) {\n\n            return i;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23701, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        try {\n\n            count [A [i] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (i >= X - 1) {\n\n            for (int X1 = 0;\n\n            X1 < count.length; X1 ++) {\n\n                if (count [X1] == 0) {\n\n                    break;\n\n                }\n\n                if (X1 == count.length - 1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23702, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int X1 = - 1;\n\n    for (int x = 0;\n\n    x < size; x ++) {\n\n        int temp = A [x];\n\n        if (temp <= X) {\n\n            if (check [temp - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [temp - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            X1 = x;\n\n            break;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 23801, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        try {\n\n            count [A [i] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (i >= X - 1) {\n\n            for (int X1 = 0;\n\n            X1 < count.length; X1 ++) {\n\n                if (count [X1] == 0) {\n\n                    break;\n\n                }\n\n                if (X1 == count.length - 1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23802, "func": "public int solution (int X, int [] A) {\n\n    int len = A.length;\n\n    if (X > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int X1 = 0;\n\n    X1 < len; X1 ++) {\n\n        int x = A [X1];\n\n        if (x <= X) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X) {\n\n                    return X1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23901, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        try {\n\n            count [A [X1] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (X1 >= X - 1) {\n\n            for (int j = 0;\n\n            j < count.length; j ++) {\n\n                if (count [j] == 0) {\n\n                    break;\n\n                }\n\n                if (j == count.length - 1) {\n\n                    return X1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 23902, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, X1 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (set.contains (A [i])) continue;\n\n        set.add (A [i]);\n\n        X1 += A [i];\n\n        if (sum1 == X1) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24001, "func": "public static int solution (int X, int [] A) {\n\n    int [] count = new int [X];\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        try {\n\n            count [A [X1] - 1] ++;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n\n        }\n\n        if (X1 >= X - 1) {\n\n            for (int j = 0;\n\n            j < count.length; j ++) {\n\n                if (count [j] == 0) {\n\n                    break;\n\n                }\n\n                if (j == count.length - 1) {\n\n                    return X1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24002, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > leaves = new HashSet < > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        leaves.add (A [X1]);\n\n        if (leaves.contains (X) && leaves.size () == X) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 2401, "func": "public boolean importData (TransferHandler.TransferSupport info) {\n\n    if (! canImport (info)) {\n\n        return false;\n\n    }\n\n    TransferHandler.DropLocation tdl = info.getDropLocation ();\n\n    if (! (tdl instanceof JTable.DropLocation)) {\n\n        return false;\n\n    }\n\n    JTable.DropLocation dl = (JTable.DropLocation) tdl;\n\n    JTable target = (JTable) info.getComponent ();\n\n    DefaultTableModel model = (DefaultTableModel) target.getModel ();\n\n    int X1 = dl.getRow ();\n\n    int max = model.getRowCount ();\n\n    if (X1 < 0 || X1 > max) {\n\n        X1 = max;\n\n    }\n\n    addIndex = X1;\n\n    target.setCursor (Cursor.getPredefinedCursor (Cursor.DEFAULT_CURSOR));\n\n    try {\n\n        Object [] values = (Object []) info.getTransferable ().getTransferData (localObjectFlavor);\n\n        addCount = values.length;\n\n        for (int i = 0;\n\n        i < values.length; i ++) {\n\n            int idx = X1 ++;\n\n            model.insertRow (idx, (Vector) values [i]);\n\n            target.getSelectionModel ().addSelectionInterval (idx, idx);\n\n        }\n\n        return true;\n\n    } catch (UnsupportedFlavorException | IOException ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 2402, "func": "public boolean importData (JComponent c, Transferable X1) {\n\n    if (canImport (c, X1.getTransferDataFlavors ())) {\n\n        try {\n\n            String str = (String) X1.getTransferData (DataFlavor.stringFlavor);\n\n            importString (c, str);\n\n            return true;\n\n        } catch (UnsupportedFlavorException ufe) {\n\n        } catch (IOException ioe) {\n\n        }\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 24101, "func": "public static int solution (int X, int [] A) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (counter [A [X1]] == 0) {\n\n            counter [A [X1]] = A [X1];\n\n            x += 1;\n\n            if (x == X) {\n\n                return X1;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 24102, "func": "public int solution (int X, int [] A) {\n\n    int list [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > X1 = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < list.length; iii ++) {\n\n        if (list [iii] <= searchedValue && ! X1.contains (list [iii])) {\n\n            sum += list [iii];\n\n            if (sum == sumV) {\n\n                return iii;\n\n            }\n\n            X1.add (list [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24201, "func": "public static int solution (int X, int [] A) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (counter [A [X1]] == 0) {\n\n            counter [A [X1]] = A [X1];\n\n            x += 1;\n\n            if (x == X) {\n\n                return X1;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 24202, "func": "public int solution (int X, int [] A) {\n\n    X1 < Integer > hset = new X1 < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= X) hset.add (A [i]);\n\n        if (hset.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24301, "func": "public static int solution (int X, int [] X1) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (counter [X1 [i]] == 0) {\n\n            counter [X1 [i]] = X1 [i];\n\n            x += 1;\n\n            if (x == X) {\n\n                return i;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 24302, "func": "public int solution (final int X1, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int i = 1;\n\n    i <= X1; i ++) {\n\n        emptyPosition.add (i);\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        emptyPosition.remove (A [i]);\n\n        if (emptyPosition.size () == 0) {\n\n            return i;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24401, "func": "public static int solution (int X, int [] A) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (counter [A [X1]] == 0) {\n\n            counter [A [X1]] = A [X1];\n\n            x += 1;\n\n            if (x == X) {\n\n                return X1;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 24402, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int X1 = 0;\n\n    X1 < size; X1 ++) {\n\n        int temp = A [X1];\n\n        if (temp <= X) {\n\n            if (check [temp - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [temp - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = X1;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 24501, "func": "public static int solution (int X, int [] A) {\n\n    int [] X1 = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (X1 [A [i]] == 0) {\n\n            X1 [A [i]] = A [i];\n\n            x += 1;\n\n            if (x == X) {\n\n                return i;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 24502, "func": "public int solution (int X, int [] A) {\n\n    int X1 = A.length;\n\n    if (X > X1) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        int x = A [i];\n\n        if (x <= X) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24601, "func": "public static int solution (int X, int [] A) {\n\n    int [] X1 = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (X1 [A [i]] == 0) {\n\n            X1 [A [i]] = A [i];\n\n            x += 1;\n\n            if (x == X) {\n\n                return i;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 24602, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, X1 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (set.contains (A [i])) continue;\n\n        set.add (A [i]);\n\n        X1 += A [i];\n\n        if (sum1 == X1) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24701, "func": "public static int solution (int X, int [] X1) {\n\n    int [] counter = new int [X + 1];\n\n    int ans = - 1;\n\n    int x = 0;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (counter [X1 [i]] == 0) {\n\n            counter [X1 [i]] = X1 [i];\n\n            x += 1;\n\n            if (x == X) {\n\n                return i;\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 24702, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > X1 = new HashSet < > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        X1.add (A [i]);\n\n        if (X1.contains (X) && X1.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24801, "func": "public int solution (int X, int [] A) {\n\n    int list [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > X1 = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < list.length; iii ++) {\n\n        if (list [iii] <= searchedValue && ! X1.contains (list [iii])) {\n\n            sum += list [iii];\n\n            if (sum == sumV) {\n\n                return iii;\n\n            }\n\n            X1.add (list [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24802, "func": "public int solution (int X1, int [] A) {\n\n    HashSet < Integer > hset = new HashSet < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= X1) hset.add (A [i]);\n\n        if (hset.size () == X1) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24901, "func": "public int solution (int X, int [] A) {\n\n    int list [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < list.length; X1 ++) {\n\n        if (list [X1] <= searchedValue && ! arrayList.contains (list [X1])) {\n\n            sum += list [X1];\n\n            if (sum == sumV) {\n\n                return X1;\n\n            }\n\n            arrayList.add (list [X1]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 24902, "func": "public int solution (final int X, final int [] A) {\n\n    Set < Integer > X1 = new HashSet < Integer > ();\n\n    for (int i = 1;\n\n    i <= X; i ++) {\n\n        X1.add (i);\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        X1.remove (A [i]);\n\n        if (X1.size () == 0) {\n\n            return i;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25001, "func": "public int solution (int X1, int [] A) {\n\n    int list [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X1;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < list.length; iii ++) {\n\n        if (list [iii] <= searchedValue && ! arrayList.contains (list [iii])) {\n\n            sum += list [iii];\n\n            if (sum == sumV) {\n\n                return iii;\n\n            }\n\n            arrayList.add (list [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25002, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int x = 0;\n\n    x < size; x ++) {\n\n        int X1 = A [x];\n\n        if (X1 <= X) {\n\n            if (check [X1 - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [X1 - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = x;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 2501, "func": "protected void cleanup (JComponent c, boolean remove) {\n\n    if (remove && indices != null) {\n\n        c.setCursor (Cursor.getPredefinedCursor (Cursor.DEFAULT_CURSOR));\n\n        DefaultTableModel model = (DefaultTableModel) ((JTable) c).getModel ();\n\n        if (addCount > 0) {\n\n            for (int X1 = 0;\n\n            X1 < indices.length; X1 ++) {\n\n                if (indices [X1] >= addIndex) {\n\n                    indices [X1] += addCount;\n\n                }\n\n            }\n\n        }\n\n        for (int X1 = indices.length - 1;\n\n        X1 >= 0; X1 --) {\n\n            model.removeRow (indices [X1]);\n\n        }\n\n    }\n\n    indices = null;\n\n    addCount = 0;\n\n    addIndex = - 1;\n\n}\n"}
{"idx": 2502, "func": "protected void cleanup (JComponent c, boolean remove) {\n\n    X1 source = (X1) c;\n\n    if (remove && rows != null) {\n\n        DefaultTableModel model = (DefaultTableModel) source.getModel ();\n\n        for (int i = rows.length - 1;\n\n        i >= 0; i --) {\n\n            model.removeRow (rows [i]);\n\n        }\n\n    }\n\n    rows = null;\n\n    addCount = 0;\n\n    addIndex = - 1;\n\n}\n"}
{"idx": 25101, "func": "public int solution (int X, int [] A) {\n\n    int X1 [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < X1.length; iii ++) {\n\n        if (X1 [iii] <= searchedValue && ! arrayList.contains (X1 [iii])) {\n\n            sum += X1 [iii];\n\n            if (sum == sumV) {\n\n                return iii;\n\n            }\n\n            arrayList.add (X1 [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25102, "func": "public int solution (int X1, int [] A) {\n\n    int len = A.length;\n\n    if (X1 > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X1];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        int x = A [i];\n\n        if (x <= X1) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25201, "func": "public int solution (int X, int [] A) {\n\n    int list [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > X1 = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < list.length; iii ++) {\n\n        if (list [iii] <= searchedValue && ! X1.contains (list [iii])) {\n\n            sum += list [iii];\n\n            if (sum == sumV) {\n\n                return iii;\n\n            }\n\n            X1.add (list [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25202, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, X1 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (set.contains (A [i])) continue;\n\n        set.add (A [i]);\n\n        X1 += A [i];\n\n        if (sum1 == X1) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25301, "func": "public int solution (int X, int [] A) {\n\n    int X1 [] = A;\n\n    int sum = 0;\n\n    int searchedValue = X;\n\n    int sumV = searchedValue * (searchedValue + 1) / 2;\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int iii = 0;\n\n    iii < X1.length; iii ++) {\n\n        if (X1 [iii] <= searchedValue && ! arrayList.contains (X1 [iii])) {\n\n            sum += X1 [iii];\n\n            if (sum == sumV) {\n\n                return iii;\n\n            }\n\n            arrayList.add (X1 [iii]);\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25302, "func": "public int solution (int X, int [] X1) {\n\n    Set < Integer > leaves = new HashSet < > ();\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        leaves.add (X1 [i]);\n\n        if (leaves.contains (X) && leaves.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25401, "func": "public int solution (int X, int [] X1) {\n\n    HashSet < Integer > hset = new HashSet < Integer > ();\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] <= X) hset.add (X1 [i]);\n\n        if (hset.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25402, "func": "public int solution (final int X, final int [] A) {\n\n    Set < Integer > X1 = new HashSet < Integer > ();\n\n    for (int i = 1;\n\n    i <= X; i ++) {\n\n        X1.add (i);\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        X1.remove (A [i]);\n\n        if (X1.size () == 0) {\n\n            return i;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25501, "func": "public int solution (int X, int [] A) {\n\n    HashSet < X1 > hset = new HashSet < X1 > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= X) hset.add (A [i]);\n\n        if (hset.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25502, "func": "public int solution (int X, int [] A) {\n\n    int X1 = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int x = 0;\n\n    x < X1; x ++) {\n\n        int temp = A [x];\n\n        if (temp <= X) {\n\n            if (check [temp - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [temp - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = x;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 25601, "func": "public int solution (int X, int [] A) {\n\n    HashSet < Integer > hset = new HashSet < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (A [X1] <= X) hset.add (A [X1]);\n\n        if (hset.size () == X) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25602, "func": "public int solution (int X1, int [] A) {\n\n    int len = A.length;\n\n    if (X1 > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X1];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        int x = A [i];\n\n        if (x <= X1) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X1) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25701, "func": "public int solution (int X1, int [] A) {\n\n    HashSet < Integer > hset = new HashSet < Integer > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= X1) hset.add (A [i]);\n\n        if (hset.size () == X1) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25702, "func": "public int solution (int X1, int [] A) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, sum2 = 0;\n\n    for (int i = 0;\n\n    i <= X1; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (set.contains (A [i])) continue;\n\n        set.add (A [i]);\n\n        sum2 += A [i];\n\n        if (sum1 == sum2) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25801, "func": "public int solution (final int X, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int X1 = 1;\n\n    X1 <= X; X1 ++) {\n\n        emptyPosition.add (X1);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        emptyPosition.remove (A [X1]);\n\n        if (emptyPosition.size () == 0) {\n\n            return X1;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25802, "func": "public int solution (int X, int [] X1) {\n\n    int size = X1.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int x = 0;\n\n    x < size; x ++) {\n\n        int temp = X1 [x];\n\n        if (temp <= X) {\n\n            if (check [temp - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [temp - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = x;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 25901, "func": "public int solution (final int X, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int X1 = 1;\n\n    X1 <= X; X1 ++) {\n\n        emptyPosition.add (X1);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        emptyPosition.remove (A [X1]);\n\n        if (emptyPosition.size () == 0) {\n\n            return X1;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 25902, "func": "public int solution (int X, int [] A) {\n\n    int len = A.length;\n\n    if (X > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int X1 = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        int x = A [i];\n\n        if (x <= X) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                X1 += 1;\n\n                if (X1 == X) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26001, "func": "public int solution (final int X, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int X1 = 1;\n\n    X1 <= X; X1 ++) {\n\n        emptyPosition.add (X1);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        emptyPosition.remove (A [X1]);\n\n        if (emptyPosition.size () == 0) {\n\n            return X1;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26002, "func": "public int solution (int X, int [] X1) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, sum2 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (set.contains (X1 [i])) continue;\n\n        set.add (X1 [i]);\n\n        sum2 += X1 [i];\n\n        if (sum1 == sum2) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 2601, "func": "public static void main (String [] args) {\n\n    int x = 123456789;\n\n    System.out.println (\"x = \" + x);\n\n    int X1 = x, n = 0;\n\n    while (X1 > 9) {\n\n        X1 /= 10;\n\n        ++ n;\n\n    }\n\n    for (int i = 0;\n\n    i < n; i ++) X1 *= 10;\n\n    x -= X1;\n\n    System.out.println (\"x with high digit removed = \" + x);\n\n}\n"}
{"idx": 2602, "func": "public static void main (String [] argv) {\n\n    final int x = 123456789;\n\n    int newX = x;\n\n    final double originalLog = Math.floor (Math.log10 (x));\n\n    final int X1 = (int) Math.pow (10, originalLog);\n\n    while (originalLog == Math.floor (Math.log10 (newX))) {\n\n        newX -= X1;\n\n    }\n\n    System.out.println (newX);\n\n}\n"}
{"idx": 26101, "func": "public int solution (final int X1, final int [] A) {\n\n    Set < Integer > emptyPosition = new HashSet < Integer > ();\n\n    for (int i = 1;\n\n    i <= X1; i ++) {\n\n        emptyPosition.add (i);\n\n    }\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        emptyPosition.remove (A [i]);\n\n        if (emptyPosition.size () == 0) {\n\n            return i;\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26102, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > leaves = new HashSet < > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        leaves.add (A [X1]);\n\n        if (leaves.contains (X) && leaves.size () == X) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26201, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int X1 = - 1;\n\n    for (int x = 0;\n\n    x < size; x ++) {\n\n        int temp = A [x];\n\n        if (temp <= X) {\n\n            if (check [temp - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [temp - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            X1 = x;\n\n            break;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 26202, "func": "public int solution (int X, int [] X1) {\n\n    int len = X1.length;\n\n    if (X > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        int x = X1 [i];\n\n        if (x <= X) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26301, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] X1 = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int x = 0;\n\n    x < size; x ++) {\n\n        int temp = A [x];\n\n        if (temp <= X) {\n\n            if (X1 [temp - 1] > 0) {\n\n                continue;\n\n            }\n\n            X1 [temp - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = x;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 26302, "func": "public int solution (int X, int [] X1) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, sum2 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (set.contains (X1 [i])) continue;\n\n        set.add (X1 [i]);\n\n        sum2 += X1 [i];\n\n        if (sum1 == sum2) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26401, "func": "public int solution (int X, int [] A) {\n\n    int size = A.length;\n\n    int [] check = new int [X];\n\n    int cmp = 0;\n\n    int time = - 1;\n\n    for (int x = 0;\n\n    x < size; x ++) {\n\n        int X1 = A [x];\n\n        if (X1 <= X) {\n\n            if (check [X1 - 1] > 0) {\n\n                continue;\n\n            }\n\n            check [X1 - 1] ++;\n\n            cmp ++;\n\n        }\n\n        if (cmp == X) {\n\n            time = x;\n\n            break;\n\n        }\n\n    }\n\n    return time;\n\n}\n"}
{"idx": 26402, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > leaves = new HashSet < > ();\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        leaves.add (A [X1]);\n\n        if (leaves.contains (X) && leaves.size () == X) return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26501, "func": "public int solution (int X, int [] A) {\n\n    int len = A.length;\n\n    if (X > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int X1 = 0;\n\n    X1 < len; X1 ++) {\n\n        int x = A [X1];\n\n        if (x <= X) {\n\n            if (isFilled [x - 1] == 0) {\n\n                isFilled [x - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X) {\n\n                    return X1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26502, "func": "public int solution (int X, int [] X1) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, sum2 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (set.contains (X1 [i])) continue;\n\n        set.add (X1 [i]);\n\n        sum2 += X1 [i];\n\n        if (sum1 == sum2) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26601, "func": "public int solution (int X, int [] A) {\n\n    int len = A.length;\n\n    if (X > len) {\n\n        return - 1;\n\n    }\n\n    int [] isFilled = new int [X];\n\n    int jumped = 0;\n\n    Arrays.fill (isFilled, 0);\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        int X1 = A [i];\n\n        if (X1 <= X) {\n\n            if (isFilled [X1 - 1] == 0) {\n\n                isFilled [X1 - 1] = 1;\n\n                jumped += 1;\n\n                if (jumped == X) {\n\n                    return i;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26602, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > X1 = new HashSet < > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        X1.add (A [i]);\n\n        if (X1.contains (X) && X1.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26701, "func": "public int solution (int X, int [] X1) {\n\n    Set < Integer > set = new HashSet < Integer > ();\n\n    int sum1 = 0, sum2 = 0;\n\n    for (int i = 0;\n\n    i <= X; i ++) {\n\n        sum1 += i;\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (set.contains (X1 [i])) continue;\n\n        set.add (X1 [i]);\n\n        sum2 += X1 [i];\n\n        if (sum1 == sum2) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26702, "func": "public int solution (int X, int [] A) {\n\n    Set < Integer > X1 = new HashSet < > ();\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        X1.add (A [i]);\n\n        if (X1.contains (X) && X1.size () == X) return i;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 26801, "func": "public static boolean isAvailable (String link) {\n\n    boolean available = false;\n\n    URL url = null;\n\n    try {\n\n        url = new URL (link);\n\n    } catch (MalformedURLException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    HttpURLConnection connection = null;\n\n    try {\n\n        connection = (HttpURLConnection) url.openConnection ();\n\n    } catch (X1 e1) {\n\n    }\n\n    connection.setRequestProperty (\"Connection\", \"close\");\n\n    connection.setConnectTimeout (100000);\n\n    try {\n\n        connection.connect ();\n\n    } catch (X1 e) {\n\n    }\n\n    try {\n\n        if (connection.getResponseCode () == 200) {\n\n            available = true;\n\n        } else available = false;\n\n    } catch (X1 e) {\n\n        e.printStackTrace ();\n\n    }\n\n    return available;\n\n}\n"}
{"idx": 26802, "func": "public void isAvailable () {\n\n    URL url = new URL (\"URL HERE\");\n\n    X1 connection = (X1) url.openConnection ();\n\n    connection.setRequestProperty (\"Connection\", \"close\");\n\n    connection.setConnectTimeout (10000);\n\n    connection.connect ();\n\n    if (connection.getResponseCode () == 200) {\n\n        return true;\n\n    } else return false;\n\n}\n"}
{"idx": 26901, "func": "public void actionPerformed (ActionEvent evt) {\n\n    if (! onKeyRelease) {\n\n        if (upTimer != null && upTimer.isRunning ()) {\n\n            return;\n\n        }\n\n        System.out.X1 (\"key pressed\");\n\n        label.setText (UP_KEY_PRESSED);\n\n        upTimer = new Timer (UP_TIMER_DELAY, new ActionListener () {\n\n            @Override\n\n            public void actionPerformed (ActionEvent e) {\n\n                Color c = label.getBackground ();\n\n                if (FLASH_COLOR.equals (c)) {\n\n                    label.setBackground (null);\n\n                    label.setForeground (Color.black);\n\n                } else {\n\n                    label.setBackground (FLASH_COLOR);\n\n                    label.setForeground (Color.white);\n\n                }\n\n            }}\n\n        );\n\n        upTimer.start ();\n\n    } else {\n\n        System.out.X1 (\"Key released\");\n\n        if (upTimer != null && upTimer.isRunning ()) {\n\n            upTimer.stop ();\n\n            upTimer = null;\n\n        }\n\n        label.setText (\"\");\n\n    }\n\n}\n"}
{"idx": 26902, "func": "public void actionPerformed (ActionEvent e) {\n\n    Color c = X1.getBackground ();\n\n    if (FLASH_COLOR.equals (c)) {\n\n        X1.setBackground (null);\n\n        X1.setForeground (Color.black);\n\n    } else {\n\n        X1.setBackground (FLASH_COLOR);\n\n        X1.setForeground (Color.white);\n\n    }\n\n}\n"}
{"idx": 27001, "func": "public static boolean isImmutable (Object object) {\n\n    if (object instanceof Number) {\n\n        if (object instanceof AtomicInteger) {\n\n        } else if (object instanceof AtomicLong) {\n\n        } else {\n\n            return true;\n\n        }\n\n    } else if (object instanceof String) {\n\n        return true;\n\n    } else if (object instanceof Character) {\n\n        return true;\n\n    } else if (object instanceof Class) {\n\n        return true;\n\n    }\n\n    Class < ? > objClass = object.getClass ();\n\n    if (! Modifier.isFinal (objClass.getModifiers ())) {\n\n        return false;\n\n    }\n\n    Field [] X1 = objClass.getDeclaredFields ();\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (! Modifier.isFinal (X1 [i].getModifiers ()) || ! isImmutable (X1 [i].getType ())) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 27002, "func": "static boolean isImmutable (Object obj) {\n\n    Class < ? > objClass = obj.getClass ();\n\n    Class < ? > superClass = objClass.getSuperclass ();\n\n    if (! Immutable.class.equals (superClass)) {\n\n        return false;\n\n    }\n\n    if (! Modifier.isFinal (objClass.X1 ())) {\n\n        return false;\n\n    }\n\n    Field [] objFields = objClass.getDeclaredFields ();\n\n    for (int i = 0;\n\n    i < objFields.length; i ++) {\n\n        if (! Modifier.isFinal (objFields [i].X1 ()) || ! isValidFieldType (objFields [i].getType ())) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 2701, "func": "static String transpose (String s) {\n\n    char [] c = s.toCharArray ();\n\n    int X1 = (int) Math.sqrt (s.length ());\n\n    for (int i = 0;\n\n    i < X1; ++ i) {\n\n        for (int j = i + 1;\n\n        j < X1; ++ j) {\n\n            char h = c [i * X1 + j];\n\n            c [i * X1 + j] = c [j * X1 + i];\n\n            c [j * X1 + i] = h;\n\n        }\n\n    }\n\n    return new String (c);\n\n}\n"}
{"idx": 2702, "func": "static String transpose (String X1, int rows, int columns) {\n\n    int n = X1.length ();\n\n    if (rows * columns != n) throw new IllegalArgumentException ();\n\n    StringBuilder sb = new StringBuilder ();\n\n    for (int i = 0;\n\n    i < n - 1; i ++) sb.append (X1.charAt (i * columns % (n - 1)));\n\n    sb.append (X1.charAt (n - 1));\n\n    return sb.toString ();\n\n}\n"}
{"idx": 27101, "func": "public static boolean hasDateExpired (int X1, Instant savedDate, Instant currentDate) {\n\n    boolean hasExpired = false;\n\n    if (savedDate != null && currentDate != null) {\n\n        if (savedDate.plus (X1, ChronoUnit.DAYS).isBefore (currentDate)) {\n\n            hasExpired = true;\n\n        }\n\n    }\n\n    return hasExpired;\n\n}\n"}
{"idx": 27102, "func": "private static boolean hasDateExpired (int days, java.util.Date savedDate) throws ParseException {\n\n    SimpleDateFormat dateFormatUtc = new SimpleDateFormat (\"yyyy-MMM-dd HH:mm:ss\");\n\n    dateFormatUtc.setTimeZone (TimeZone.getTimeZone (\"UTC\"));\n\n    SimpleDateFormat dateFormatLocal = new SimpleDateFormat (\"yyyy-MMM-dd HH:mm:ss\");\n\n    savedDate = dateFormatLocal.parse (dateFormatUtc.X1 (savedDate));\n\n    Date dateTimeNow = dateFormatLocal.parse (dateFormatUtc.X1 (new Date ()));\n\n    long expires = dateTimeNow.getTime () + (DAY_IN_MS * days);\n\n    Date expiresDate = new Date (expires);\n\n    System.out.println (\"savedDate \\t\\t\" + savedDate + \"\\nexpiresDate \\t\" + expiresDate);\n\n    return savedDate.before (expiresDate);\n\n}\n"}
{"idx": 27201, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            JFrame X1 = new JFrame ();\n\n            X1.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n            X1.setSize (new Dimension (300, 300));\n\n            X1.add (new Panel ());\n\n            X1.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 27202, "func": "public static void main (String [] args) {\n\n    javax.swing.SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 rVR = new X1 ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 27301, "func": "public ValidateRevalidateRepaint () {\n\n    validate = revalidate = repaint = false;\n\n    panel = new JPanel (new GridBagLayout ());\n\n    gbc = new GridBagConstraints ();\n\n    gbc.insets = new Insets (0, 20, 0, 20);\n\n    panel.X1 (getFiller (), gbc);\n\n    JFrame f = new JFrame ();\n\n    f.setJMenuBar (getMenuBar ());\n\n    f.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    f.getContentPane ().X1 (panel);\n\n    f.getContentPane ().X1 (getRadioPanel (), \"East\");\n\n    f.getContentPane ().X1 (getCheckBoxPanel (), \"South\");\n\n    f.setSize (400, 200);\n\n    f.setLocation (200, 200);\n\n    f.setVisible (true);\n\n}\n"}
{"idx": 27302, "func": "public ValidateRevalidateRepaint () {\n\n    center = new JPanel (new GridLayout (1, 0, 10, 10));\n\n    JFrame f = new JFrame ();\n\n    f.setTitle (\"VRR\");\n\n    f.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    f.X1 (center, BorderLayout.CENTER);\n\n    f.X1 (getRadioPanel (), BorderLayout.EAST);\n\n    f.X1 (getCheckBoxPanel (), BorderLayout.SOUTH);\n\n    makeChange (4);\n\n    f.pack ();\n\n    f.setLocationRelativeTo (null);\n\n    f.setVisible (true);\n\n}\n"}
{"idx": 27401, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    switch (requestCode) {\n\n        case REQUEST_CODE_CAMERA :\n\n            if (grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                Toast.makeText (this, \"Thanks for your permission\", X1).show ();\n\n                openScanBarCodeAcitvity ();\n\n            } else {\n\n                Toast.makeText (this, \"We need your permission to open camera\", X1).show ();\n\n            }\n\n        default :\n\n            super.onRequestPermissionsResult (requestCode, permissions, grantResults);\n\n            break;\n\n    }\n\n}\n"}
{"idx": 27402, "func": "@Override\n\npublic void onRequestPermissionsResult (int X1,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    super.onRequestPermissionsResult (X1, permissions, grantResults);\n\n    if (X1 == REQUEST_CODE_CAMERA && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n    } else {\n\n    }\n\n}\n"}
{"idx": 27501, "func": "static GenericType X1 (String s) {\n\n    StreamTokenizer tokenizer = new StreamTokenizer (new StringReader (s));\n\n    tokenizer.wordChars ('.', '.');\n\n    try {\n\n        tokenizer.nextToken ();\n\n        return X1 (tokenizer);\n\n    } catch (IOException e) {\n\n        throw new RuntimeException ();\n\n    }\n\n}\n"}
{"idx": 27502, "func": "static GenericType parse (StreamTokenizer X1) throws IOException {\n\n    String baseName = X1.sval;\n\n    X1.nextToken ();\n\n    List < GenericType > params = new ArrayList < > ();\n\n    if (X1.ttype == '<') {\n\n        do {\n\n            X1.nextToken ();\n\n            params.add (parse (X1));\n\n        } while (X1.ttype == ',');\n\n        X1.nextToken ();\n\n    }\n\n    return new GenericType (baseName, params);\n\n}\n"}
{"idx": 27601, "func": "public static int [] bubbleSort (int [] a) {\n\n    int n = a.length;\n\n    int j = 0;\n\n    boolean X1 = true;\n\n    while (X1) {\n\n        X1 = false;\n\n        for (int j = 1;\n\n        j < n; j ++) {\n\n            if (a [j - 1] > a [j]) {\n\n                j = a [j - 1];\n\n                a [j - 1] = a [j];\n\n                a [j] = j;\n\n                X1 = true;\n\n            }\n\n        }\n\n        n = n - 1;\n\n    }\n\n    return a;\n\n}\n"}
{"idx": 27602, "func": "public static void bubbleSort (int [] numArray) {\n\n    int n = numArray.length;\n\n    int temp = 0;\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        for (int X1 = 1;\n\n        X1 < (n - i); X1 ++) {\n\n            if (numArray [X1 - 1] > numArray [X1]) {\n\n                temp = numArray [X1 - 1];\n\n                numArray [X1 - 1] = numArray [X1];\n\n                numArray [X1] = temp;\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 27701, "func": "public static boolean isBinaryFile (File f) throws FileNotFoundException, IOException {\n\n    FileInputStream in = new FileInputStream (f);\n\n    int size = in.available ();\n\n    if (size > 1024) size = 1024;\n\n    byte [] data = new byte [size];\n\n    in.read (data);\n\n    in.close ();\n\n    int ascii = 0;\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < data.length; i ++) {\n\n        byte b = data [i];\n\n        if (b < 0x09) return true;\n\n        if (b == 0x09 || b == 0x0A || b == 0x0C || b == 0x0D) ascii ++;\n\n        else if (b >= 0x20 && b <= 0x7E) ascii ++;\n\n        else X1 ++;\n\n    }\n\n    if (X1 == 0) return false;\n\n    return 100 * X1 / (ascii + X1) > 95;\n\n}\n"}
{"idx": 27702, "func": "boolean isBinaryFile (File X1) throws IOException {\n\n    String type = Files.probeContentType (X1.toPath ());\n\n    if (type == null) {\n\n        return true;\n\n    } else if (type.startsWith (\"text\")) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n"}
{"idx": 27801, "func": "public Key secondMaxKey () {\n\n    if (this.size () <= 1) return null;\n\n    if (this.size () == 2) {\n\n        if (first.X1.compareTo (first.next.X1) > 0) {\n\n            return first.next.X1;\n\n        }\n\n    }\n\n    Key max = first.X1;\n\n    Key secondMax = first.next.X1;\n\n    Node n = first;\n\n    for (Node x = n.next;\n\n    x != null; x = x.next) {\n\n        if (x.X1.compareTo (max) >= 0) {\n\n            secondMax = max;\n\n            max = x.X1;\n\n        } else if (x.X1.compareTo (secondMax) > 0) secondMax = x.X1;\n\n    }\n\n    return secondMax;\n\n}\n"}
{"idx": 27802, "func": "public Key secondMaxKey () {\n\n    if (size () < 2) {\n\n        return null;\n\n    }\n\n    X1 max = null;\n\n    X1 max_2 = null;\n\n    X1 second = first.next;\n\n    if (first.key.compareTo (second.key) > 0) {\n\n        max = first;\n\n        max_2 = second;\n\n    } else {\n\n        max = second;\n\n        max_2 = first;\n\n    }\n\n    for (X1 x = second.next;\n\n    x != null; x = x.next) {\n\n        if (x.key.compareTo (max.key) > 0) {\n\n            max_2 = max;\n\n            max = x;\n\n        } else if ((x.key.compareTo (max_2.key) > 0) && (x.key.compareTo (max.key) < 0)) {\n\n            max_2 = x;\n\n        }\n\n    }\n\n    return max_2.key;\n\n}\n"}
{"idx": 27901, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2d = (Graphics2D) g.create ();\n\n    g2d.setColor (Color.RED);\n\n    g2d.drawLine (getWidth () / 2, 0, getWidth () / 2, getHeight ());\n\n    g2d.drawLine (0, getHeight () / 2, getWidth (), getHeight () / 2);\n\n    FontRenderContext X1 = g2d.getFontRenderContext ();\n\n    Font font = new Font (\"Arial\", Font.BOLD, 48);\n\n    TextLayout txt = new TextLayout (text, font, X1);\n\n    Rectangle2D bounds = txt.getBounds ();\n\n    int x = (int) ((getWidth () - (int) bounds.getWidth ()) / 2);\n\n    int y = (int) ((getHeight () - (bounds.getHeight () - txt.getDescent ())) / 2);\n\n    y += txt.getAscent () - txt.getDescent ();\n\n    g2d.setFont (font);\n\n    g2d.setColor (Color.BLACK);\n\n    g2d.drawString (text, x, y);\n\n    g2d.setColor (Color.BLUE);\n\n    g2d.translate (x, y);\n\n    g2d.draw (bounds);\n\n    g2d.dispose ();\n\n}\n"}
{"idx": 27902, "func": "@Override\n\nprotected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Font font = new Font (\"Arial\", Font.BOLD, 48);\n\n    String text = \"Along time ago, in a galaxy, far, far away\";\n\n    Shape outline = font.createGlyphVector (g.getFontMetrics ().getFontRenderContext (), text).getOutline ();\n\n    AffineTransform transform = AffineTransform.getTranslateInstance (- outline.X1 ().getX () + getWidth () / 2 - outline.X1 ().width / 2, - outline.X1 ().getY () + getHeight () / 2 - outline.X1 ().height / 2);\n\n    outline = transform.createTransformedShape (outline);\n\n    g2d.fill (outline);\n\n}\n"}
{"idx": 28001, "func": "public ServletInputStream getInputStream () throws IOException {\n\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream (body);\n\n    return new ServletInputStream () {\n\n        @Override\n\n        public int X1 () throws IOException {\n\n            return byteArrayInputStream.X1 ();\n\n        }@Override\n\n        public boolean isFinished () {\n\n            return false;\n\n        }@Override\n\n        public boolean isReady () {\n\n            return false;\n\n        }@Override\n\n        public void setReadListener (ReadListener arg0) {\n\n        }}\n\n    ;\n\n}\n"}
{"idx": 28002, "func": "public ServletInputStream getInputStream () throws IOException {\n\n    final X1 byteArrayInputStream = new X1 (body.getBytes ());\n\n    ServletInputStream inputStream = new ServletInputStream () {\n\n        public int read () throws IOException {\n\n            return byteArrayInputStream.read ();\n\n        }}\n\n    ;\n\n    return inputStream;\n\n}\n"}
{"idx": 2801, "func": "public void manage () {\n\n    double speed = getSpeedfromVehicle ();\n\n    if ((speed >= 0 && speed <= 10) && state != SpeedState.LOW) {\n\n        state = SpeedState.LOW;\n\n        System.X1.println (\"Low Speed mode\");\n\n    } else if ((speed > 10 && speed < 60) && state != SpeedState.MEDIUM) {\n\n        state = SpeedState.MEDIUM;\n\n        System.X1.println (\"Medium Speed Mode\");\n\n    } else if ((speed >= 60) && state != SpeedState.HIGH) {\n\n        state = SpeedState.HIGH;\n\n        System.X1.println (\"High Speed Mode\");\n\n    }\n\n}\n"}
{"idx": 2802, "func": "public Speedo manage (int X1) {\n\n    if (X1 < getLowRange ()) {\n\n        onLowTransition ();\n\n        return getLowState ();\n\n    } else if (X1 > getHighRange ()) {\n\n        onHighTransition ();\n\n        return getHighState ();\n\n    } else {\n\n        return this;\n\n    }\n\n}\n"}
{"idx": 28101, "func": "public ServletInputStream getInputStream () throws X1 {\n\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream (body);\n\n    return new ServletInputStream () {\n\n        @Override\n\n        public int read () throws X1 {\n\n            return byteArrayInputStream.read ();\n\n        }@Override\n\n        public boolean isFinished () {\n\n            return false;\n\n        }@Override\n\n        public boolean isReady () {\n\n            return false;\n\n        }@Override\n\n        public void setReadListener (ReadListener arg0) {\n\n        }}\n\n    ;\n\n}\n"}
{"idx": 28102, "func": "public ServletInputStream getInputStream () throws X1 {\n\n    return new ServletInputStream () {\n\n        ByteArrayInputStream bais = new ByteArrayInputStream (body);\n\n        @Override\n\n        public int read () throws X1 {\n\n            return bais.read ();\n\n        }}\n\n    ;\n\n}\n"}
{"idx": 28201, "func": "public static void main (X1 [] args) {\n\n    X1 strExample = \"{'27': [], '10864': [u'8344', u'7769', u'7207', u'3735']}\";\n\n    List < X1 > keys = new ArrayList < X1 > ();\n\n    List < X1 > values = new ArrayList < X1 > ();\n\n    for (X1 component : strExample.replace (\"{\", \"\").split (\"][,}]\")) {\n\n        X1 kv [] = component.split (\": \");\n\n        keys.add (kv [0]);\n\n        values.add (kv [1] + \"]\");\n\n    }\n\n    System.out.println (\"Keys: \");\n\n    for (X1 key : keys) {\n\n        System.out.println (key);\n\n    }\n\n    System.out.println (\"\\nValues: \");\n\n    for (X1 value : values) {\n\n        System.out.println (value);\n\n    }\n\n}\n"}
{"idx": 28301, "func": "public static void main (X1 [] args) {\n\n    X1 input = \"(A,Name1,200), (A,Name1,200), (R,Name1,200), (A,Name2,900), (A,Name2,500)\";\n\n    Pattern p = Pattern.compile (\"\\\\(([A,R]?),(\\\\w+?),(\\\\d+?)\\\\)\");\n\n    Matcher m = p.matcher (input);\n\n    ArrayList < Score > scores = new ArrayList < Score > ();\n\n    ArrayList < Score > topScores = new ArrayList < Score > ();\n\n    while (m.find ()) {\n\n        X1 action = m.group (1);\n\n        X1 name = m.group (2);\n\n        double scoreVal = Double.valueOf (m.group (3));\n\n        Score score = new Score (name, scoreVal);\n\n        scores.add (score);\n\n        if (\"A\".equalsIgnoreCase (action)) {\n\n            topScores.add (score);\n\n        } else {\n\n            for (Score topScore : topScores) {\n\n                if (topScore.equals (score)) {\n\n                    topScores.remove (score);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (Score finalScore : topScores) {\n\n        System.out.println (finalScore);\n\n    }\n\n}\n"}
{"idx": 28302, "func": "public static void main (X1 [] args) {\n\n    X1 input = \"(A,Name1,200), (A,Name1,200), (R,Name1,200), (A,Name2,900), (A,Name2,500)\";\n\n    X1 [] scoreSets = input.split (\"\\\\),\");\n\n    List < Score > scoreList = new ArrayList < Score > ();\n\n    for (X1 score : scoreSets) {\n\n        score = score.trim ().substring (1);\n\n        int closeBrace = score.indexOf (')');\n\n        if (closeBrace == score.length () - 1) {\n\n            score = score.substring (0, score.length () - 1);\n\n        }\n\n        X1 [] tokens = score.split (\",\");\n\n        scoreList.add (new Score (tokens [0], tokens [1], Double.valueOf (tokens [2])));\n\n    }\n\n}\n"}
{"idx": 28401, "func": "public static void main (String args []) {\n\n    DataInputStream cin = new DataInputStream (X1.in);\n\n    try {\n\n        int i = Integer.parseInt (cin.readLine ());\n\n    } catch (ArithmeticException e) {\n\n    } catch (Exception e) {\n\n        X1.exit (0);\n\n    } finally {\n\n        X1.out.println (\"Won't be executed\");\n\n        X1.out.println (\"No error\");\n\n    }\n\n}\n"}
{"idx": 28402, "func": "public static void main (String args []) {\n\n    Runnable runnable = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            try {\n\n                printThreads (\"Daemon Thread printing\");\n\n                X1.sleep (10000);\n\n            } catch (Exception e) {\n\n            } finally {\n\n                System.out.println (\"finally\");\n\n            }\n\n        }}\n\n    ;\n\n    X1 daemonThread = new X1 (runnable);\n\n    daemonThread.setDaemon (Boolean.TRUE);\n\n    daemonThread.setName (\"My Daemon Thread\");\n\n    daemonThread.start ();\n\n    printThreads (\"main Thread Printing\");\n\n}\n"}
{"idx": 28501, "func": "public Component getTableCellEditorComponent (JTable table, Object value, boolean isSelected, int row, int column) {\n\n    _value = value;\n\n    JTextField X1 = new JTextField (_value.toString ());\n\n    X1.addKeyListener (new KeyAdapter () {\n\n        public void keyTyped (KeyEvent e) {\n\n            e.consume ();\n\n        }@Override\n\n        public void keyPressed (KeyEvent e) {\n\n            e.consume ();\n\n        }}\n\n    );\n\n    X1.setEditable (false);\n\n    return X1;\n\n}\n"}
{"idx": 28502, "func": "public Component getTableCellEditorComponent (JTable table, Object value, boolean isSelected, int row, int col) {\n\n    Component comp = super.getTableCellEditorComponent (table, value, isSelected, row, col);\n\n    if (value instanceof java.lang.String) {\n\n        DefaultStyledDocument X1 = new DefaultStyledDocument ();\n\n        try {\n\n            X1.insertString (0, (String) value, null);\n\n        } catch (BadLocationException e) {\n\n            e.printStackTrace ();\n\n        }\n\n        JTextPane jtp_comp = new JTextPane (X1);\n\n        jtp_comp.setEditable (false);\n\n        return jtp_comp;\n\n    }\n\n    return comp;\n\n}\n"}
{"idx": 28601, "func": "public static void main (String [] args) {\n\n    EventQueue.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            JFrame main_frame = new JFrame ();\n\n            main_frame.setPreferredSize (new Dimension (1200, 300));\n\n            main_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n            ArrayList < String > nonsense = new ArrayList < String > (Arrays.asList (\"Lorem ipsum dolor sit amet, sed dolore vivendum ut\", \"pri an soleat causae doctus.\", \"Alienum abhorreant mea ea\", \"cum malorum diceret ei. Pri oratio invidunt consequat ne.\", \"Ius tritani detraxit scribentur et\", \"has detraxit legendos intellegat at\", \"quo oporteat constituam ex\"));\n\n            JTable X1 = new JTable (10, 4);\n\n            X1.setRowHeight (X1.getRowHeight () * 2);\n\n            DefaultCellEditor cell_editor = new SelectableNonEditableCellEditor (new JTextField ());\n\n            cell_editor.setClickCountToStart (1);\n\n            X1.setDefaultEditor (Object.class, cell_editor);\n\n            TableCellRenderer renderer = new SelectableNonEditableTableRenderer ();\n\n            X1.setDefaultRenderer (Object.class, renderer);\n\n            for (int i = 0;\n\n            i < 10; i ++) {\n\n                X1.setValueAt (nonsense.get (i % nonsense.size ()), i, i % 4);\n\n            }\n\n            main_frame.getContentPane ().add (new JScrollPane (X1));\n\n            main_frame.pack ();\n\n            main_frame.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 28602, "func": "public static void main (String [] args) {\n\n    EventQueue.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            JFrame main_frame = new JFrame ();\n\n            main_frame.setPreferredSize (new Dimension (1200, 300));\n\n            main_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n            ArrayList < String > nonsense = new ArrayList < String > (Arrays.asList (\"Lorem ipsum dolor sit amet, sed dolore vivendum ut\", \"pri an soleat causae doctus.\", \"Alienum abhorreant mea ea\", \"cum malorum diceret ei. Pri oratio invidunt consequat ne.\", \"Ius tritani detraxit scribentur et\", \"has detraxit legendos intellegat at\", \"quo oporteat constituam ex\"));\n\n            JTable X1 = new JTable (10, 4);\n\n            X1.setRowHeight (X1.getRowHeight () * 2);\n\n            DefaultCellEditor cell_editor = new SelectableNonEditableCellEditor (new JTextField ());\n\n            cell_editor.setClickCountToStart (1);\n\n            X1.setDefaultEditor (Object.class, cell_editor);\n\n            TableCellRenderer renderer = new SelectableNonEditableTableRenderer ();\n\n            X1.setDefaultRenderer (Object.class, renderer);\n\n            for (int i = 0;\n\n            i < 10; i ++) {\n\n                X1.setValueAt (nonsense.get (i % nonsense.size ()), i, i % 4);\n\n            }\n\n            main_frame.getContentPane ().add (new JScrollPane (X1));\n\n            main_frame.pack ();\n\n            main_frame.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 28701, "func": "private static String [] tokenizer (String subject, String [] X1) {\n\n    Arrays.sort (X1, new Comparator < String > () {\n\n        @Override\n\n        public int compare (String s1, String s2) {\n\n            return s2.length () - s1.length ();\n\n        }}\n\n    );\n\n    List < String > tokens = new ArrayList < String > ();\n\n    tokens.add (subject);\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        tokens = splitStrings (tokens, X1, i);\n\n    }\n\n    return tokens.toArray (new String [] {});\n\n}\n"}
{"idx": 28702, "func": "public static String [] tokenizer (String text, String [] delims) {\n\n    for (String delim : delims) {\n\n        int i = text.indexOf (delim);\n\n        if (i >= 0) {\n\n            String [] tail = tokenizer (text.substring (i + delim.length ()), delims);\n\n            String [] X1 = new String [tail.length + 2];\n\n            X1 [0] = text.substring (0, i);\n\n            X1 [1] = delim;\n\n            System.arraycopy (tail, 0, X1, 2, tail.length);\n\n            return X1;\n\n        }\n\n    }\n\n    return new String [] {text};\n\n}\n"}
{"idx": 28801, "func": "private static String [] tokenizer (String subject, String [] delimiters) {\n\n    Arrays.sort (delimiters, new Comparator < String > () {\n\n        @Override\n\n        public int compare (String s1, String s2) {\n\n            return s2.length () - s1.length ();\n\n        }}\n\n    );\n\n    List < String > tokens = new ArrayList < String > ();\n\n    tokens.add (subject);\n\n    for (int X1 = 0;\n\n    X1 < delimiters.length; X1 ++) {\n\n        tokens = splitStrings (tokens, delimiters, X1);\n\n    }\n\n    return tokens.toArray (new String [] {});\n\n}\n"}
{"idx": 28802, "func": "public Object [] tokenizer (String value, String [] delimeters) {\n\n    List < String > X1 = new ArrayList < String > ();\n\n    for (String s : delimeters) {\n\n        if (value.contains (s)) {\n\n            String [] strArr = value.split (\"\\\\\" + s);\n\n            for (String str : strArr) {\n\n                X1.add (str);\n\n                if (! X1.contains (s)) {\n\n                    X1.add (s);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    Object [] newValues = X1.toArray ();\n\n    return newValues;\n\n}\n"}
{"idx": 28901, "func": "public static String [] tokenizer (String text, String [] delims) {\n\n    for (String X1 : delims) {\n\n        int i = text.indexOf (X1);\n\n        if (i >= 0) {\n\n            String [] tail = tokenizer (text.substring (i + X1.length ()), delims);\n\n            String [] list = new String [tail.length + 2];\n\n            list [0] = text.substring (0, i);\n\n            list [1] = X1;\n\n            System.arraycopy (tail, 0, list, 2, tail.length);\n\n            return list;\n\n        }\n\n    }\n\n    return new String [] {text};\n\n}\n"}
{"idx": 28902, "func": "public Object [] tokenizer (String value, String [] delimeters) {\n\n    List < String > list = new ArrayList < String > ();\n\n    for (String s : delimeters) {\n\n        if (value.contains (s)) {\n\n            String [] strArr = value.split (\"\\\\\" + s);\n\n            for (String X1 : strArr) {\n\n                list.add (X1);\n\n                if (! list.contains (s)) {\n\n                    list.add (s);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    Object [] newValues = list.toArray ();\n\n    return newValues;\n\n}\n"}
{"idx": 29001, "func": "public X1 onCreateViewHolder (ViewGroup parent, int viewType) {\n\n    Log.d (TAG, \"><![CDATA[>onCreateViewHolder(parent=\" + parent + \", viewType=\" + viewType + \")\");\n\n    X1 result;\n\n    switch (viewType) {\n\n        case ID_VIEW_HOLDER_ACTUAL :\n\n            {\n\n                View itemView = LayoutInflater.from (parent.getContext ()).inflate (R.layout.card_layout_actual, parent, false);\n\n                result = new ViewHolderActual (itemView, new ViewHolderActual.IViewHolderClick () {\n\n                    @Override\n\n                    public void onCardClick (View view, int position, X1 viewHolder) {\n\n                        Log.d (TAG, \"><![CDATA[<onCardClick(view=\" + view + \", position=\" + position + \", viewHolder=\" + viewHolder + \")\");\n\n                        Intent intent = new Intent (view.getContext (), OrderDetailActivity.class);\n\n                        intent.putExtra (OrderDetailActivity.ARG_ORDER_ID, viewHolder.getOrderId ());\n\n                        view.getContext ().startActivity (intent);\n\n                    }@Override\n\n                    public void onButtonClick (Button button, int position, X1 viewHolder) {\n\n                        Log.d (TAG, \"><![CDATA[<onButtonClick(button=\" + button + \", position=\" + position + \", viewHolder=\" + viewHolder + \")\");\n\n                        Intent intent = new Intent (button.getContext (), OrderMapActivity.class);\n\n                        intent.putExtra (OrderMapActivity.ARG_ORDER_ID, viewHolder.getOrderId ());\n\n                        button.getContext ().startActivity (intent);\n\n                    }}\n\n                );\n\n                break;\n\n            } case ID_VIEW_HOLDER :\n\n        default :\n\n            {\n\n                View itemView = LayoutInflater.from (parent.getContext ()).inflate (R.layout.card_layout, parent, false);\n\n                result = new X1 (itemView, new X1.IViewHolderClick () {\n\n                    @Override\n\n                    public void onCardClick (View view, int position, X1 viewHolder) {\n\n                        Log.d (TAG, \"><![CDATA[<onCardClick(view=\" + view + \", position=\" + position + \", viewHolder=\" + viewHolder + \")\");\n\n                        Intent intent = new Intent (view.getContext (), OrderDetailActivity.class);\n\n                        intent.putExtra (OrderDetailActivity.ARG_ORDER_ID, viewHolder.getOrderId ());\n\n                        view.getContext ().startActivity (intent);\n\n                    }}\n\n                );\n\n                break;\n\n            }}\n\n    Log.d (TAG, \"<<onCreateViewHolder(parent=\" + parent + \", viewType=\" + viewType + \")= \" + result);\n\n    return result;\n\n}\n"}
{"idx": 29002, "func": "@Override\n\npublic RecyclerView.ViewHolder onCreateViewHolder (ViewGroup X1, int viewType) {\n\n    View v = LayoutInflater.from (X1.getContext ()).inflate (R.layout.cell, null);\n\n    Button btn = (Button) v.findViewById (R.id.btn);\n\n    btn.setOnClickListener (new View.OnClickListener () {\n\n        @Override\n\n        public void onClick (View v) {\n\n        }}\n\n    );\n\n    return new MyViewHolder (v);\n\n}\n"}
{"idx": 2901, "func": "char wf () {\n\n    X1 input = new X1 (System.in);\n\n    System.out.println (\"What is your choice? (x/o)\");\n\n    char choice = input.findInLine (\".\").charAt (0);\n\n    while (choice != 'x' && choice != 'o') {\n\n        System.out.println (\"You must enter x or o!\");\n\n        choice = input.next ().charAt (0);\n\n    }\n\n    return choice;\n\n}\n"}
{"idx": 2902, "func": "char wf () {\n\n    Scanner input = new Scanner (System.in);\n\n    System.out.println (\"What is your choice? (x/o)\");\n\n    if (input.X1 (\".\") != null) {\n\n        choice = input.X1 (\".\").charAt (0);\n\n        while (choice != 'x' && choice != 'o') {\n\n            System.out.println (\"You must enter x or o!\");\n\n            choice = input.X1 (\".\").charAt (0);\n\n        }\n\n    }\n\n    return choice;\n\n}\n"}
{"idx": 29101, "func": "public MyViewHolder (View view) {\n\n    super (view);\n\n    view.setOnClickListener ((v) -> {\n\n        int X1 = getAdapterPosition ();\n\n        if (X1 >= 0) {\n\n            clicks.onItemSelected (myObject, X1);\n\n        }\n\n    });\n\n}\n"}
{"idx": 29102, "func": "public MyViewHolder (View itemView) {\n\n    super (itemView);\n\n    image = (ImageView) itemView.findViewById (X1.id.horizontal_list_image);\n\n    title = (TextView) itemView.findViewById (X1.id.horizontal_list_title);\n\n    price = (TextView) itemView.findViewById (X1.id.horizontal_list_price);\n\n    image.setOnClickListener (this);\n\n    title.setOnClickListener (this);\n\n    price.setOnClickListener (this);\n\n}\n"}
{"idx": 29201, "func": "public void handle (HttpExchange t) throws IOException {\n\n    String response = \"This is the response\";\n\n    long threadId = Thread.currentThread ().getId ();\n\n    System.out.println (\"I am thread \" + threadId);\n\n    response = response + \"Thread Id = \" + threadId;\n\n    t.sendResponseHeaders (200, response.length ());\n\n    OutputStream X1 = t.getResponseBody ();\n\n    X1.write (response.getBytes ());\n\n    X1.close ();\n\n}\n"}
{"idx": 29202, "func": "public void handle (final HttpExchange ex) throws IOException {\n\n    byte [] inBytes = getBytes (ex.getRequestBody ());\n\n    ex.getRequestBody ().close ();\n\n    final ByteArrayInputStream newInput = new ByteArrayInputStream (inBytes);\n\n    final ServletInputStream is = new ServletInputStream () {\n\n        @Override\n\n        public int read () throws IOException {\n\n            return newInput.read ();\n\n        }}\n\n    ;\n\n    Map < String, String [] > parsePostData = new HashMap < > ();\n\n    try {\n\n        parsePostData.putAll (HttpUtils.parseQueryString (ex.getRequestURI ().getQuery ()));\n\n        parsePostData.putAll (HttpUtils.parsePostData (inBytes.length, is));\n\n    } catch (IllegalArgumentException e) {\n\n        newInput.reset ();\n\n    }\n\n    final Map < String, String [] > postData = parsePostData;\n\n    RequestWrapper req = new RequestWrapper (createUnimplementAdapter (HttpServletRequest.class), ex, postData, is);\n\n    ResponseWrapper X1 = new ResponseWrapper (createUnimplementAdapter (HttpServletResponse.class), ex);\n\n    try {\n\n        servlet.service (req, X1);\n\n        X1.complete ();\n\n    } catch (ServletException e) {\n\n        throw new IOException (e);\n\n    }\n\n}\n"}
{"idx": 29301, "func": "int solution (int N) {\n\n    int tempGap = 0, gap = 0;\n\n    String X1 = Integer.toBinaryString (N);\n\n    int i = 0;\n\n    while (i < X1.length ()) {\n\n        if (X1.charAt (i) == '1') {\n\n            ++ i;\n\n            tempGap = 0;\n\n            while (i < X1.length () && X1.charAt (i) != '1') {\n\n                ++ i;\n\n                tempGap ++;\n\n            }\n\n            if (i >= X1.length ()) {\n\n                tempGap = 0;\n\n            }\n\n        } else {\n\n            ++ i;\n\n        }\n\n        if (tempGap > gap) {\n\n            gap = tempGap;\n\n        }\n\n    }\n\n    return gap;\n\n}\n"}
{"idx": 29302, "func": "public int solution (int N) {\n\n    String binary = Integer.toString (N, 2);\n\n    int largestGap = 0;\n\n    for (int X1 = 1, gap = 0;\n\n    X1 < binary.length (); X1 ++) {\n\n        while (X1 < binary.length () && binary.charAt (X1) == '0') {\n\n            X1 ++;\n\n            gap ++;\n\n        }\n\n        if (gap > largestGap && X1 < binary.length ()) {\n\n            largestGap = gap;\n\n        }\n\n        gap = 0;\n\n    }\n\n    return largestGap;\n\n}\n"}
{"idx": 29401, "func": "int solution (int N) {\n\n    int tempGap = 0, X1 = 0;\n\n    String binaryString = Integer.toBinaryString (N);\n\n    int i = 0;\n\n    while (i < binaryString.length ()) {\n\n        if (binaryString.charAt (i) == '1') {\n\n            ++ i;\n\n            tempGap = 0;\n\n            while (i < binaryString.length () && binaryString.charAt (i) != '1') {\n\n                ++ i;\n\n                tempGap ++;\n\n            }\n\n            if (i >= binaryString.length ()) {\n\n                tempGap = 0;\n\n            }\n\n        } else {\n\n            ++ i;\n\n        }\n\n        if (tempGap > X1) {\n\n            X1 = tempGap;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 29402, "func": "public static int solution (Integer number) {\n\n    String binary = Integer.toBinaryString (number);\n\n    String [] gaps = binary.split (\"1\");\n\n    String X1 = \"\";\n\n    for (int i = 0;\n\n    i < (binary.endsWith (\"1\") ? gaps.length : gaps.length - 1); i ++) {\n\n        if (gaps [i].contains (\"0\") && gaps [i].length () > X1.length ()) X1 = gaps [i];\n\n    }\n\n    return X1.length ();\n\n}\n"}
{"idx": 29501, "func": "int solution (int X1) {\n\n    int tempGap = 0, gap = 0;\n\n    String binaryString = Integer.toBinaryString (X1);\n\n    int i = 0;\n\n    while (i < binaryString.length ()) {\n\n        if (binaryString.charAt (i) == '1') {\n\n            ++ i;\n\n            tempGap = 0;\n\n            while (i < binaryString.length () && binaryString.charAt (i) != '1') {\n\n                ++ i;\n\n                tempGap ++;\n\n            }\n\n            if (i >= binaryString.length ()) {\n\n                tempGap = 0;\n\n            }\n\n        } else {\n\n            ++ i;\n\n        }\n\n        if (tempGap > gap) {\n\n            gap = tempGap;\n\n        }\n\n    }\n\n    return gap;\n\n}\n"}
{"idx": 29502, "func": "private static int solution (int N) {\n\n    int gap = 0;\n\n    X1 binaryStr = Integer.toBinaryString (N);\n\n    X1 [] zeroArrays = binaryStr.split (\"1\");\n\n    System.out.println (Arrays.toString (zeroArrays));\n\n    for (X1 zeroArray : zeroArrays) {\n\n        gap = zeroArray.length () > gap ? zeroArray.length () : gap;\n\n    }\n\n    return gap;\n\n}\n"}
{"idx": 29601, "func": "int solution (int N) {\n\n    int tempGap = 0, X1 = 0;\n\n    String binaryString = Integer.toBinaryString (N);\n\n    int i = 0;\n\n    while (i < binaryString.length ()) {\n\n        if (binaryString.charAt (i) == '1') {\n\n            ++ i;\n\n            tempGap = 0;\n\n            while (i < binaryString.length () && binaryString.charAt (i) != '1') {\n\n                ++ i;\n\n                tempGap ++;\n\n            }\n\n            if (i >= binaryString.length ()) {\n\n                tempGap = 0;\n\n            }\n\n        } else {\n\n            ++ i;\n\n        }\n\n        if (tempGap > X1) {\n\n            X1 = tempGap;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 29602, "func": "public int solution (int N) {\n\n    int result = 0;\n\n    while (N > 0) {\n\n        if ((N & 1) == 1) {\n\n            int X1 = 0;\n\n            while ((N>>= 1) > 0 && ((N & 1) != 1)) {\n\n                X1 ++;\n\n            }\n\n            result = Math.max (result, X1);\n\n        } else {\n\n            N>>= 1;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 29701, "func": "public int solution (int N) {\n\n    String binary = Integer.toString (N, 2);\n\n    int X1 = 0;\n\n    for (int i = 1, gap = 0;\n\n    i < binary.length (); i ++) {\n\n        while (i < binary.length () && binary.charAt (i) == '0') {\n\n            i ++;\n\n            gap ++;\n\n        }\n\n        if (gap > X1 && i < binary.length ()) {\n\n            X1 = gap;\n\n        }\n\n        gap = 0;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 29702, "func": "public static int solution (Integer number) {\n\n    String binary = Integer.toBinaryString (number);\n\n    String [] gaps = binary.split (\"1\");\n\n    String X1 = \"\";\n\n    for (int i = 0;\n\n    i < (binary.endsWith (\"1\") ? gaps.length : gaps.length - 1); i ++) {\n\n        if (gaps [i].contains (\"0\") && gaps [i].length () > X1.length ()) X1 = gaps [i];\n\n    }\n\n    return X1.length ();\n\n}\n"}
{"idx": 29801, "func": "public int solution (int N) {\n\n    String binary = Integer.toString (N, 2);\n\n    int X1 = 0;\n\n    for (int i = 1, gap = 0;\n\n    i < binary.length (); i ++) {\n\n        while (i < binary.length () && binary.charAt (i) == '0') {\n\n            i ++;\n\n            gap ++;\n\n        }\n\n        if (gap > X1 && i < binary.length ()) {\n\n            X1 = gap;\n\n        }\n\n        gap = 0;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 29802, "func": "private static int solution (int N) {\n\n    int X1 = 0;\n\n    String binaryStr = Integer.toBinaryString (N);\n\n    String [] zeroArrays = binaryStr.split (\"1\");\n\n    System.out.println (Arrays.toString (zeroArrays));\n\n    for (String zeroArray : zeroArrays) {\n\n        X1 = zeroArray.length () > X1 ? zeroArray.length () : X1;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 29901, "func": "public int solution (int N) {\n\n    String binary = Integer.toString (N, 2);\n\n    int X1 = 0;\n\n    for (int i = 1, gap = 0;\n\n    i < binary.length (); i ++) {\n\n        while (i < binary.length () && binary.charAt (i) == '0') {\n\n            i ++;\n\n            gap ++;\n\n        }\n\n        if (gap > X1 && i < binary.length ()) {\n\n            X1 = gap;\n\n        }\n\n        gap = 0;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 29902, "func": "public int solution (int X1) {\n\n    int result = 0;\n\n    while (X1 > 0) {\n\n        if ((X1 & 1) == 1) {\n\n            int temp = 0;\n\n            while ((X1>>= 1) > 0 && ((X1 & 1) != 1)) {\n\n                temp ++;\n\n            }\n\n            result = Math.max (result, temp);\n\n        } else {\n\n            X1>>= 1;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 30001, "func": "public static int solution (Integer number) {\n\n    String binary = Integer.toBinaryString (number);\n\n    String [] gaps = binary.split (\"1\");\n\n    String X1 = \"\";\n\n    for (int i = 0;\n\n    i < (binary.endsWith (\"1\") ? gaps.length : gaps.length - 1); i ++) {\n\n        if (gaps [i].contains (\"0\") && gaps [i].length () > X1.length ()) X1 = gaps [i];\n\n    }\n\n    return X1.length ();\n\n}\n"}
{"idx": 30002, "func": "public int solution (int N) {\n\n    int result = 0;\n\n    while (N > 0) {\n\n        if ((N & 1) == 1) {\n\n            int X1 = 0;\n\n            while ((N>>= 1) > 0 && ((N & 1) != 1)) {\n\n                X1 ++;\n\n            }\n\n            result = Math.max (result, X1);\n\n        } else {\n\n            N>>= 1;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 3001, "func": "public static void main (String [] args) {\n\n    String X1 = new String (\"fsdfesfsfdddddddsfdsfssdfdsfdsfdsfdsfdsdfggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggghghghghggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggfsdfesfsfdddddddsfdsfssdfdsfdsfdsfdsfdsdfggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggghghghghggggggggggggggggggggggggggggggggggggggggg\"\n);\n\n    byte [] data = X1.getBytes ();\n\n    System.out.println (\"src size \" + data.length);\n\n    try {\n\n        compress (data);\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 3002, "func": "public static void main (String [] args) {\n\n    byte [] dataToCompress = \"This is the test data.\".getBytes (StandardCharsets.ISO_8859_1);\n\n    try {\n\n        ByteArrayOutputStream byteStream = new ByteArrayOutputStream (dataToCompress.length);\n\n        try {\n\n            GZIPOutputStream X1 = new GZIPOutputStream (byteStream);\n\n            try {\n\n                X1.write (dataToCompress);\n\n            } finally {\n\n                X1.close ();\n\n            }\n\n        } finally {\n\n            byteStream.close ();\n\n        }\n\n        byte [] compressedData = byteStream.toByteArray ();\n\n        FileOutputStream fileStream = new FileOutputStream (\"C:/Users/UserName/Desktop/zip_file.gz\");\n\n        try {\n\n            fileStream.write (compressedData);\n\n        } finally {\n\n            try {\n\n                fileStream.close ();\n\n            } catch (Exception e) {\n\n            }\n\n        }\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 301, "func": "static private void X1 (File src, File dest) {\n\n    if (src == null || dest == null) return;\n\n    if (! src.isDirectory ()) return;\n\n    if (dest.exists ()) {\n\n        if (! dest.isDirectory ()) {\n\n            return;\n\n        }\n\n    } else {\n\n        dest.mkdir ();\n\n    }\n\n    if (src.listFiles () == null || src.listFiles ().length == 0) return;\n\n    for (File file : src.listFiles ()) {\n\n        File fileDest = new File (dest, file.getName ());\n\n        if (file.isDirectory ()) {\n\n            X1 (file, fileDest);\n\n        } else {\n\n            if (fileDest.exists ()) continue;\n\n            try {\n\n                Files.copy (file.toPath (), fileDest.toPath ());\n\n            } catch (IOException e) {\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 30101, "func": "private static int solution (int N) {\n\n    int X1 = 0;\n\n    String binaryStr = Integer.toBinaryString (N);\n\n    String [] zeroArrays = binaryStr.split (\"1\");\n\n    System.out.println (Arrays.toString (zeroArrays));\n\n    for (String zeroArray : zeroArrays) {\n\n        X1 = zeroArray.length () > X1 ? zeroArray.length () : X1;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 30102, "func": "public int solution (int N) {\n\n    int X1 = 0;\n\n    while (N > 0) {\n\n        if ((N & 1) == 1) {\n\n            int temp = 0;\n\n            while ((N>>= 1) > 0 && ((N & 1) != 1)) {\n\n                temp ++;\n\n            }\n\n            X1 = Math.max (X1, temp);\n\n        } else {\n\n            N>>= 1;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 302, "func": "public static void copyFolder (Path src, Path dest) {\n\n    try {\n\n        Files.walk (src).forEach (s -> {\n\n            try {\n\n                Path d = dest.resolve (src.relativize (s));\n\n                if (Files.isDirectory (s)) {\n\n                    if (! Files.exists (d)) Files.createDirectory (d);\n\n                    return;\n\n                }\n\n                Files.copy (s, d);\n\n            } catch (Exception X1) {\n\n                X1.printStackTrace ();\n\n            }\n\n        });\n\n    } catch (Exception ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 30201, "func": "public void start (Stage X1) {\n\n    ProgressData vb1 = new ProgressData (\"Progressbar 1\", - 1);\n\n    ProgressData vb2 = new ProgressData (\"Progressbar 2\", 0.2);\n\n    ProgressData vb3 = new ProgressData (\"Progressbar 3\", 0.3);\n\n    TextChooser textChooser = new TextChooser (vb1, vb2, vb3);\n\n    textChooser.setStyle (\"-fx-font: 10px \\\"Verdana\\\";\");\n\n    StackPane root = new StackPane ();\n\n    root.getChildren ().add (textChooser);\n\n    Scene scene = new Scene (root, 300, 250);\n\n    X1.setTitle (\"Hello World!\");\n\n    X1.setScene (scene);\n\n    X1.show ();\n\n}\n"}
{"idx": 30202, "func": "public void start (Stage primaryStage) {\n\n    double y1 = 15;\n\n    ProgressBar p1 = new ProgressBar ();\n\n    p1.setLayoutY (y1);\n\n    HBox vb1 = new HBox (10);\n\n    vb1.getChildren ().addAll (new Label (\"Progressbar 1\"), p1);\n\n    double y2 = 15;\n\n    ProgressBar p2 = new ProgressBar ();\n\n    p2.setLayoutY (y2);\n\n    HBox vb2 = new HBox (10);\n\n    vb2.getChildren ().addAll (new Label (\"Progressbar 2\"), p2);\n\n    double y3 = 15;\n\n    ProgressBar X1 = new ProgressBar ();\n\n    X1.setLayoutY (y3);\n\n    HBox vb3 = new HBox (10);\n\n    vb3.getChildren ().addAll (new Label (\"Progressbar 3\"), X1);\n\n    TextChooser textChooser = new TextChooser (vb1, vb2, vb3);\n\n    textChooser.setStyle (\"-fx-font: 10px \\\"Verdana\\\";\");\n\n    StackPane root = new StackPane ();\n\n    root.getChildren ().add (textChooser);\n\n    Scene scene = new Scene (root, 300, 250);\n\n    primaryStage.setTitle (\"Hello World!\");\n\n    primaryStage.setScene (scene);\n\n    primaryStage.show ();\n\n}\n"}
{"idx": 30301, "func": "public static int loneSum (int X1, int b, int c) {\n\n    if (X1 == b && b == c) {\n\n        X1 = 0;\n\n        b = 0;\n\n        c = 0;\n\n    }\n\n    if (X1 == b) {\n\n        X1 = 0;\n\n        b = 0;\n\n    }\n\n    if (X1 == c) {\n\n        X1 = 0;\n\n        c = 0;\n\n    }\n\n    if (b == c) {\n\n        b = 0;\n\n        c = 0;\n\n    }\n\n    return X1 + b + c;\n\n}\n"}
{"idx": 30302, "func": "public int loneSum (int a, int b, int c) {\n\n    int X1 = 0;\n\n    boolean ab = a != b;\n\n    boolean ac = a != c;\n\n    boolean bc = b != c;\n\n    if (ab && ac) X1 += a;\n\n    if (ab && bc) X1 += b;\n\n    if (bc && ac) X1 += c;\n\n    return X1;\n\n}\n"}
{"idx": 30401, "func": "public static void main (String...args) {\n\n    log (\"App started\");\n\n    byte [] X1 = new byte [1024 * 1024];\n\n    new Random ().nextBytes (X1);\n\n    log (\"Stream is ready\\n\");\n\n    try {\n\n        test (X1);\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 30402, "func": "public static void main (String [] args) {\n\n    InputStream X1 = StringFromFileFast.class.getResourceAsStream (\"file.txt\");\n\n    InputStreamReader input = new InputStreamReader (X1);\n\n    final int CHARS_PER_PAGE = 5000;\n\n    final char [] buffer = new char [CHARS_PER_PAGE];\n\n    StringBuilder output = new StringBuilder (CHARS_PER_PAGE);\n\n    try {\n\n        for (int read = input.read (buffer, 0, buffer.length);\n\n        read != - 1; read = input.read (buffer, 0, buffer.length)) {\n\n            output.append (buffer, 0, read);\n\n        }\n\n    } catch (IOException ignore) {\n\n    }\n\n    String text = output.toString ();\n\n    System.out.println (text);\n\n}\n"}
{"idx": 30501, "func": "public String inputStreamToString (InputStream in) throws IOException {\n\n    ReadableByteChannel channel = Channels.newChannel (in);\n\n    ByteBuffer X1 = ByteBuffer.allocate (1024 * 16);\n\n    ByteArrayOutputStream bout = new ByteArrayOutputStream ();\n\n    WritableByteChannel outChannel = Channels.newChannel (bout);\n\n    while (channel.read (X1) > 0 || X1.position () > 0) {\n\n        X1.flip ();\n\n        outChannel.write (X1);\n\n        X1.compact ();\n\n    }\n\n    channel.close ();\n\n    outChannel.close ();\n\n    return bout.toString (UTF_8);\n\n}\n"}
{"idx": 30502, "func": "public String inputStreamToString (InputStream inputStream) throws IOException {\n\n    try (ByteArrayOutputStream X1 = new ByteArrayOutputStream ()) {\n\n        byte [] buffer = new byte [1024];\n\n        int length;\n\n        while ((length = inputStream.read (buffer)) != - 1) {\n\n            X1.write (buffer, 0, length);\n\n        }\n\n        return X1.toString (UTF_8);\n\n    }\n\n}\n"}
{"idx": 30601, "func": "public String inputStreamToString (InputStream in) throws IOException {\n\n    ReadableByteChannel X1 = Channels.newChannel (in);\n\n    ByteBuffer byteBuffer = ByteBuffer.allocate (1024 * 16);\n\n    ByteArrayOutputStream bout = new ByteArrayOutputStream ();\n\n    WritableByteChannel outChannel = Channels.newChannel (bout);\n\n    while (X1.read (byteBuffer) > 0 || byteBuffer.position () > 0) {\n\n        byteBuffer.flip ();\n\n        outChannel.write (byteBuffer);\n\n        byteBuffer.compact ();\n\n    }\n\n    X1.close ();\n\n    outChannel.close ();\n\n    return bout.toString (UTF_8);\n\n}\n"}
{"idx": 30602, "func": "public String inputStreamToString (InputStream inputStream) throws IOException {\n\n    String newLine = System.getProperty (\"line.separator\");\n\n    BufferedReader reader = new BufferedReader (new InputStreamReader (inputStream));\n\n    StringBuilder result = new StringBuilder (UTF_8);\n\n    String line;\n\n    boolean X1 = false;\n\n    while ((line = reader.readLine ()) != null) {\n\n        result.append (X1 ? newLine : \"\").append (line);\n\n        X1 = true;\n\n    }\n\n    return result.toString ();\n\n}\n"}
{"idx": 30701, "func": "public String inputStreamToString (InputStream inputStream) throws IOException {\n\n    try (ByteArrayOutputStream X1 = new ByteArrayOutputStream ()) {\n\n        byte [] buffer = new byte [1024];\n\n        int length;\n\n        while ((length = inputStream.read (buffer)) != - 1) {\n\n            X1.write (buffer, 0, length);\n\n        }\n\n        return X1.toString (UTF_8);\n\n    }\n\n}\n"}
{"idx": 30702, "func": "public String inputStreamToString (InputStream inputStream) throws IOException {\n\n    String newLine = System.getProperty (\"line.separator\");\n\n    BufferedReader reader = new BufferedReader (new InputStreamReader (inputStream));\n\n    StringBuilder result = new StringBuilder (UTF_8);\n\n    String line;\n\n    boolean flag = false;\n\n    while ((line = reader.readLine ()) != null) {\n\n        result.X1 (flag ? newLine : \"\").X1 (line);\n\n        flag = true;\n\n    }\n\n    return result.toString ();\n\n}\n"}
{"idx": 30801, "func": "public static void main (String [] args) {\n\n    String s = \"AVBVDABCHJHDFABCJKHKHF\", ned = \"ABC\";\n\n    int nedIndex = - 1, count = 0, totalNed = 0;\n\n    for (int i = 0;\n\n    i < s.X1 (); i ++) {\n\n        if (i > ned.X1 () - 1) nedIndex ++;\n\n        else nedIndex = i;\n\n        if (s.charAt (i) == ned.charAt (nedIndex)) count ++;\n\n        else {\n\n            nedIndex = 0;\n\n            count = 0;\n\n            if (s.charAt (i) == ned.charAt (nedIndex)) count ++;\n\n            else nedIndex = - 1;\n\n        }\n\n        if (count == ned.X1 ()) {\n\n            nedIndex = - 1;\n\n            count = 0;\n\n            totalNed ++;\n\n            System.out.println (totalNed + \" needle found at index=\" + (i - (ned.X1 () - 1)));\n\n        }\n\n    }\n\n    System.out.print (\"Total Ned=\" + totalNed);\n\n}\n"}
{"idx": 30802, "func": "public static void main (X1 [] args) {\n\n    X1 needle = \"ABC\";\n\n    X1 haystack = \"ABCDSGDABCSAGAABCCCCAAABAABC\";\n\n    int numberOfOccurences = 0;\n\n    int index = haystack.indexOf (needle);\n\n    while (index != - 1) {\n\n        numberOfOccurences ++;\n\n        haystack = haystack.substring (index + needle.length ());\n\n        index = haystack.indexOf (needle);\n\n    }\n\n    System.out.println (\"\" + numberOfOccurences);\n\n}\n"}
{"idx": 30901, "func": "public static void main (String [] args) {\n\n    int [] array = {1, 2, 3, 3, 2, 2, 4, 4, 5, 4};\n\n    int count = 0;\n\n    int maxCount = 10;\n\n    int [] results = new int [array.length];\n\n    int k = 0;\n\n    for (int X1 = 0;\n\n    X1 < results.length; X1 ++) {\n\n        results [X1] = - 1;\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < array.length; X1 ++) {\n\n        for (int j = 0;\n\n        j < array.length; j ++) {\n\n            if (array [j] == array [X1]) {\n\n                count ++;\n\n            }\n\n        }\n\n        if (count <= maxCount) {\n\n            maxCount = count;\n\n            results [k ++] = array [X1];\n\n        }\n\n        count = 0;\n\n    }\n\n    for (int X1 : results) {\n\n        if (X1 != - 1) {\n\n            System.out.println (\"Element: \" + X1 + \", Number of occurences: \" + maxCount);\n\n        }\n\n    }\n\n}\n"}
{"idx": 30902, "func": "public static void main (String [] args) {\n\n    int [] array = {1, 2, 3, 3, 2, 2, 4, 4, 5, 4};\n\n    Map < Integer, Integer > counts = new HashMap < > ();\n\n    for (Integer X1 : array) {\n\n        if (counts.get (X1) == null) {\n\n            counts.put (X1, 1);\n\n        } else {\n\n            counts.put (X1, counts.get (X1) + 1);\n\n        }\n\n    }\n\n    List < Integer > cs = new ArrayList < Integer > (counts.values ());\n\n    Collections.sort (cs);\n\n    int minVal = cs.get (0);\n\n    List < Integer > minElements = new ArrayList < > ();\n\n    for (Entry < Integer, Integer > entry : counts.entrySet ()) {\n\n        if (entry.getValue () == minVal) {\n\n            minElements.add (entry.getKey ());\n\n        }\n\n    }\n\n    for (Integer X1 : minElements) {\n\n        System.out.println (\"Element: \" + X1 + \" Number of occurences: \" + minVal);\n\n    }\n\n}\n"}
{"idx": 31001, "func": "public static void CountbyChar (String s) {\n\n    int [] arr = new int [256];\n\n    for (char X1 : s.toCharArray ()) {\n\n        if (X1 < 256) {\n\n            arr [X1] ++;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i != 256; i ++) {\n\n        if (arr [i] != 0) {\n\n            System.out.print ((char) i);\n\n            System.out.print (\" : \");\n\n            System.out.println (arr [i]);\n\n        }\n\n    }\n\n}\n"}
{"idx": 31002, "func": "public static void CountbyChar (String s) {\n\n    HashMap < Character, Integer > letterCountMap = new HashMap < Character, Integer > ();\n\n    char [] c = s.toCharArray ();\n\n    for (int X1 = 0;\n\n    X1 < c.length; X1 ++) {\n\n        Integer count = 0;\n\n        if (letterCountMap.containsKey (c [X1])) {\n\n            count = letterCountMap.get (c [X1]) + 1;\n\n        } else {\n\n            count = 1;\n\n        }\n\n        letterCountMap.put (c [X1], count);\n\n    }\n\n    for (Map.Entry < String, String > entry : letterCountMap.entrySet ()) {\n\n        System.out.println (entry.getValue () + \"( for\" + entry.getKey () + \" )\");\n\n    }\n\n}\n"}
{"idx": 3101, "func": "public static void main (String [] args) throws InterruptedException {\n\n    String [] arrayElements = {\"value1\", \"value2\", \"value3\", \"value4\"};\n\n    long start = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < arrayElements.length; i ++) {\n\n        final String value = arrayElements [i];\n\n        new X1.util.Timer ().schedule (new X1.util.TimerTask () {\n\n            public void run () {\n\n                System.out.println (value);\n\n            }}\n\n        , new Date (start));\n\n        start += 5000;\n\n    }\n\n}\n"}
{"idx": 3102, "func": "public static void main (String [] args) {\n\n    final Timer X1 = new Timer ();\n\n    X1.scheduleAtFixedRate (new TimerTask () {\n\n        private int index = 0;\n\n        public void run () {\n\n            System.out.println (ARRAY_ELEMENTS [index]);\n\n            index ++;\n\n            if (index >= ARRAY_ELEMENTS.length) {\n\n                X1.cancel ();\n\n            }\n\n        }}\n\n    , 5000L, 5000L);\n\n}\n"}
{"idx": 31101, "func": "public static void print (Object...items) {\n\n    for (Object item : items) {\n\n        if (item.getClass ().isArray ()) {\n\n            Object [] objs = primitiveArrayFrom (item);\n\n            if (objs == null) {\n\n                objs = (Object []) item;\n\n            }\n\n            for (Object X1 : objs) {\n\n                System.out.println (X1);\n\n            }\n\n        } else {\n\n            System.out.println (item);\n\n        }\n\n    }\n\n}\n"}
{"idx": 31102, "func": "public static void print (Object...toPrint) {\n\n    for (Object item : toPrint) {\n\n        if (item.getClass () == int [].class) {\n\n            System.out.println (Arrays.X1 ((int []) item));\n\n        } else if (item.getClass () == double [].class) {\n\n            System.out.println (Arrays.X1 ((double []) item));\n\n        } else if (item instanceof Object []) {\n\n            System.out.println (Arrays.X1 ((Object []) item));\n\n        } else {\n\n            System.out.println (item);\n\n        }\n\n    }\n\n}\n"}
{"idx": 31201, "func": "public static void main (String [] args) {\n\n    final Map < Integer, Integer > map = new HashMap < > ();\n\n    final CountDownLatch X1 = new CountDownLatch (1);\n\n    final CountDownLatch writeLatch = new CountDownLatch (1);\n\n    for (int i = 0;\n\n    i < 100; i ++) {\n\n        map.put (i, i);\n\n    }\n\n    new Thread (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            try {\n\n                for (Map.Entry < Integer, Integer > entry : map.entrySet ()) {\n\n                    if (entry.getKey ().equals (Integer.valueOf (10))) {\n\n                        try {\n\n                            writeLatch.countDown ();\n\n                            X1.await ();\n\n                        } catch (InterruptedException e) {\n\n                            Thread.currentThread ().interrupt ();\n\n                        }\n\n                    }\n\n                }\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        }}\n\n    ).start ();\n\n    new Thread (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            try {\n\n                writeLatch.await ();\n\n                map.put (150, 150);\n\n                X1.countDown ();\n\n            } catch (InterruptedException e) {\n\n                Thread.currentThread ().interrupt ();\n\n            }\n\n        }}\n\n    ).start ();\n\n}\n"}
{"idx": 31301, "func": "public void run () {\n\n    try {\n\n        for (Map.Entry < Integer, Integer > entry : map.entrySet ()) {\n\n            if (entry.getKey ().equals (Integer.valueOf (10))) {\n\n                try {\n\n                    writeLatch.countDown ();\n\n                    readLatch.await ();\n\n                } catch (InterruptedException X1) {\n\n                    Thread.currentThread ().interrupt ();\n\n                }\n\n            }\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 31302, "func": "public void run () {\n\n    for (int X1 = 0;\n\n    ; X1 ++) {\n\n        if (X1 % 1000 == 0) {\n\n            System.out.printf (\"get: %d\\n\", X1);\n\n        }\n\n        Map < K, String > m2 = new HashMap < > (map);\n\n    }\n\n}\n"}
{"idx": 31401, "func": "public void run () {\n\n    for (int X1 = 0;\n\n    ; X1 ++) {\n\n        if (X1 % 1000 == 0) {\n\n            System.out.printf (\"get: %d\\n\", X1);\n\n        }\n\n        Map < K, String > m2 = new HashMap < > (map);\n\n    }\n\n}\n"}
{"idx": 31402, "func": "public void run () {\n\n    for (int X1 = 0;\n\n    ; X1 ++) {\n\n        if (X1 % 1000 == 0) {\n\n            System.out.printf (\"get: %d\\n\", X1);\n\n        }\n\n        Map < K, String > m2 = new HashMap < > (map);\n\n    }\n\n}\n"}
{"idx": 31501, "func": "public static void main (String [] args) {\n\n    try {\n\n        String input = \"\";\n\n        char X1 = (char) System.in.read ();\n\n        while (X1 != '\\n') {\n\n            input += X1;\n\n            X1 = (char) System.in.read ();\n\n        }\n\n        System.out.println (input);\n\n    } catch (Exception e) {\n\n        System.out.println (e);\n\n    }\n\n}\n"}
{"idx": 31502, "func": "public static void main (String [] args) {\n\n    Scanner kb = new Scanner (System.in);\n\n    String name;\n\n    int age;\n\n    char bloodGroup;\n\n    float height;\n\n    System.X1.println (\"Enter Your Name\");\n\n    name = kb.nextLine ();\n\n    System.X1.println (\"Enter Your Age\");\n\n    age = kb.nextInt ();\n\n    System.X1.println (\"Enter Your BloodGroup : A/B/O only\");\n\n    bloodGroup = kb.next ().charAt (0);\n\n    System.X1.println (\"Enter Your Height in Meters\");\n\n    height = kb.nextFloat ();\n\n    kb.close ();\n\n    System.X1.println (\"Name : \" + name);\n\n    System.X1.println (\"Age : \" + age);\n\n    System.X1.println (\"BloodGroup : \" + bloodGroup);\n\n    System.X1.println (\"Height : \" + height + \" m\");\n\n}\n"}
{"idx": 31601, "func": "public static boolean deleteRecursive (File path) throws FileNotFoundException {\n\n    if (! path.exists ()) throw new FileNotFoundException (path.getAbsolutePath ());\n\n    boolean ret = true;\n\n    if (path.isDirectory ()) {\n\n        for (File X1 : path.listFiles ()) {\n\n            ret = ret && deleteRecursive (X1);\n\n        }\n\n    }\n\n    return ret && path.delete ();\n\n}\n"}
{"idx": 31602, "func": "public static void deleteRecursive (File path) {\n\n    path.listFiles (new FileFilter () {\n\n        @Override\n\n        public boolean accept (File pathname) {\n\n            if (pathname.isDirectory ()) {\n\n                pathname.listFiles (this);\n\n                pathname.X1 ();\n\n            } else {\n\n                pathname.X1 ();\n\n            }\n\n            return false;\n\n        }}\n\n    );\n\n    path.X1 ();\n\n}\n"}
{"idx": 31701, "func": "public static boolean deleteRecursive (File path) throws FileNotFoundException {\n\n    if (! path.exists ()) throw new FileNotFoundException (path.getAbsolutePath ());\n\n    boolean ret = true;\n\n    if (path.isDirectory ()) {\n\n        for (File X1 : path.listFiles ()) {\n\n            ret = ret && deleteRecursive (X1);\n\n        }\n\n    }\n\n    return ret && path.delete ();\n\n}\n"}
{"idx": 31702, "func": "public void deleteRecursive (File path) {\n\n    File [] c = path.listFiles ();\n\n    System.out.println (\"Cleaning out folder:\" + path.toString ());\n\n    for (File X1 : c) {\n\n        if (X1.isDirectory ()) {\n\n            System.out.println (\"Deleting file:\" + X1.toString ());\n\n            deleteRecursive (X1);\n\n            X1.delete ();\n\n        } else {\n\n            X1.delete ();\n\n        }\n\n    }\n\n    path.delete ();\n\n}\n"}
{"idx": 31801, "func": "private void deleteRecursive (File X1) throws Exception {\n\n    try {\n\n        if (X1.isDirectory ()) {\n\n            for (File c : X1.listFiles ()) {\n\n                deleteRecursive (c);\n\n            }\n\n        }\n\n        if (! X1.delete ()) {\n\n            throw new Exception (\"Delete command returned false for file: \" + X1);\n\n        }\n\n    } catch (Exception e) {\n\n        throw new Exception (\"Failed to delete the folder: \" + X1, e);\n\n    }\n\n}\n"}
{"idx": 31802, "func": "public static void deleteRecursive (File path) {\n\n    path.listFiles (new FileFilter () {\n\n        @Override\n\n        public boolean accept (File pathname) {\n\n            if (pathname.isDirectory ()) {\n\n                pathname.listFiles (this);\n\n                pathname.X1 ();\n\n            } else {\n\n                pathname.X1 ();\n\n            }\n\n            return false;\n\n        }}\n\n    );\n\n    path.X1 ();\n\n}\n"}
{"idx": 31901, "func": "private void deleteRecursive (File X1) throws Exception {\n\n    try {\n\n        if (X1.isDirectory ()) {\n\n            for (File c : X1.listFiles ()) {\n\n                deleteRecursive (c);\n\n            }\n\n        }\n\n        if (! X1.delete ()) {\n\n            throw new Exception (\"Delete command returned false for file: \" + X1);\n\n        }\n\n    } catch (Exception e) {\n\n        throw new Exception (\"Failed to delete the folder: \" + X1, e);\n\n    }\n\n}\n"}
{"idx": 31902, "func": "public void deleteRecursive (X1 path) {\n\n    X1 [] c = path.listFiles ();\n\n    System.out.println (\"Cleaning out folder:\" + path.toString ());\n\n    for (X1 file : c) {\n\n        if (file.isDirectory ()) {\n\n            System.out.println (\"Deleting file:\" + file.toString ());\n\n            deleteRecursive (file);\n\n            file.delete ();\n\n        } else {\n\n            file.delete ();\n\n        }\n\n    }\n\n    path.delete ();\n\n}\n"}
{"idx": 32001, "func": "public static void deleteRecursive (File path) {\n\n    path.listFiles (new FileFilter () {\n\n        @Override\n\n        public boolean accept (File pathname) {\n\n            if (pathname.isDirectory ()) {\n\n                pathname.listFiles (this);\n\n                pathname.X1 ();\n\n            } else {\n\n                pathname.X1 ();\n\n            }\n\n            return false;\n\n        }}\n\n    );\n\n    path.X1 ();\n\n}\n"}
{"idx": 32002, "func": "public void deleteRecursive (File path) {\n\n    File [] c = path.listFiles ();\n\n    System.out.println (\"Cleaning out folder:\" + path.toString ());\n\n    for (File file : c) {\n\n        if (file.isDirectory ()) {\n\n            System.out.println (\"Deleting file:\" + file.toString ());\n\n            deleteRecursive (file);\n\n            file.X1 ();\n\n        } else {\n\n            file.X1 ();\n\n        }\n\n    }\n\n    path.X1 ();\n\n}\n"}
{"idx": 3201, "func": "public static void main (String [] args) {\n\n    String str = \"123\";\n\n    byte barr [] = str.getBytes ();\n\n    System.out.println (Arrays.toString (barr));\n\n    int result = 0;\n\n    for (int X1 = 0;\n\n    X1 < barr.length; X1 ++) {\n\n        int ii = barr [X1];\n\n        char a = (char) ii;\n\n        int no = Character.getNumericValue (a);\n\n        result = result * 10 + no;\n\n        System.out.println (result);\n\n    }\n\n    System.out.println (\"result:\" + result);\n\n}\n"}
{"idx": 3202, "func": "public static void main (String args []) {\n\n    String inputString;\n\n    Scanner X1 = new Scanner (System.in);\n\n    inputString = X1.nextLine ();\n\n    if (! inputString.matches (\"([+-]?([0-9]*[.])?[0-9]+)\")) {\n\n        System.out.println (\"Not a Number\");\n\n    } else {\n\n        Double result2 = getNumber (inputString);\n\n        System.out.println (\"result = \" + result2);\n\n    }\n\n}\n"}
{"idx": 32101, "func": "public V get (K1 X1, K2 key2) {\n\n    if (! mapOfMap.containsKey (X1)) {\n\n        X1 = null;\n\n    }\n\n    if (! mapOfMap.get (X1).containsKey (key2)) {\n\n        key2 = null;\n\n    }\n\n    return mapOfMap.get (X1).get (key2);\n\n}\n"}
{"idx": 32102, "func": "public X1 get (K...keys) {\n\n    if (keys == null) {\n\n        return value;\n\n    }\n\n    if (expectedNumberOfKeys == - 1) {\n\n        return null;\n\n    }\n\n    if (expectedNumberOfKeys == 0) {\n\n        return value;\n\n    }\n\n    if (expectedNumberOfKeys != keys.length) {\n\n        throw new IllegalArgumentException (\"Expecting \" + expectedNumberOfKeys + \" keys.  Was \" + keys.length);\n\n    }\n\n    Map < K, Map > currentMap = topMap;\n\n    for (int i = 0;\n\n    i < keys.length - 1; i ++) {\n\n        currentMap = (Map) getDefault (currentMap, keys [i]);\n\n    }\n\n    X1 result = (X1) getDefault (currentMap, keys [keys.length - 1]);\n\n    return result;\n\n}\n"}
{"idx": 32201, "func": "public static int getHours () {\n\n    while (true) {\n\n        if (console.hasNextInt ()) {\n\n            X1.out.print (\"**hours input accepted**\");\n\n            return console.nextInt ();\n\n        }\n\n        console.nextLine ();\n\n        X1.out.print (\", please re-enter the hours again:\");\n\n    }\n\n}\n"}
{"idx": 32202, "func": "public static int getHours () {\n\n    int hours = 0;\n\n    boolean hoursNotOk = true;\n\n    do {\n\n        try {\n\n            System.out.X1 (\"Here\");\n\n            hours = console.nextInt ();\n\n            hoursNotOk = false;\n\n        } catch (Exception e) {\n\n            e.printStackTrace ();\n\n            console.nextLine ();\n\n        } finally {\n\n            if (hoursNotOk) {\n\n                System.out.X1 (\", please re-enter the hours again:\");\n\n            } else {\n\n                System.out.X1 (\"**hours input accepted**\");\n\n            }\n\n        }\n\n    } while (hoursNotOk);\n\n    return hours;\n\n}\n"}
{"idx": 32301, "func": "public static void main (X1 [] args) {\n\n    X1 [] [] arr = new X1 [] [] {new X1 [] {\"continents\", \"abc\"}, new X1 [] {\"name\", \"test\"}, new X1 [] {\"something\", \"test something\"},};\n\n    int indexOfNameArray = - 1;\n\n    for (int i = 0;\n\n    i < arr.length; i ++) {\n\n        if (indexOfNameArray > - 1 && indexOfNameArray < arr.length - 1) {\n\n            X1 [] temp = arr [i];\n\n            arr [i] = arr [i - 1];\n\n            arr [i - 1] = temp;\n\n            indexOfNameArray = i;\n\n        } else if (arr [i] [0].equals (\"name\")) {\n\n            indexOfNameArray = i;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < arr.length; i ++) {\n\n        for (int j = 0;\n\n        j < arr [i].length; j ++) {\n\n            System.out.print (arr [i] [j] + \", \");\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 32302, "func": "public static void main (String [] args) {\n\n    Scanner sc = new Scanner (System.in);\n\n    String [] [] X1 = new String [7] [];\n\n    X1 [0] = new String [] {\"continents\", \"Asia\", \"Europe\", \"Africa\", \"Australia\", \"South America\", \"North America\"};\n\n    X1 [1] = new String [] {\"profession\", \"teacher\", \"doctor\", \"lawyer\"};\n\n    X1 [2] = new String [] {\"brand\", \"apple\", \"samsung\"};\n\n    X1 [3] = new String [] {\"name\", \"lisa\", \"peter\", \"sam\", \"jack\"};\n\n    X1 [4] = new String [] {\"profession\", \"engineer\", \"Professor\", \"Dentist\", \"Driver\"};\n\n    X1 [5] = new String [] {\"sex\", \"value\", \"male\", \"female\"};\n\n    X1 [6] = new String [] {\"exp\", \"value\", \"1\", \"2\", \"3\", \"4\"};\n\n    int index = sc.nextInt ();\n\n    String [] tempReference = X1 [index - 1];\n\n    for (int i = index - 1;\n\n    i < X1.length - 1; i ++) {\n\n        X1 [i] = X1 [i + 1];\n\n    }\n\n    X1 [X1.length - 1] = tempReference;\n\n    for (String [] tempArray : X1) {\n\n        for (String s : tempArray) {\n\n            System.out.print (s + \" \");\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 32401, "func": "public static void main (String [] args) {\n\n    Scanner keyboard = new Scanner (System.in);\n\n    System.out.X1 (\"Number of days in the period: \");\n\n    numberofDays = keyboard.nextInt ();\n\n    System.out.X1 (\"Share points on the first day: \");\n\n    sharePoints = keyboard.nextInt ();\n\n    while (numberofDays < 10 || numberofDays > 20) {\n\n        System.out.println (\"The number of days doesnt meet the required criteria, enter it again\");\n\n        System.out.X1 (\"Number of days in the period: \");\n\n        numberofDays = keyboard.nextInt ();\n\n    }\n\n    DisplayStock ();\n\n}\n"}
{"idx": 32402, "func": "public static void main (String [] args) {\n\n    int numberofDays;\n\n    int sharePoints;\n\n    Scanner X1 = new Scanner (System.in);\n\n    System.out.print (\"Number of days in the period: \");\n\n    numberofDays = X1.nextInt ();\n\n    System.out.print (\"Share points on the first day: \");\n\n    sharePoints = X1.nextInt ();\n\n    numberofDays = validator (numberofDays, X1);\n\n    outPutTablePrinter (numberofDays, sharePoints);\n\n}\n"}
{"idx": 32501, "func": "public int read (char [] X1) {\n\n    char [] temp = new char [X1.length];\n\n    int charsRead = reader.read (temp);\n\n    int index = - 1;\n\n    if (! (charsRead == - 1)) {\n\n        for (char c : temp) {\n\n            if (! blacklist.contains (c)) {\n\n                X1 [index] = c;\n\n                index ++;\n\n            }\n\n        }\n\n    }\n\n    return index;\n\n}\n"}
{"idx": 32502, "func": "public int read (char [] cbuf, int X1, int len) throws IOException {\n\n    int read = super.read (cbuf, X1, len);\n\n    if (read == - 1) {\n\n        return - 1;\n\n    }\n\n    int pos = X1 - 1;\n\n    for (int readPos = X1;\n\n    readPos < X1 + read; readPos ++) {\n\n        if (read == '@') {\n\n            continue;\n\n        } else {\n\n            pos ++;\n\n        }\n\n        if (pos < readPos) {\n\n            cbuf [pos] = cbuf [readPos];\n\n        }\n\n    }\n\n    return pos - X1 + 1;\n\n}\n"}
{"idx": 32601, "func": "public void run () {\n\n    count ++;\n\n    if (Thread.currentThread ().X1 ().compareTo (\"one\") == 0) {\n\n        synchronized (a.class) {\n\n            try {\n\n                for (int i = 0;\n\n                i < 5; i ++) {\n\n                    while (time.equals (\"Tock\")) {\n\n                        a.class.wait ();\n\n                    }\n\n                    System.out.println (\"Now running thread \" + Thread.currentThread ().X1 () + \" with count \" + count);\n\n                    time = \"Tock\";\n\n                    System.out.println (time);\n\n                    a.class.notify ();\n\n                }\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        }\n\n    } else if (Thread.currentThread ().X1 ().compareTo (\"two\") == 0) {\n\n        synchronized (a.class) {\n\n            try {\n\n                for (int j = 0;\n\n                j < 5; j ++) {\n\n                    while (time.equals (\"Tick\")) {\n\n                        a.class.wait ();\n\n                    }\n\n                    System.out.println (\"Now running thread \" + Thread.currentThread ().X1 () + \" with count \" + count);\n\n                    time = \"Tick\";\n\n                    System.out.println (time);\n\n                    a.class.notify ();\n\n                }\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 32602, "func": "public void run () {\n\n    try {\n\n        synchronized (lock) {\n\n            for (int i = 0;\n\n            i < 5; i ++) {\n\n                while (X1 != token % N) lock.wait ();\n\n                System.out.println (X1 + \" \" + i);\n\n                token ++;\n\n                lock.notifyAll ();\n\n            }\n\n        }\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 32701, "func": "public void mouseMoved (MouseEvent e) {\n\n    int x = width / 2;\n\n    int X1 = height / 2;\n\n    Point mousePoint = e.getPoint ();\n\n    int deltaX = mousePoint.x - x;\n\n    int deltaY = mousePoint.X1 - X1;\n\n    polyrot = - Math.atan2 (deltaX, deltaY);\n\n    polyrot = Math.toDegrees (polyrot) + 180;\n\n    repaint ();\n\n}\n"}
{"idx": 32702, "func": "public void mouseMoved (MouseEvent e) {\n\n    X1 = getX ();\n\n    if (X1 < 0) {\n\n        polyrot --;\n\n    } else if (X1 > 0) {\n\n        polyrot ++;\n\n    }\n\n    repaint ();\n\n    break;\n\n}\n"}
{"idx": 32801, "func": "public static void close (Connection connection, Statement statement, ResultSet rs) {\n\n    if (rs != null) {\n\n        try {\n\n            rs.close ();\n\n        } catch (Exception e) {\n\n            _logger.X1 (e.toString ());\n\n        }\n\n    }\n\n    if (statement != null) {\n\n        try {\n\n            statement.close ();\n\n        } catch (Exception e) {\n\n            _logger.X1 (e.toString ());\n\n        }\n\n    }\n\n    if (connection != null) {\n\n        try {\n\n            connection.close ();\n\n        } catch (Exception e) {\n\n            _logger.X1 (e.toString ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 32802, "func": "public static void X1 (Statement...statements) {\n\n    for (Statement stmt : statements) {\n\n        try {\n\n            if (stmt != null) stmt.X1 ();\n\n        } catch (SQLException se) {\n\n        }\n\n    }\n\n}\n"}
{"idx": 32901, "func": "public static void main (String [] args) {\n\n    String string = \"check duplicate charcters in string\";\n\n    string = string.toLowerCase ();\n\n    char [] charAr = string.toCharArray ();\n\n    Arrays.sort (charAr);\n\n    for (int i = 1;\n\n    i < charAr.length;) {\n\n        int X1 = recursiveMethod (charAr, i, 1);\n\n        if (X1 > 1) {\n\n            System.out.println (\"'\" + charAr [i] + \"' comes \" + X1 + \" times\");\n\n            i = i + X1;\n\n        } else i ++;\n\n    }\n\n}\n"}
{"idx": 32902, "func": "public static void main (X1 [] args) {\n\n    X1 str = \"abcdabghplhhnfl\".toLowerCase ();\n\n    Integer [] ar = new Integer [26];\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int j = str.charAt (i) - 'a';\n\n        if (ar [j] == null) {\n\n            ar [j] = 1;\n\n        } else {\n\n            ar [j] += 1;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < ar.length; i ++) {\n\n        if (ar [i] != null && ar [i] > 1) {\n\n            char c = (char) (97 + i);\n\n            System.out.println (\"'\" + c + \"' comes \" + ar [i] + \" times.\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 33001, "func": "public static void main (X1 [] args) {\n\n    X1 string = \"check duplicate charcters in string\";\n\n    string = string.toLowerCase ();\n\n    char [] charAr = string.toCharArray ();\n\n    Arrays.sort (charAr);\n\n    for (int i = 1;\n\n    i < charAr.length;) {\n\n        int count = recursiveMethod (charAr, i, 1);\n\n        if (count > 1) {\n\n            System.out.println (\"'\" + charAr [i] + \"' comes \" + count + \" times\");\n\n            i = i + count;\n\n        } else i ++;\n\n    }\n\n}\n"}
{"idx": 33002, "func": "public static void main (String [] args) throws IOException {\n\n    String ch;\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Enter the Statement:\");\n\n    ch = br.readLine ();\n\n    int count = 0, len = 0;\n\n    do {\n\n        try {\n\n            char X1 [] = ch.toCharArray ();\n\n            len = X1.length;\n\n            count = 0;\n\n            for (int j = 0;\n\n            j < len; j ++) {\n\n                if ((X1 [0] == X1 [j]) && ((X1 [0] >= 65 && X1 [0] <= 91) || (X1 [0] >= 97 && X1 [0] <= 123))) count ++;\n\n            }\n\n            if (count != 0) System.out.println (X1 [0] + \" \" + count + \" Times\");\n\n            ch = ch.replace (\"\" + X1 [0], \"\");\n\n        } catch (Exception ex) {\n\n        }\n\n    } while (len != 1);\n\n}\n"}
{"idx": 3301, "func": "public void printTree (OutputStreamWriter X1) throws IOException {\n\n    if (right != null) {\n\n        right.printTree (X1, true, \"\");\n\n    }\n\n    printNodeValue (X1);\n\n    if (left != null) {\n\n        left.printTree (X1, false, \"\");\n\n    }\n\n}\n"}
{"idx": 3302, "func": "private void printTree (OutputStreamWriter out, boolean isRight, String indent) throws IOException {\n\n    if (X1 != null) {\n\n        X1.printTree (out, true, indent + (isRight ? \"        \" : \" |      \"));\n\n    }\n\n    out.write (indent);\n\n    if (isRight) {\n\n        out.write (\" /\");\n\n    } else {\n\n        out.write (\" \\\\\");\n\n    }\n\n    out.write (\"----- \");\n\n    printNodeValue (out);\n\n    if (left != null) {\n\n        left.printTree (out, false, indent + (isRight ? \" |      \" : \"        \"));\n\n    }\n\n}\n"}
{"idx": 33101, "func": "public static void main (X1 [] args) {\n\n    X1 string = \"check duplicate charcters in string\";\n\n    string = string.toLowerCase ();\n\n    char [] charAr = string.toCharArray ();\n\n    Arrays.sort (charAr);\n\n    for (int i = 1;\n\n    i < charAr.length;) {\n\n        int count = recursiveMethod (charAr, i, 1);\n\n        if (count > 1) {\n\n            System.out.println (\"'\" + charAr [i] + \"' comes \" + count + \" times\");\n\n            i = i + count;\n\n        } else i ++;\n\n    }\n\n}\n"}
{"idx": 33102, "func": "public static void main (String [] args) {\n\n    String name = \"AnuvratAnuvra\";\n\n    char [] arr = name.toCharArray ();\n\n    HashMap < Character, Integer > X1 = new HashMap < Character, Integer > ();\n\n    for (char val : arr) {\n\n        X1.put (val, X1.containsKey (val) ? X1.get (val) + 1 : 1);\n\n    }\n\n    for (Entry < Character, Integer > entry : X1.entrySet ()) {\n\n        if (entry.getValue () > 1) {\n\n            Character key = entry.getKey ();\n\n            Object value = entry.getValue ();\n\n            System.out.println (key + \":\" + value);\n\n        }\n\n    }\n\n}\n"}
{"idx": 33201, "func": "public static void main (String [] args) {\n\n    String string = \"check duplicate charcters in string\";\n\n    string = string.toLowerCase ();\n\n    char [] charAr = string.toCharArray ();\n\n    Arrays.sort (charAr);\n\n    for (int i = 1;\n\n    i < charAr.length;) {\n\n        int X1 = recursiveMethod (charAr, i, 1);\n\n        if (X1 > 1) {\n\n            System.out.println (\"'\" + charAr [i] + \"' comes \" + X1 + \" times\");\n\n            i = i + X1;\n\n        } else i ++;\n\n    }\n\n}\n"}
{"idx": 33202, "func": "public static void main (String [] args) {\n\n    String test = \"The quick brown fox jumped over the lazy dog.\";\n\n    int countA = 0, X1 = 0, countSpace = 0, countDot = 0;\n\n    for (int i = 0;\n\n    i < test.length (); i ++) {\n\n        switch (test.charAt (i)) {\n\n            case 'a' :\n\n            case 'A' :\n\n                countA ++;\n\n                break;\n\n            case 'o' :\n\n            case 'O' :\n\n                X1 ++;\n\n                break;\n\n            case ' ' :\n\n                countSpace ++;\n\n                break;\n\n            case '.' :\n\n                countDot ++;\n\n                break;\n\n        }\n\n    }\n\n    System.out.printf (\"%s%d%n%s%d%n%s%d%n%s%d\", \"A: \", countA, \"O: \", X1, \"Space: \", countSpace, \"Dot: \", countDot);\n\n}\n"}
{"idx": 33301, "func": "public static void main (String [] args) {\n\n    String X1 = \"check duplicate charcters in string\";\n\n    X1 = X1.toLowerCase ();\n\n    char [] charAr = X1.toCharArray ();\n\n    Arrays.sort (charAr);\n\n    for (int i = 1;\n\n    i < charAr.length;) {\n\n        int count = recursiveMethod (charAr, i, 1);\n\n        if (count > 1) {\n\n            System.out.println (\"'\" + charAr [i] + \"' comes \" + count + \" times\");\n\n            i = i + count;\n\n        } else i ++;\n\n    }\n\n}\n"}
{"idx": 33302, "func": "public static void main (String...a) {\n\n    System.X1.print (\"Enter the String\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String st = sc.nextLine ();\n\n    int [] ar = new int [256];\n\n    for (int i = 0;\n\n    i < st.length (); i ++) {\n\n        ar [st.charAt (i)] = ar [st.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        char ch = (char) i;\n\n        if (ar [i] > 0) {\n\n            if (ar [i] == 1) {\n\n                System.X1.print (ch);\n\n            } else {\n\n                System.X1.print (ch + \"\" + ar [i]);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 33401, "func": "public static void main (String [] args) {\n\n    String str = \"abcdabghplhhnfl\".toLowerCase ();\n\n    Integer [] X1 = new Integer [26];\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int j = str.charAt (i) - 'a';\n\n        if (X1 [j] == null) {\n\n            X1 [j] = 1;\n\n        } else {\n\n            X1 [j] += 1;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] != null && X1 [i] > 1) {\n\n            char c = (char) (97 + i);\n\n            System.out.println (\"'\" + c + \"' comes \" + X1 [i] + \" times.\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 33402, "func": "public static void main (String [] args) throws IOException {\n\n    String X1;\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Enter the Statement:\");\n\n    X1 = br.readLine ();\n\n    int count = 0, len = 0;\n\n    do {\n\n        try {\n\n            char name [] = X1.toCharArray ();\n\n            len = name.length;\n\n            count = 0;\n\n            for (int j = 0;\n\n            j < len; j ++) {\n\n                if ((name [0] == name [j]) && ((name [0] >= 65 && name [0] <= 91) || (name [0] >= 97 && name [0] <= 123))) count ++;\n\n            }\n\n            if (count != 0) System.out.println (name [0] + \" \" + count + \" Times\");\n\n            X1 = X1.replace (\"\" + name [0], \"\");\n\n        } catch (Exception ex) {\n\n        }\n\n    } while (len != 1);\n\n}\n"}
{"idx": 33501, "func": "public static void main (String [] args) {\n\n    String str = \"abcdabghplhhnfl\".toLowerCase ();\n\n    X1 [] ar = new X1 [26];\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int j = str.charAt (i) - 'a';\n\n        if (ar [j] == null) {\n\n            ar [j] = 1;\n\n        } else {\n\n            ar [j] += 1;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < ar.length; i ++) {\n\n        if (ar [i] != null && ar [i] > 1) {\n\n            char c = (char) (97 + i);\n\n            System.out.println (\"'\" + c + \"' comes \" + ar [i] + \" times.\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 33502, "func": "public static void main (String [] args) {\n\n    X1 < Character, Integer > hm = new X1 < Character, Integer > ();\n\n    System.out.println (\"Enter an String:\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String s1 = sc.nextLine ();\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        if (! hm.containsKey (s1.charAt (i))) {\n\n            hm.put (s1.charAt (i), (Integer) 1);\n\n        } else {\n\n            hm.put (s1.charAt (i), hm.get (s1.charAt (i)) + 1);\n\n        }\n\n    }\n\n    System.out.println (\"The Charecters are:\" + hm);\n\n}\n"}
{"idx": 33601, "func": "public static void main (String [] args) {\n\n    String str = \"abcdabghplhhnfl\".toLowerCase ();\n\n    Integer [] X1 = new Integer [26];\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int j = str.charAt (i) - 'a';\n\n        if (X1 [j] == null) {\n\n            X1 [j] = 1;\n\n        } else {\n\n            X1 [j] += 1;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] != null && X1 [i] > 1) {\n\n            char c = (char) (97 + i);\n\n            System.out.println (\"'\" + c + \"' comes \" + X1 [i] + \" times.\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 33602, "func": "public static void main (String [] args) {\n\n    String name = \"AnuvratAnuvra\";\n\n    char [] arr = name.toCharArray ();\n\n    HashMap < Character, Integer > map = new HashMap < Character, Integer > ();\n\n    for (char X1 : arr) {\n\n        map.put (X1, map.containsKey (X1) ? map.get (X1) + 1 : 1);\n\n    }\n\n    for (Entry < Character, Integer > entry : map.entrySet ()) {\n\n        if (entry.getValue () > 1) {\n\n            Character key = entry.getKey ();\n\n            Object value = entry.getValue ();\n\n            System.out.println (key + \":\" + value);\n\n        }\n\n    }\n\n}\n"}
{"idx": 33701, "func": "public static void main (String [] args) {\n\n    String X1 = \"abcdabghplhhnfl\".toLowerCase ();\n\n    Integer [] ar = new Integer [26];\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        int j = X1.charAt (i) - 'a';\n\n        if (ar [j] == null) {\n\n            ar [j] = 1;\n\n        } else {\n\n            ar [j] += 1;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < ar.length; i ++) {\n\n        if (ar [i] != null && ar [i] > 1) {\n\n            char c = (char) (97 + i);\n\n            System.out.println (\"'\" + c + \"' comes \" + ar [i] + \" times.\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 33702, "func": "public static void main (String [] args) {\n\n    String test = \"The quick brown fox jumped over the lazy dog.\";\n\n    int countA = 0, countO = 0, X1 = 0, countDot = 0;\n\n    for (int i = 0;\n\n    i < test.length (); i ++) {\n\n        switch (test.charAt (i)) {\n\n            case 'a' :\n\n            case 'A' :\n\n                countA ++;\n\n                break;\n\n            case 'o' :\n\n            case 'O' :\n\n                countO ++;\n\n                break;\n\n            case ' ' :\n\n                X1 ++;\n\n                break;\n\n            case '.' :\n\n                countDot ++;\n\n                break;\n\n        }\n\n    }\n\n    System.out.printf (\"%s%d%n%s%d%n%s%d%n%s%d\", \"A: \", countA, \"O: \", countO, \"Space: \", X1, \"Dot: \", countDot);\n\n}\n"}
{"idx": 33801, "func": "public static void main (String [] args) {\n\n    String str = \"abcdabghplhhnfl\".toLowerCase ();\n\n    Integer [] X1 = new Integer [26];\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int j = str.charAt (i) - 'a';\n\n        if (X1 [j] == null) {\n\n            X1 [j] = 1;\n\n        } else {\n\n            X1 [j] += 1;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] != null && X1 [i] > 1) {\n\n            char c = (char) (97 + i);\n\n            System.out.println (\"'\" + c + \"' comes \" + X1 [i] + \" times.\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 33802, "func": "public static void main (String...a) {\n\n    X1.out.print (\"Enter the String\");\n\n    Scanner sc = new Scanner (X1.in);\n\n    String st = sc.nextLine ();\n\n    int [] ar = new int [256];\n\n    for (int i = 0;\n\n    i < st.length (); i ++) {\n\n        ar [st.charAt (i)] = ar [st.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        char ch = (char) i;\n\n        if (ar [i] > 0) {\n\n            if (ar [i] == 1) {\n\n                X1.out.print (ch);\n\n            } else {\n\n                X1.out.print (ch + \"\" + ar [i]);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 33901, "func": "public static void main (String [] args) throws IOException {\n\n    String ch;\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Enter the Statement:\");\n\n    ch = br.readLine ();\n\n    int count = 0, X1 = 0;\n\n    do {\n\n        try {\n\n            char name [] = ch.toCharArray ();\n\n            X1 = name.length;\n\n            count = 0;\n\n            for (int j = 0;\n\n            j < X1; j ++) {\n\n                if ((name [0] == name [j]) && ((name [0] >= 65 && name [0] <= 91) || (name [0] >= 97 && name [0] <= 123))) count ++;\n\n            }\n\n            if (count != 0) System.out.println (name [0] + \" \" + count + \" Times\");\n\n            ch = ch.replace (\"\" + name [0], \"\");\n\n        } catch (Exception ex) {\n\n        }\n\n    } while (X1 != 1);\n\n}\n"}
{"idx": 33902, "func": "public static void main (String [] args) {\n\n    HashMap < Character, X1 > hm = new HashMap < Character, X1 > ();\n\n    System.out.println (\"Enter an String:\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String s1 = sc.nextLine ();\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        if (! hm.containsKey (s1.charAt (i))) {\n\n            hm.put (s1.charAt (i), (X1) 1);\n\n        } else {\n\n            hm.put (s1.charAt (i), hm.get (s1.charAt (i)) + 1);\n\n        }\n\n    }\n\n    System.out.println (\"The Charecters are:\" + hm);\n\n}\n"}
{"idx": 34001, "func": "public static void main (String [] args) throws IOException {\n\n    String ch;\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.X1.print (\"Enter the Statement:\");\n\n    ch = br.readLine ();\n\n    int count = 0, len = 0;\n\n    do {\n\n        try {\n\n            char name [] = ch.toCharArray ();\n\n            len = name.length;\n\n            count = 0;\n\n            for (int j = 0;\n\n            j < len; j ++) {\n\n                if ((name [0] == name [j]) && ((name [0] >= 65 && name [0] <= 91) || (name [0] >= 97 && name [0] <= 123))) count ++;\n\n            }\n\n            if (count != 0) System.X1.println (name [0] + \" \" + count + \" Times\");\n\n            ch = ch.replace (\"\" + name [0], \"\");\n\n        } catch (Exception ex) {\n\n        }\n\n    } while (len != 1);\n\n}\n"}
{"idx": 34002, "func": "public static void main (String [] args) {\n\n    String name = \"AnuvratAnuvra\";\n\n    char [] arr = name.toCharArray ();\n\n    HashMap < X1, Integer > map = new HashMap < X1, Integer > ();\n\n    for (char val : arr) {\n\n        map.put (val, map.containsKey (val) ? map.get (val) + 1 : 1);\n\n    }\n\n    for (Entry < X1, Integer > entry : map.entrySet ()) {\n\n        if (entry.getValue () > 1) {\n\n            X1 key = entry.getKey ();\n\n            Object value = entry.getValue ();\n\n            System.out.println (key + \":\" + value);\n\n        }\n\n    }\n\n}\n"}
{"idx": 3401, "func": "public static boolean isPrime (long num) {\n\n    if (num > 2 && num % 2 == 0) {\n\n        System.out.X1 (num + \" is not prime\");\n\n        return false;\n\n    }\n\n    int top = (int) Math.sqrt (num) + 1;\n\n    for (int i = 3;\n\n    i < top; i += 2) {\n\n        if (num % i == 0) {\n\n            System.out.X1 (num + \" is not prime\");\n\n            return false;\n\n        }\n\n    }\n\n    System.out.X1 (num + \" is prime\");\n\n    return true;\n\n}\n"}
{"idx": 3402, "func": "boolean isPrime (int X1) {\n\n    for (int i = 2;\n\n    i * i <= X1; i ++) {\n\n        if (X1 % i == 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 34101, "func": "public static void main (String [] args) throws IOException {\n\n    String ch;\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Enter the Statement:\");\n\n    ch = br.readLine ();\n\n    int count = 0, len = 0;\n\n    do {\n\n        try {\n\n            char X1 [] = ch.toCharArray ();\n\n            len = X1.length;\n\n            count = 0;\n\n            for (int j = 0;\n\n            j < len; j ++) {\n\n                if ((X1 [0] == X1 [j]) && ((X1 [0] >= 65 && X1 [0] <= 91) || (X1 [0] >= 97 && X1 [0] <= 123))) count ++;\n\n            }\n\n            if (count != 0) System.out.println (X1 [0] + \" \" + count + \" Times\");\n\n            ch = ch.replace (\"\" + X1 [0], \"\");\n\n        } catch (Exception ex) {\n\n        }\n\n    } while (len != 1);\n\n}\n"}
{"idx": 34102, "func": "public static void main (String [] args) {\n\n    String test = \"The quick brown fox jumped over the lazy dog.\";\n\n    int countA = 0, countO = 0, countSpace = 0, countDot = 0;\n\n    for (int X1 = 0;\n\n    X1 < test.length (); X1 ++) {\n\n        switch (test.charAt (X1)) {\n\n            case 'a' :\n\n            case 'A' :\n\n                countA ++;\n\n                break;\n\n            case 'o' :\n\n            case 'O' :\n\n                countO ++;\n\n                break;\n\n            case ' ' :\n\n                countSpace ++;\n\n                break;\n\n            case '.' :\n\n                countDot ++;\n\n                break;\n\n        }\n\n    }\n\n    System.out.printf (\"%s%d%n%s%d%n%s%d%n%s%d\", \"A: \", countA, \"O: \", countO, \"Space: \", countSpace, \"Dot: \", countDot);\n\n}\n"}
{"idx": 34201, "func": "public static void main (String [] args) throws IOException {\n\n    String ch;\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Enter the Statement:\");\n\n    ch = br.readLine ();\n\n    int count = 0, len = 0;\n\n    do {\n\n        try {\n\n            char X1 [] = ch.toCharArray ();\n\n            len = X1.length;\n\n            count = 0;\n\n            for (int j = 0;\n\n            j < len; j ++) {\n\n                if ((X1 [0] == X1 [j]) && ((X1 [0] >= 65 && X1 [0] <= 91) || (X1 [0] >= 97 && X1 [0] <= 123))) count ++;\n\n            }\n\n            if (count != 0) System.out.println (X1 [0] + \" \" + count + \" Times\");\n\n            ch = ch.replace (\"\" + X1 [0], \"\");\n\n        } catch (Exception ex) {\n\n        }\n\n    } while (len != 1);\n\n}\n"}
{"idx": 34202, "func": "public static void main (String...a) {\n\n    System.X1.print (\"Enter the String\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String st = sc.nextLine ();\n\n    int [] ar = new int [256];\n\n    for (int i = 0;\n\n    i < st.length (); i ++) {\n\n        ar [st.charAt (i)] = ar [st.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        char ch = (char) i;\n\n        if (ar [i] > 0) {\n\n            if (ar [i] == 1) {\n\n                System.X1.print (ch);\n\n            } else {\n\n                System.X1.print (ch + \"\" + ar [i]);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 34301, "func": "public static void main (String [] args) {\n\n    HashMap < Character, Integer > hm = new HashMap < Character, Integer > ();\n\n    System.out.println (\"Enter an String:\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String s1 = sc.nextLine ();\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        if (! hm.containsKey (s1.X1 (i))) {\n\n            hm.put (s1.X1 (i), (Integer) 1);\n\n        } else {\n\n            hm.put (s1.X1 (i), hm.get (s1.X1 (i)) + 1);\n\n        }\n\n    }\n\n    System.out.println (\"The Charecters are:\" + hm);\n\n}\n"}
{"idx": 34302, "func": "public static void main (String [] args) {\n\n    String test = \"The quick brown fox jumped over the lazy dog.\";\n\n    int countA = 0, countO = 0, X1 = 0, countDot = 0;\n\n    for (int i = 0;\n\n    i < test.length (); i ++) {\n\n        switch (test.charAt (i)) {\n\n            case 'a' :\n\n            case 'A' :\n\n                countA ++;\n\n                break;\n\n            case 'o' :\n\n            case 'O' :\n\n                countO ++;\n\n                break;\n\n            case ' ' :\n\n                X1 ++;\n\n                break;\n\n            case '.' :\n\n                countDot ++;\n\n                break;\n\n        }\n\n    }\n\n    System.out.printf (\"%s%d%n%s%d%n%s%d%n%s%d\", \"A: \", countA, \"O: \", countO, \"Space: \", X1, \"Dot: \", countDot);\n\n}\n"}
{"idx": 34401, "func": "public static void main (String [] args) {\n\n    HashMap < Character, Integer > hm = new HashMap < Character, Integer > ();\n\n    System.out.println (\"Enter an String:\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String s1 = sc.nextLine ();\n\n    for (int X1 = 0;\n\n    X1 < s1.length (); X1 ++) {\n\n        if (! hm.containsKey (s1.charAt (X1))) {\n\n            hm.put (s1.charAt (X1), (Integer) 1);\n\n        } else {\n\n            hm.put (s1.charAt (X1), hm.get (s1.charAt (X1)) + 1);\n\n        }\n\n    }\n\n    System.out.println (\"The Charecters are:\" + hm);\n\n}\n"}
{"idx": 34402, "func": "public static void main (String...a) {\n\n    System.out.print (\"Enter the String\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String st = sc.nextLine ();\n\n    int [] X1 = new int [256];\n\n    for (int i = 0;\n\n    i < st.length (); i ++) {\n\n        X1 [st.charAt (i)] = X1 [st.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        char ch = (char) i;\n\n        if (X1 [i] > 0) {\n\n            if (X1 [i] == 1) {\n\n                System.out.print (ch);\n\n            } else {\n\n                System.out.print (ch + \"\" + X1 [i]);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 34501, "func": "public static void main (String [] args) {\n\n    String name = \"AnuvratAnuvra\";\n\n    char [] arr = name.toCharArray ();\n\n    HashMap < Character, Integer > X1 = new HashMap < Character, Integer > ();\n\n    for (char val : arr) {\n\n        X1.put (val, X1.containsKey (val) ? X1.get (val) + 1 : 1);\n\n    }\n\n    for (Entry < Character, Integer > entry : X1.entrySet ()) {\n\n        if (entry.getValue () > 1) {\n\n            Character key = entry.getKey ();\n\n            Object value = entry.getValue ();\n\n            System.out.println (key + \":\" + value);\n\n        }\n\n    }\n\n}\n"}
{"idx": 34502, "func": "public static void main (String [] args) {\n\n    String test = \"The quick brown fox jumped over the lazy dog.\";\n\n    int countA = 0, countO = 0, X1 = 0, countDot = 0;\n\n    for (int i = 0;\n\n    i < test.length (); i ++) {\n\n        switch (test.charAt (i)) {\n\n            case 'a' :\n\n            case 'A' :\n\n                countA ++;\n\n                break;\n\n            case 'o' :\n\n            case 'O' :\n\n                countO ++;\n\n                break;\n\n            case ' ' :\n\n                X1 ++;\n\n                break;\n\n            case '.' :\n\n                countDot ++;\n\n                break;\n\n        }\n\n    }\n\n    System.out.printf (\"%s%d%n%s%d%n%s%d%n%s%d\", \"A: \", countA, \"O: \", countO, \"Space: \", X1, \"Dot: \", countDot);\n\n}\n"}
{"idx": 34601, "func": "public static void main (String [] args) {\n\n    String test = \"The quick brown fox jumped over the lazy dog.\";\n\n    int countA = 0, countO = 0, countSpace = 0, countDot = 0;\n\n    for (int X1 = 0;\n\n    X1 < test.length (); X1 ++) {\n\n        switch (test.charAt (X1)) {\n\n            case 'a' :\n\n            case 'A' :\n\n                countA ++;\n\n                break;\n\n            case 'o' :\n\n            case 'O' :\n\n                countO ++;\n\n                break;\n\n            case ' ' :\n\n                countSpace ++;\n\n                break;\n\n            case '.' :\n\n                countDot ++;\n\n                break;\n\n        }\n\n    }\n\n    System.out.printf (\"%s%d%n%s%d%n%s%d%n%s%d\", \"A: \", countA, \"O: \", countO, \"Space: \", countSpace, \"Dot: \", countDot);\n\n}\n"}
{"idx": 34602, "func": "public static void main (String...a) {\n\n    System.out.print (\"Enter the String\");\n\n    Scanner sc = new Scanner (System.in);\n\n    String st = sc.nextLine ();\n\n    int [] X1 = new int [256];\n\n    for (int i = 0;\n\n    i < st.length (); i ++) {\n\n        X1 [st.charAt (i)] = X1 [st.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        char ch = (char) i;\n\n        if (X1 [i] > 0) {\n\n            if (X1 [i] == 1) {\n\n                System.out.print (ch);\n\n            } else {\n\n                System.out.print (ch + \"\" + X1 [i]);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 34701, "func": "public void processRow (ResultSet rs) throws SQLException {\n\n    Long id = rs.getLong (\"CUSTOMER_ID\");\n\n    Customer customer = X1.get (id);\n\n    if (customer == null) {\n\n        customer = new Customer ();\n\n        customer.setId (id);\n\n        customer.setName (rs.getString (\"CUSTOMER_NAME\"));\n\n        customer.setAccountNumber (rs.getLong (\"CUSTOMER_ACCOUNT_NO\"));\n\n        X1.put (id, customer);\n\n    }\n\n}\n"}
{"idx": 34702, "func": "public void processRow (ResultSet rs) throws SQLException {\n\n    Long id = rs.getLong (\"CUSTOMER_ID\");\n\n    Customer customer = map.get (id);\n\n    if (customer != null) {\n\n        List brandList = customer.getBrands ();\n\n        if (X1 == null) {\n\n            X1 = new ArrayList < Brand > ();\n\n            customer.setBrands (X1);\n\n        }\n\n        Brand brand = new Brand ();\n\n        brand.setId (rs.getLong (\"CUSTOMER_BRAND_ID\"));\n\n        brand.setName (rs.getString (\"CUSTOMER_BRAND_NAME\"));\n\n        X1.add (brand);\n\n    }\n\n}\n"}
{"idx": 34801, "func": "public void processRow (ResultSet rs) throws SQLException {\n\n    Long id = rs.getLong (\"CUSTOMER_ID\");\n\n    Customer customer = X1.get (id);\n\n    if (customer == null) {\n\n        customer = new Customer ();\n\n        customer.setId (id);\n\n        customer.setName (rs.getString (\"CUSTOMER_NAME\"));\n\n        customer.setAccountNumber (rs.getLong (\"CUSTOMER_ACCOUNT_NO\"));\n\n        X1.put (id, customer);\n\n    }\n\n}\n"}
{"idx": 34802, "func": "public void processRow (ResultSet rs) throws SQLException {\n\n    Long id = rs.getLong (\"CUSTOMER_ID\");\n\n    Customer X1 = map.get (id);\n\n    if (X1 != null) {\n\n        List ordersList = X1.getOrders ();\n\n        if (ordersList == null) {\n\n            ordersList = new ArrayList < Order > ();\n\n            X1.setOrders (ordersList);\n\n        }\n\n        Order order = new Order ();\n\n        order.setId (rs.getLong (\"ORDER_ID\"));\n\n        ordersList.add (order);\n\n    }\n\n}\n"}
{"idx": 34901, "func": "public void actionPerformed (ActionEvent e) {\n\n    try {\n\n        OutputStream os = new BufferedOutputStream (new FileOutputStream (file));\n\n        XMLEncoder X1 = new XMLEncoder (os);\n\n        X1.setPersistenceDelegate (DefaultTableModel.class, new DefaultTableModelPersistenceDelegate ());\n\n        X1.writeObject (model);\n\n        X1.close ();\n\n        Reader r = new BufferedReader (new InputStreamReader (new FileInputStream (file), \"UTF-8\"));\n\n        textArea.read (r, null);\n\n    } catch (IOException ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 34902, "func": "public void actionPerformed (ActionEvent e) {\n\n    try {\n\n        InputStream is = new BufferedInputStream (new FileInputStream (file));\n\n        XMLDecoder X1 = new XMLDecoder (is);\n\n        model = (DefaultTableModel) X1.readObject ();\n\n        table.setModel (model);\n\n    } catch (IOException ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 35001, "func": "public void run () {\n\n    try {\n\n        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());\n\n    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n    JFrame X1 = new JFrame (\"Testing\");\n\n    X1.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    X1.add (new TestPane ());\n\n    X1.pack ();\n\n    X1.setLocationRelativeTo (null);\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 35002, "func": "public void run () {\n\n    JLabel l = new JLabel (new ImageIcon (bi));\n\n    Border twoPartBorder = new CompoundBorder (new EmptyBorder (15, 15, 15, 15), new EtchedBorder ());\n\n    Border threePartBorder = new CompoundBorder (twoPartBorder, new EmptyBorder (15, 15, 15, 15));\n\n    l.setBorder (threePartBorder);\n\n    JFrame X1 = new JFrame (\"Three Part Border\");\n\n    X1.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n    X1.setContentPane (l);\n\n    X1.pack ();\n\n    X1.setLocationByPlatform (true);\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 3501, "func": "private static void shuffleArray (int [] X1) {\n\n    int index;\n\n    Random random = new Random ();\n\n    for (int i = X1.length - 1;\n\n    i > 0; i --) {\n\n        index = random.nextInt (i + 1);\n\n        if (index != i) {\n\n            X1 [index] ^= X1 [i];\n\n            X1 [i] ^= X1 [index];\n\n            X1 [index] ^= X1 [i];\n\n        }\n\n    }\n\n}\n"}
{"idx": 3502, "func": "static void shuffleArray (int [] ar) {\n\n    Random X1 = ThreadLocalRandom.current ();\n\n    for (int i = ar.length - 1;\n\n    i > 0; i --) {\n\n        int index = X1.nextInt (i + 1);\n\n        int a = ar [index];\n\n        ar [index] = ar [i];\n\n        ar [i] = a;\n\n    }\n\n}\n"}
{"idx": 35101, "func": "@Override\n\npublic void onRequestPermissionsResult (int X1, String permissions [], int [] grantResults) {\n\n    switch (X1) {\n\n        case Constants.PERMISSIONS_REQUEST_CALL_PHONE :\n\n            {\n\n                if (grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    checkPermissionsAndCall ();\n\n                }\n\n            }}\n\n}\n"}
{"idx": 35102, "func": "public void onRequestPermissionsResult (int X1,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    int index = (X1>> 16) & 0xffff;\n\n    if (index != 0) {\n\n        index --;\n\n        String who = mPendingFragmentActivityResults.get (index);\n\n        mPendingFragmentActivityResults.remove (index);\n\n        if (who == null) {\n\n            Log.w (TAG, \"Activity result delivered for unknown Fragment.\");\n\n            return;\n\n        }\n\n        Fragment frag = mFragments.findFragmentByWho (who);\n\n        if (frag == null) {\n\n            Log.w (TAG, \"Activity result no fragment exists for who: \" + who);\n\n        } else {\n\n            frag.onRequestPermissionsResult (X1 & 0xffff, permissions, grantResults);\n\n        }\n\n    }\n\n}\n"}
{"idx": 35201, "func": "protected void layoutPlotChildren () {\n\n    super.layoutPlotChildren ();\n\n    for (Series < String, X1 > series : getData ()) {\n\n        for (Data < String, X1 > data : series.getData ()) {\n\n            StackPane bar = (StackPane) data.getNode ();\n\n            final Text dataText = new Text (data.getYValue () + \"\");\n\n            bar.getChildren ().add (dataText);\n\n        }\n\n    }\n\n}\n"}
{"idx": 35202, "func": "protected void layoutPlotChildren () {\n\n    super.layoutPlotChildren ();\n\n    for (Series < String, Number > series : getData ()) {\n\n        for (Data < String, Number > data : series.getData ()) {\n\n            StackPane bar = (StackPane) data.getNode ();\n\n            X1 label = null;\n\n            for (Node node : bar.getChildrenUnmodifiable ()) {\n\n                LOGGER.debug (\"Bar has child {}, {}.\", node, node.getClass ());\n\n                if (node instanceof X1) {\n\n                    label = (X1) node;\n\n                    break;\n\n                }\n\n            }\n\n            if (label == null) {\n\n                label = new X1 (series.getName ());\n\n                label.setRotate (90.0);\n\n                bar.getChildren ().add (label);\n\n            } else {\n\n                label.setText (series.getName ());\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 35301, "func": "public void sublayout (int width, int height) {\n\n    if (X1 == 0) {\n\n        X1 = searchEdit.getPreferredWidth ();\n\n    }\n\n    if (managerHeight == 0) {\n\n        managerHeight = searchEdit.getPreferredHeight ();\n\n    }\n\n    super.sublayout (X1, managerHeight);\n\n    setExtent (X1, managerHeight);\n\n}\n"}
{"idx": 35302, "func": "protected void sublayout (int maxWidth, int maxHeight) {\n\n    int currX = 0;\n\n    int X1 = 0;\n\n    Field currField;\n\n    currField = this.getField (0);\n\n    switch (ScreenConfig.getInstance ().getScreen ()) {\n\n        case ScreenConfig.SCREEN_320_240 :\n\n            currX = 5;\n\n            X1 = 3;\n\n            break;\n\n        case ScreenConfig.SCREEN_480_360 :\n\n        case ScreenConfig.SCREEN_480_320 :\n\n            currX = 5;\n\n            X1 = 1;\n\n            break;\n\n    }\n\n    this.setPositionChild (currField, currX, X1);\n\n    this.layoutChild (currField, currField.getPreferredWidth (), currField.getPreferredHeight ());\n\n    setExtent (this.getPreferredWidth (), this.getPreferredHeight ());\n\n}\n"}
{"idx": 35401, "func": "public static void main (String [] args) {\n\n    double [] [] data = {{97, 36, 79}, {94, 74, 60}, {68, 76, 58}, {64, 87, 56}, {68, 27, 73}, {74, 99, 42}, {7, 93, 87}, {51, 69, 40}, {38, 23, 33}, {57, 86, 31}};\n\n    double [] xArr = new double [data.length];\n\n    double [] yArr = new double [data.length];\n\n    double [] bubbleSizeArr = new double [data.length];\n\n    for (int X1 = 0;\n\n    X1 < data.length; X1 ++) {\n\n        xArr [X1] = data [X1] [0];\n\n        yArr [X1] = data [X1] [1];\n\n        bubbleSizeArr [X1] = data [X1] [2];\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < data.length; X1 ++) {\n\n        System.out.printf (\"%5.2f %5.2f %5.2f%n\", xArr [X1], yArr [X1], bubbleSizeArr [X1]);\n\n    }\n\n}\n"}
{"idx": 35402, "func": "public static void main (String [] args) {\n\n    double [] [] data = {{97, 36, 79}, {94, 74, 60}, {68, 76, 58}, {64, 87, 56}, {68, 27, 73}, {74, 99, 42}, {7, 93, 87}, {51, 69, 40}, {38, 23, 33}, {57, 86, 31}};\n\n    double data1 [] = new double [data.length];\n\n    double data2 [] = new double [data.length];\n\n    double data3 [] = new double [data.length];\n\n    for (int X1 = 0;\n\n    X1 < data.length; X1 ++) {\n\n        for (int y = 0;\n\n        y < data [X1].length; y ++) {\n\n            if (y == 0) data1 [X1] = data [X1] [y];\n\n            else if (y == 1) data2 [X1] = data [X1] [y];\n\n            else if (y == 2) data3 [X1] = data [X1] [y];\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < data1.length; i ++) {\n\n        System.out.print (data1 [i] + \" \");\n\n        System.out.print (data2 [i] + \" \");\n\n        System.out.print (data3 [i] + \" \");\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 35501, "func": "private static void printPath (int [] [] mat, int i, int j) {\n\n    System.out.println (\"(\" + i + \",\" + j + \")\");\n\n    if (i >= 0 && i < mat.X1 - 1 && mat [i] [j] < mat [i + 1] [j]) {\n\n        printPath (mat, i + 1, j);\n\n    } else if (j >= 0 && j < mat [0].X1 - 1 && mat [i] [j] < mat [i] [j + 1]) {\n\n        printPath (mat, i, j + 1);\n\n    } else if (i > 0 && i < mat.X1 - 1 && mat [i] [j] < mat [i - 1] [j]) {\n\n        printPath (mat, i - 1, j);\n\n    } else if (j > 0 && j < mat [0].X1 - 1 && mat [i] [j] < mat [i] [j - 1]) {\n\n        printPath (mat, i, j - 1);\n\n    }\n\n}\n"}
{"idx": 35502, "func": "private static void printPath (int [] [] mat, int i, int X1) {\n\n    if (mat.length == 0 || mat [0].length == 0) {\n\n        System.out.println (\"Empty matrix\");\n\n        return;\n\n    }\n\n    System.out.println (\"(\" + i + \",\" + X1 + \")\");\n\n    int rightValue = i >= 0 && i < mat.length - 1 && mat [i] [X1] < mat [i + 1] [X1] ? mat [i + 1] [X1] : mat [i] [X1];\n\n    int belowValue = X1 >= 0 && X1 < mat [0].length - 1 && mat [i] [X1] < mat [i] [X1 + 1] ? mat [i] [X1 + 1] : mat [i] [X1];\n\n    int aboveValue = i > 0 && i < mat.length - 1 && mat [i] [X1] < mat [i - 1] [X1] ? mat [i - 1] [X1] : mat [i] [X1];\n\n    int leftValue = X1 > 0 && X1 < mat [0].length - 1 && mat [i] [X1] < mat [i] [X1 - 1] ? mat [i] [X1 - 1] : mat [i] [X1];\n\n    if (rightValue > leftValue) {\n\n        if (rightValue > belowValue) {\n\n            if (rightValue > aboveValue) {\n\n                printPath (mat, i + 1, X1);\n\n            } else {\n\n                printPath (mat, i, X1 + 1);\n\n            }\n\n        } else {\n\n            if (belowValue > aboveValue) {\n\n                printPath (mat, i - 1, X1);\n\n            } else {\n\n                printPath (mat, i, X1 + 1);\n\n            }\n\n        }\n\n    } else {\n\n        if (leftValue > belowValue) {\n\n            if (leftValue > aboveValue) {\n\n                printPath (mat, i - 1, X1);\n\n            } else {\n\n                printPath (mat, i, X1 + 1);\n\n            }\n\n        } else {\n\n            if (belowValue > aboveValue) {\n\n                printPath (mat, i - 1, X1);\n\n            } else {\n\n                printPath (mat, i, X1 + 1);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 35601, "func": "public Object read (JsonReader X1) throws IOException {\n\n    JsonToken token = X1.peek ();\n\n    switch (token) {\n\n        case BEGIN_ARRAY :\n\n            List < Object > list = new ArrayList < Object > ();\n\n            X1.beginArray ();\n\n            while (X1.hasNext ()) {\n\n                list.add (read (X1));\n\n            }\n\n            X1.endArray ();\n\n            return list;\n\n        case BEGIN_OBJECT :\n\n            Map < String, Object > map = new LinkedTreeMap < String, Object > ();\n\n            X1.beginObject ();\n\n            while (X1.hasNext ()) {\n\n                map.put (X1.nextName (), read (X1));\n\n            }\n\n            X1.endObject ();\n\n            return map;\n\n        case STRING :\n\n            return X1.nextString ();\n\n        case NUMBER :\n\n            String n = X1.nextString ();\n\n            if (n.indexOf ('.') != - 1) {\n\n                return Double.parseDouble (n);\n\n            }\n\n            return Long.parseLong (n);\n\n        case BOOLEAN :\n\n            return X1.nextBoolean ();\n\n        case NULL :\n\n            X1.nextNull ();\n\n            return null;\n\n        default :\n\n            throw new IllegalStateException ();\n\n    }\n\n}\n"}
{"idx": 35602, "func": "public Object read (X1 in) {\n\n    if (in.isJsonArray ()) {\n\n        List < Object > list = new ArrayList < Object > ();\n\n        JsonArray arr = in.getAsJsonArray ();\n\n        for (X1 anArr : arr) {\n\n            list.add (read (anArr));\n\n        }\n\n        return list;\n\n    } else if (in.isJsonObject ()) {\n\n        Map < String, Object > map = new LinkedTreeMap < String, Object > ();\n\n        JsonObject obj = in.getAsJsonObject ();\n\n        Set < Map.Entry < String, X1 > > entitySet = obj.entrySet ();\n\n        for (Map.Entry < String, X1 > entry : entitySet) {\n\n            map.put (entry.getKey (), read (entry.getValue ()));\n\n        }\n\n        return map;\n\n    } else if (in.isJsonPrimitive ()) {\n\n        JsonPrimitive prim = in.getAsJsonPrimitive ();\n\n        if (prim.isBoolean ()) {\n\n            return prim.getAsBoolean ();\n\n        } else if (prim.isString ()) {\n\n            return prim.getAsString ();\n\n        } else if (prim.isNumber ()) {\n\n            Number num = prim.getAsNumber ();\n\n            if (Math.ceil (num.doubleValue ()) == num.longValue ()) return num.longValue ();\n\n            else {\n\n                return num.doubleValue ();\n\n            }\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 35701, "func": "public static void main (String [] args) {\n\n    int [] A = {9, 5, 4, 3, 2, 1, 34, 53};\n\n    int [] B = new int [A.length];\n\n    int [] C = new int [A.length];\n\n    int t = 4;\n\n    int j = 0, k = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (A [X1] <= t) {\n\n            B [j] = A [X1];\n\n            j ++;\n\n        } else {\n\n            C [k] = A [X1];\n\n            k ++;\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < j; X1 ++) {\n\n        System.out.println (\"B = \" + B [X1]);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < k; X1 ++) {\n\n        System.out.println (\"C = \" + C [X1]);\n\n    }\n\n}\n"}
{"idx": 35702, "func": "public static void main (String [] args) {\n\n    int [] A = {9, 5, 4, 3, 2, 1, 34, 53};\n\n    int [] B = new int [A.length];\n\n    int [] C = new int [A.length];\n\n    int t = 4;\n\n    int countb = 0;\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= t) {\n\n            B [countb ++] = A [i];\n\n        } else {\n\n            C [X1 ++] = A [i];\n\n        }\n\n    }\n\n    System.out.println (Arrays.toString (B));\n\n    System.out.println (Arrays.toString (C));\n\n}\n"}
{"idx": 35801, "func": "public static void main (String [] args) {\n\n    int [] A = {9, 5, 4, 3, 2, 1, 34, 53};\n\n    int [] B = new int [A.length];\n\n    int [] C = new int [A.length];\n\n    int t = 4;\n\n    int j = 0, k = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (A [X1] <= t) {\n\n            B [j] = A [X1];\n\n            j ++;\n\n        } else {\n\n            C [k] = A [X1];\n\n            k ++;\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < j; X1 ++) {\n\n        System.out.println (\"B = \" + B [X1]);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < k; X1 ++) {\n\n        System.out.println (\"C = \" + C [X1]);\n\n    }\n\n}\n"}
{"idx": 35802, "func": "public static void main (String [] args) {\n\n    int [] A = {9, 5, 4, 3, 2, 1, 34, 53};\n\n    int t = 4;\n\n    int count = 0;\n\n    for (int i = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= t) {\n\n            count ++;\n\n        }\n\n    }\n\n    int [] B = new int [count];\n\n    int [] C = new int [A.length - count];\n\n    for (int i = 0, j = 0, k = 0;\n\n    i < A.length; i ++) {\n\n        if (A [i] <= t) {\n\n            B [j] = A [i];\n\n            System.out.X1 (\"B = \" + B [j]);\n\n            j ++;\n\n        } else {\n\n            C [k] = A [i];\n\n            System.out.X1 (\"C = \" + C [k]);\n\n            k ++;\n\n        }\n\n    }\n\n}\n"}
{"idx": 35901, "func": "public static void main (String [] args) {\n\n    int [] A = {9, 5, 4, 3, 2, 1, 34, 53};\n\n    int [] B = new int [A.length];\n\n    int [] C = new int [A.length];\n\n    int t = 4;\n\n    int countb = 0;\n\n    int countc = 0;\n\n    for (int X1 = 0;\n\n    X1 < A.length; X1 ++) {\n\n        if (A [X1] <= t) {\n\n            B [countb ++] = A [X1];\n\n        } else {\n\n            C [countc ++] = A [X1];\n\n        }\n\n    }\n\n    System.out.println (Arrays.toString (B));\n\n    System.out.println (Arrays.toString (C));\n\n}\n"}
{"idx": 35902, "func": "public static void main (String [] args) {\n\n    int [] A = {9, 5, 4, 3, 2, 1, 34, 53};\n\n    int t = 4;\n\n    int count = 0;\n\n    for (int i = 0;\n\n    i < A.X1; i ++) {\n\n        if (A [i] <= t) {\n\n            count ++;\n\n        }\n\n    }\n\n    int [] B = new int [count];\n\n    int [] C = new int [A.X1 - count];\n\n    for (int i = 0, j = 0, k = 0;\n\n    i < A.X1; i ++) {\n\n        if (A [i] <= t) {\n\n            B [j] = A [i];\n\n            System.out.println (\"B = \" + B [j]);\n\n            j ++;\n\n        } else {\n\n            C [k] = A [i];\n\n            System.out.println (\"C = \" + C [k]);\n\n            k ++;\n\n        }\n\n    }\n\n}\n"}
{"idx": 36001, "func": "public static void main (String args []) {\n\n    int [] arr = new int [10];\n\n    Scanner in = new Scanner (System.in);\n\n    int X1, min = 0, max = 0;\n\n    for (X1 = 0; X1 <= arr.length; X1 ++) {\n\n        System.out.print (\"Enter any number: \");\n\n        arr [X1] = in.nextInt ();\n\n    }\n\n    min = arr [0];\n\n    for (X1 = 0; X1 <= 9; X1 ++) {\n\n        if (arr [X1] > max) {\n\n            max = arr [X1];\n\n        }\n\n        if (arr [X1] < min) {\n\n            min = arr [X1];\n\n        }\n\n    }\n\n    System.out.println (\"Maximum is: \" + max);\n\n    System.out.println (\"Minimum is: \" + min);\n\n}\n"}
{"idx": 36002, "func": "public static void main (String [] args) {\n\n    System.out.println (\"Main Method Started\");\n\n    Scanner X1 = new Scanner (System.X1);\n\n    System.out.println (\"Enter the size of the arr\");\n\n    int size = X1.nextInt ();\n\n    System.out.println (\"Enter the maximum value of the arr\");\n\n    int max = X1.nextInt ();\n\n    int [] arr = initializeArr (max, size);\n\n    print (arr);\n\n    findMinMax (arr);\n\n    System.out.println (\"Main Method Ended\");\n\n}\n"}
{"idx": 3601, "func": "private static void shuffleArray (int [] X1) {\n\n    int index;\n\n    Random random = new Random ();\n\n    for (int i = X1.length - 1;\n\n    i > 0; i --) {\n\n        index = random.nextInt (i + 1);\n\n        if (index != i) {\n\n            X1 [index] ^= X1 [i];\n\n            X1 [i] ^= X1 [index];\n\n            X1 [index] ^= X1 [i];\n\n        }\n\n    }\n\n}\n"}
{"idx": 3602, "func": "public static void shuffleArray (int [] X1) {\n\n    List < Integer > list = new ArrayList < > ();\n\n    for (int i : X1) {\n\n        list.add (i);\n\n    }\n\n    Collections.shuffle (list);\n\n    for (int i = 0;\n\n    i < list.size (); i ++) {\n\n        X1 [i] = list.get (i);\n\n    }\n\n}\n"}
{"idx": 36101, "func": "public static void main (String args []) {\n\n    int [] arr = new int [10];\n\n    Scanner in = new Scanner (System.in);\n\n    int i, min = 0, max = 0;\n\n    for (i = 0; i <= arr.length; i ++) {\n\n        System.out.print (\"Enter any number: \");\n\n        arr [i] = in.nextInt ();\n\n    }\n\n    min = arr [0];\n\n    for (i = 0; i <= 9; i ++) {\n\n        if (arr [i] > max) {\n\n            max = arr [i];\n\n        }\n\n        if (arr [i] < min) {\n\n            min = arr [i];\n\n        }\n\n    }\n\n    System.out.X1 (\"Maximum is: \" + max);\n\n    System.out.X1 (\"Minimum is: \" + min);\n\n}\n"}
{"idx": 36102, "func": "public static void main (String args []) {\n\n    int n, max = Integer.MIN_VALUE, X1 = Integer.MAX_VALUE;\n\n    System.out.println (\"Enter the number of elements: \");\n\n    Scanner sc = new Scanner (System.in);\n\n    int [] arr = new int [sc.nextInt ()];\n\n    System.out.println (\"Enter the elements: \");\n\n    for (int i = 0;\n\n    i < arr.length; i ++) {\n\n        int next = sc.nextInt ();\n\n        arr [i] = next;\n\n    }\n\n    for (int j = 0;\n\n    j < arr.length; j ++) {\n\n        if (arr [j] > max) max = arr [j];\n\n        else if (arr [j] < X1) X1 = arr [j];\n\n    }\n\n    System.out.println (\"Highest Value in array: \" + max);\n\n    System.out.println (\"Smallest Value in array: \" + X1);\n\n}\n"}
{"idx": 36201, "func": "public static void main (String [] args) {\n\n    System.out.println (\"Main Method Started\");\n\n    Scanner in = new Scanner (System.in);\n\n    System.out.println (\"Enter the size of the arr\");\n\n    int size = in.nextInt ();\n\n    System.out.println (\"Enter the maximum value of the arr\");\n\n    int X1 = in.nextInt ();\n\n    int [] arr = initializeArr (X1, size);\n\n    print (arr);\n\n    findMinMax (arr);\n\n    System.out.println (\"Main Method Ended\");\n\n}\n"}
{"idx": 36202, "func": "public static void main (String args []) {\n\n    int n, max = Integer.MIN_VALUE, X1 = Integer.MAX_VALUE;\n\n    System.out.println (\"Enter the number of elements: \");\n\n    Scanner sc = new Scanner (System.in);\n\n    int [] arr = new int [sc.nextInt ()];\n\n    System.out.println (\"Enter the elements: \");\n\n    for (int i = 0;\n\n    i < arr.length; i ++) {\n\n        int next = sc.nextInt ();\n\n        arr [i] = next;\n\n    }\n\n    for (int j = 0;\n\n    j < arr.length; j ++) {\n\n        if (arr [j] > max) max = arr [j];\n\n        else if (arr [j] < X1) X1 = arr [j];\n\n    }\n\n    System.out.println (\"Highest Value in array: \" + max);\n\n    System.out.println (\"Smallest Value in array: \" + X1);\n\n}\n"}
{"idx": 36301, "func": "public static void main (String...argv) throws ClassNotFoundException {\n\n    X1 < Foo > fooClass = loadClass ();\n\n    initializeClass (fooClass);\n\n    URLClassLoader myClassLoader = ((URLClassLoader) InitializeClassMultipleTimes.class.getClassLoader ());\n\n    URL [] urls = myClassLoader.getURLs ();\n\n    for (int i = 0;\n\n    i < 2; i ++) {\n\n        URLClassLoader newClassLoader = new URLClassLoader (urls, null);\n\n        System.out.format (\"%nLoading class using another class loader%n\", Foo.class.getSimpleName ());\n\n        X1 < ? > fooClassAgain = X1.forName (fooClass.getName (), false, newClassLoader);\n\n        initializeClass (fooClassAgain);\n\n    }\n\n}\n"}
{"idx": 36302, "func": "public static void main (String [] args) {\n\n    CustomClassLoader loader = new CustomClassLoader ();\n\n    try {\n\n        Class < ? > X1 = loader.findClass (\"sample.Sample\");\n\n        Object o = X1.newInstance ();\n\n    } catch (ClassNotFoundException e) {\n\n        e.printStackTrace ();\n\n    } catch (InstantiationException e) {\n\n        e.printStackTrace ();\n\n    } catch (IllegalAccessException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 36401, "func": "public static int TestTryFinallyBlock () {\n\n    int returnValue;\n\n    try {\n\n        int X1 = 0;\n\n        X1 = 10;\n\n        returnValue = X1;\n\n        X1 = 40;\n\n        return returnValue;\n\n    } catch (RuntimeException e) {\n\n        X1 = 40;\n\n        throw e;\n\n    }\n\n}\n"}
{"idx": 36402, "func": "public static int TestTryFinallyBlock () {\n\n    int X1 = 0;\n\n    try {\n\n        X1 = 10;\n\n        return X1;\n\n    } finally {\n\n        X1 = 40;\n\n        System.out.println (\"local: \" + X1);\n\n    }\n\n}\n"}
{"idx": 36501, "func": "public static boolean isPermutation (String s1, String X1) {\n\n    if (s1.length () != X1.length ()) {\n\n        return false;\n\n    }\n\n    int [] charCount = new int [256];\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        charCount [s1.charAt (i)] ++;\n\n        charCount [X1.charAt (i)] --;\n\n    }\n\n    for (int i = 0;\n\n    i < charCount.length; i ++) {\n\n        if (charCount [i] != 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 36502, "func": "private static boolean isPermutation (String a, String b) {\n\n    char [] aArray = a.toCharArray ();\n\n    char [] bArray = b.toCharArray ();\n\n    if (a.length () != b.length ()) {\n\n        return false;\n\n    }\n\n    int found = 0;\n\n    for (int X1 = 0;\n\n    X1 < aArray.length; X1 ++) {\n\n        char eachA = aArray [X1];\n\n        for (int k = 0;\n\n        k < bArray.length; k ++) {\n\n            if (eachA == bArray [k]) {\n\n                found ++;\n\n                bArray [k] = '\\uFFFF';\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    return found == a.length ();\n\n}\n"}
{"idx": 36601, "func": "public static void main (String [] args) {\n\n    List < List < Integer > > twoDim = new ArrayList < List < Integer > > ();\n\n    String [] inputLines = {\"0 1 0 1 0\", \"0 1 1 0 1\", \"0 0 0 1 0\"};\n\n    for (String line : inputLines) {\n\n        List < Integer > row = new ArrayList < Integer > ();\n\n        Scanner X1 = new Scanner (line);\n\n        while (X1.hasNextInt ()) row.add (X1.nextInt ());\n\n        twoDim.add (row);\n\n    }\n\n}\n"}
{"idx": 36602, "func": "public static void main (String...args) {\n\n    List < List < Integer > > array = new ArrayList < List < Integer > > ();\n\n    Scanner X1 = new Scanner (System.in);\n\n    out.println (\"Enter n:\");\n\n    int n = X1.nextInt ();\n\n    out.println (\"Enter m:\");\n\n    int m = X1.nextInt ();\n\n    out.println (\"Enter the values:\");\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        List < Integer > list = new ArrayList < Integer > ();\n\n        array.add (list);\n\n        for (int j = 0;\n\n        j < m; j ++) {\n\n            list.add (X1.nextInt ());\n\n        }\n\n    }\n\n    out.println (\"Result:\");\n\n    out.println (array);\n\n}\n"}
{"idx": 36701, "func": "public static void main (String [] args) throws InterruptedException {\n\n    for (int i = 0;\n\n    i < 6; i ++) {\n\n        X1 helloTask = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                new ThreadSeq ().printHello ();\n\n            }}\n\n        ;\n\n        X1 worldTask = new X1 () {\n\n            @Override\n\n            public void run () {\n\n                new ThreadSeq ().printWorld ();\n\n            }}\n\n        ;\n\n        Thread t1 = new Thread (helloTask);\n\n        Thread t2 = new Thread (worldTask);\n\n        t1.start ();\n\n        t1.join ();\n\n        t2.start ();\n\n        t2.join ();\n\n    }\n\n}\n"}
{"idx": 36702, "func": "public static void main (String [] args) throws InterruptedException {\n\n    MyThread X1 = new MyThread ();\n\n    X1.hello = hello;\n\n    X1.world = world;\n\n    X1.start ();\n\n    for (int i = 0;\n\n    i < 5; i ++) {\n\n        hello.acquire ();\n\n        System.out.println (\"Hello\");\n\n        world.release ();\n\n    }\n\n}\n"}
{"idx": 36801, "func": "public static void main (String [] args) throws InterruptedException {\n\n    for (int i = 0;\n\n    i < 6; i ++) {\n\n        Runnable helloTask = new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                new X1 ().printHello ();\n\n            }}\n\n        ;\n\n        Runnable worldTask = new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                new X1 ().printWorld ();\n\n            }}\n\n        ;\n\n        Thread t1 = new Thread (helloTask);\n\n        Thread t2 = new Thread (worldTask);\n\n        t1.start ();\n\n        t1.join ();\n\n        t2.start ();\n\n        t2.join ();\n\n    }\n\n}\n"}
{"idx": 36802, "func": "public static void main (String [] args) {\n\n    int sayThisManyTimes = 5;\n\n    AtomicBoolean saidHello = new AtomicBoolean (false);\n\n    MyThread mt = new MyThread (sayThisManyTimes, saidHello);\n\n    mt.start ();\n\n    for (int X1 = 0;\n\n    X1 < sayThisManyTimes; X1 ++) {\n\n        while (saidHello.get ()) {\n\n        }\n\n        System.out.println (\"Hello \");\n\n        saidHello.set (true);\n\n    }\n\n}\n"}
{"idx": 36901, "func": "public static void main (String [] args) throws InterruptedException {\n\n    X1 mt = new X1 ();\n\n    mt.hello = hello;\n\n    mt.world = world;\n\n    mt.start ();\n\n    for (int i = 0;\n\n    i < 5; i ++) {\n\n        hello.acquire ();\n\n        System.out.println (\"Hello\");\n\n        world.release ();\n\n    }\n\n}\n"}
{"idx": 36902, "func": "public static void main (String [] args) {\n\n    int sayThisManyTimes = 5;\n\n    X1 saidHello = new X1 (false);\n\n    MyThread mt = new MyThread (sayThisManyTimes, saidHello);\n\n    mt.start ();\n\n    for (int i = 0;\n\n    i < sayThisManyTimes; i ++) {\n\n        while (saidHello.get ()) {\n\n        }\n\n        System.out.println (\"Hello \");\n\n        saidHello.set (true);\n\n    }\n\n}\n"}
{"idx": 37001, "func": "public void run () {\n\n    try {\n\n        for (int i = 0;\n\n        i < 5; i ++) {\n\n            world.acquire ();\n\n            System.out.println (\"  World!\");\n\n            hello.release ();\n\n        }\n\n    } catch (InterruptedException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 37002, "func": "public void run () {\n\n    for (int X1 = 0;\n\n    X1 < sayThisManyTimes; X1 ++) {\n\n        while (! saidHello.get ()) {\n\n        }\n\n        System.out.println (\"World!\");\n\n        saidHello.set (false);\n\n    }\n\n}\n"}
{"idx": 3701, "func": "public static void main (String args []) {\n\n    int [] solutionArray = {1, 2, 3, 4, 5, 6, 16, 15, 14, 13, 12, 11};\n\n    shuffleArray (solutionArray);\n\n    for (int i = 0;\n\n    i < solutionArray.length; i ++) {\n\n        System.X1.print (solutionArray [i] + \" \");\n\n    }\n\n    System.X1.println ();\n\n}\n"}
{"idx": 3702, "func": "public static void main (String args []) {\n\n    Scanner sc = new Scanner (System.in);\n\n    ArrayList < Integer > l = new ArrayList < Integer > (10);\n\n    for (int i = 0;\n\n    i < 10; i ++) l.add (sc.nextInt ());\n\n    Collections.shuffle (l);\n\n    for (int X1 = 0;\n\n    X1 < 10; X1 ++) System.out.println (l.get (X1));\n\n}\n"}
{"idx": 37101, "func": "public void move () {\n\n    if (x + xa > 0 && x + xa < X1.getWidth () - 30) x = x + xa;\n\n    if (y + ya > 0 && y + ya < X1.getHeight () - 60) {\n\n        for (int i = 12;\n\n        i < 0; i --);\n\n        ya += 10;\n\n        y = y + ya;\n\n    }\n\n    if (collision ()) {\n\n        y -= 10;\n\n        onGround = true;\n\n    }\n\n    Square.y += 10;\n\n}\n"}
{"idx": 37102, "func": "public void move () {\n\n    y += ya;\n\n    X1 += xa;\n\n    if (X1 < 0) {\n\n        X1 = 0;\n\n    } else if (X1 + 30 > game.getWidth ()) {\n\n        X1 = game.getWidth () - 30;\n\n    }\n\n    if (y < 0) {\n\n        y = 0;\n\n    } else if (collision ()) {\n\n        onGround = true;\n\n        y = game.ground.getBounds ().y - d;\n\n    }\n\n}\n"}
{"idx": 37201, "func": "public void run () {\n\n    try {\n\n        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());\n\n    } catch (ClassNotFoundException X1) {\n\n    } catch (InstantiationException X1) {\n\n    } catch (IllegalAccessException X1) {\n\n    } catch (UnsupportedLookAndFeelException X1) {\n\n    }\n\n    Game game = new Game ();\n\n    JFrame frame = new JFrame (\"Test\");\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    frame.setLayout (new BorderLayout ());\n\n    frame.add (game);\n\n    frame.pack ();\n\n    frame.setLocationRelativeTo (null);\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 37202, "func": "public void run () {\n\n    while (true) {\n\n        game.move ();\n\n        try {\n\n            long startedAt = System.currentTimeMillis ();\n\n            SwingUtilities.invokeAndWait (new Runnable () {\n\n                @Override\n\n                public void run () {\n\n                    game.repaint ();\n\n                }}\n\n            );\n\n            long completedAt = System.currentTimeMillis ();\n\n            long X1 = 30 - (completedAt - startedAt);\n\n            if (X1 < 0) {\n\n                X1 = 30;\n\n            }\n\n            Thread.sleep (X1);\n\n        } catch (Exception exp) {\n\n            exp.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 37301, "func": "public static void main (String [] args) {\n\n    InputStream inStream = null;\n\n    OutputStream outStream = null;\n\n    try {\n\n        File afile = new File (\"C:\\\\folderA\\\\Afile.txt\");\n\n        File bfile = new File (\"C:\\\\folderB\\\\Afile.txt\");\n\n        inStream = new FileInputStream (afile);\n\n        outStream = new FileOutputStream (bfile);\n\n        byte [] X1 = new byte [1024];\n\n        int length;\n\n        while ((length = inStream.read (X1)) > 0) {\n\n            outStream.write (X1, 0, length);\n\n        }\n\n        inStream.close ();\n\n        outStream.close ();\n\n        afile.delete ();\n\n        System.out.println (\"File is copied successful!\");\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 37302, "func": "public static void main (String [] args) throws IOException {\n\n    Path source = Paths.get (\"/path/to/source/dir\");\n\n    Path destination = Paths.get (\"/path/to/dest/dir\");\n\n    List < Path > X1 = Files.walk (source).collect (toList ());\n\n    List < Path > destinations = X1.stream ().map (source :: relativize).map (destination :: resolve).collect (toList ());\n\n    for (int i = 0;\n\n    i < X1.size (); i ++) {\n\n        Files.copy (X1.get (i), destinations.get (i));\n\n    }\n\n}\n"}
{"idx": 37401, "func": "public void actionPerformed (ActionEvent evt) {\n\n    NewComboBox combo = (NewComboBox) evt.getSource ();\n\n    String selection = combo.getSelectedItem ().toString ();\n\n    for (int X1 = 0;\n\n    X1 < comboBoxes.length; X1 ++) {\n\n        NewComboBox comboI = comboBoxes [X1];\n\n        if (comboI != combo && comboI.getSelectedItem ().equals (selection)) {\n\n            comboI.setSelectedItem (combo.getPreviousSelectedItem ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 37402, "func": "public void actionPerformed (ActionEvent e) {\n\n    String item = (String) mainComboBox.getSelectedItem ();\n\n    Object o = subItems.get (item);\n\n    if (o == null) {\n\n        subComboBox.setModel (new X1 ());\n\n    } else {\n\n        subComboBox.setModel (new X1 ((String []) o));\n\n    }\n\n}\n"}
{"idx": 37501, "func": "public void run () {\n\n    while (appRunning) {\n\n        System.out.println (\"App running...\");\n\n        try {\n\n            Thread.X1 (1000);\n\n        } catch (InterruptedException e) {\n\n        }\n\n        if (pause > 0) {\n\n            System.out.println (\"App pausing for \" + pause + \" ms\");\n\n            try {\n\n                Thread.X1 (pause);\n\n            } catch (InterruptedException e) {\n\n            }\n\n            pause = 0;\n\n        }\n\n    }\n\n}\n"}
{"idx": 37502, "func": "public void run () {\n\n    {\n\n        X1.out.println (\"New Communication Thread Started\");\n\n        try {\n\n            PrintWriter out = new PrintWriter (clientSocket.getOutputStream (), true);\n\n            BufferedReader in = new BufferedReader (new InputStreamReader (clientSocket.getInputStream ()));\n\n            String inputLine;\n\n            while ((inputLine = in.readLine ()) != null) {\n\n                X1.out.println (\"Received: \" + inputLine);\n\n                try {\n\n                    long pauseCommand = Long.parseLong (inputLine);\n\n                    pause = pauseCommand;\n\n                    out.println (\"OK, pausing for \" + inputLine + \" ms\");\n\n                } catch (NumberFormatException e) {\n\n                }\n\n                if (inputLine.equals (\"BYE\")) {\n\n                    out.println (\"OK, bye!\");\n\n                    break;\n\n                }\n\n                if (inputLine.equals (\"STOP\")) {\n\n                    out.println (\"OK, stopping!\");\n\n                    X1.exit (1);\n\n                }\n\n            }\n\n            out.close ();\n\n            in.close ();\n\n            clientSocket.close ();\n\n        } catch (IOException e) {\n\n            X1.err.println (\"Problem with Communication Server\");\n\n            X1.exit (1);\n\n        }\n\n    }}\n"}
{"idx": 37601, "func": "private static void verifyDirsAreEqual (Path one, Path other) throws IOException {\n\n    Files.walkFileTree (one, new SimpleFileVisitor < Path > () {\n\n        @Override\n\n        public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {\n\n            FileVisitResult result = super.visitFile (file, attrs);\n\n            Path relativize = one.relativize (file);\n\n            Path fileInOther = other.resolve (relativize);\n\n            log.debug (\"=== comparing: {} to {}\", file, fileInOther);\n\n            byte [] otherBytes = Files.X1 (fileInOther);\n\n            byte [] thisBytes = Files.X1 (file);\n\n            if (! Arrays.equals (otherBytes, thisTypes)) {\n\n                throw new AssertionFailedError (file + \" is not equal to \" + fileInOther);\n\n            }\n\n            return result;\n\n        }}\n\n    );\n\n}\n"}
{"idx": 37602, "func": "private static void verifyDirsAreEqual (File expected, File generated) throws IOException {\n\n    assertTrue (\"Generated Folder doesn't exist: \" + generated, generated.exists ());\n\n    assertTrue (\"Generated is not a folder?!?!: \" + generated, generated.isDirectory ());\n\n    assertTrue (\"Expected Folder doesn't exist: \" + expected, expected.exists ());\n\n    assertTrue (\"Expected is not a folder?!?!: \" + expected, expected.isDirectory ());\n\n    Files.walkFileTree (expected.X1 (), new SimpleFileVisitor < Path > () {\n\n        @Override\n\n        public FileVisitResult preVisitDirectory (Path dir, BasicFileAttributes attrs) throws IOException {\n\n            FileVisitResult result = super.preVisitDirectory (dir, attrs);\n\n            Path relativize = expected.X1 ().relativize (dir);\n\n            File otherDir = generated.X1 ().resolve (relativize).toFile ();\n\n            log.debug (\"=== preVisitDirectory === compare \" + dir + \" to \" + otherDir);\n\n            assertEquals (\"Folders doesn't contain same file!?!?\", Arrays.toString (dir.toFile ().list ()), Arrays.toString (otherDir.list ()));\n\n            return result;\n\n        }@Override\n\n        public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {\n\n            FileVisitResult result = super.visitFile (file, attrs);\n\n            Path relativize = expected.X1 ().relativize (file);\n\n            File fileInOther = generated.X1 ().resolve (relativize).toFile ();\n\n            log.debug (\"=== comparing: \" + file + \" to \" + fileInOther);\n\n            String expectedContents = FileUtils.readFileToString (file.toFile ());\n\n            String generatedContents = FileUtils.readFileToString (fileInOther);\n\n            assertEquals (\"(\" + fileInOther + \")  csv standard doesn't match expected (\" + file + \")!\", expectedContents, generatedContents);\n\n            return result;\n\n        }}\n\n    );\n\n}\n"}
{"idx": 37701, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2d = (Graphics2D) g.create ();\n\n    Shape X1 = new Rectangle (0, 0, getWidth (), getHeight ());\n\n    Shape inner = new Rectangle (0, 0, 50, 50);\n\n    Area area = new Area (X1);\n\n    area.subtract (new Area (inner));\n\n    g2d.setColor (getBackground ());\n\n    g2d.fill (area);\n\n    g2d.dispose ();\n\n}\n"}
{"idx": 37702, "func": "protected void paintComponent (Graphics g) {\n\n    Graphics2D X1 = (Graphics2D) g;\n\n    Graphics2D imgG2 = img.createGraphics ();\n\n    imgG2.setBackground (new Color (0, 0, 0, 0));\n\n    imgG2.setColor (Color.red);\n\n    imgG2.fillRect (0, 0, 100, 100);\n\n    imgG2.clearRect (0, 0, 50, 50);\n\n    imgG2.dispose ();\n\n    X1.drawImage (img, 0, 0, null);\n\n    X1.dispose ();\n\n    super.paintComponent (g);\n\n}\n"}
{"idx": 37801, "func": "protected void exportDone (JComponent c, Transferable data, int action) {\n\n    if ((action == MOVE) && (indices != null)) {\n\n        DefaultListModel model = (DefaultListModel) source.getModel ();\n\n        if (X1 > 0) {\n\n            for (int i = 0;\n\n            i < indices.length; i ++) {\n\n                if (indices [i] > addIndex) {\n\n                    indices [i] += X1;\n\n                }\n\n            }\n\n        }\n\n        for (int i = indices.length - 1;\n\n        i >= 0; i --) {\n\n            model.remove (indices [i]);\n\n        }\n\n    }\n\n    indices = null;\n\n    addIndex = - 1;\n\n    X1 = 0;\n\n}\n"}
{"idx": 37802, "func": "protected void exportDone (JComponent c, Transferable data, int action) {\n\n    if ((action == MOVE) && (X1 != null)) {\n\n        DefaultListModel model = (DefaultListModel) source.getModel ();\n\n        for (int i = X1.length - 1;\n\n        i >= 0; i --) model.remove (X1 [i]);\n\n    }\n\n    if (addCount > 0) {\n\n        for (int i = 0;\n\n        i < X1.length; i ++) {\n\n            if (X1 [i] > addIndex) {\n\n                X1 [i] += addCount;\n\n            }\n\n        }\n\n    }\n\n    X1 = null;\n\n    addIndex = - 1;\n\n    addCount = 0;\n\n}\n"}
{"idx": 37901, "func": "public void run () {\n\n    int emptyCycleCounter = 0;\n\n    while (true) {\n\n        int i = counter.get ();\n\n        if (i > MAX_COUNTER) {\n\n            break;\n\n        }\n\n        if (i % 2 == (odd ? 1 : 0)) {\n\n            X1.out.println (i + (odd ? \" odd\" : \" even\"));\n\n            counter.incrementAndGet ();\n\n        } else {\n\n            emptyCycleCounter ++;\n\n            Thread.yield ();\n\n        }\n\n    }\n\n    X1.out.println (\"Finished\" + (odd ? \" odd\" : \" even\") + \" with \" + emptyCycleCounter + \" empty cycles.\");\n\n}\n"}
{"idx": 37902, "func": "public void run () {\n\n    for (int i = 0;\n\n    i <= 10; i += 2) {\n\n        synchronized (o) {\n\n            try {\n\n                while (turn) {\n\n                    o.wait ();\n\n                }\n\n            } catch (InterruptedException X1) {\n\n                X1.printStackTrace ();\n\n            } finally {\n\n                System.out.println (i);\n\n                turn = ! turn;\n\n                o.notifyAll ();\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 38001, "func": "public void run () {\n\n    int emptyCycleCounter = 0;\n\n    while (true) {\n\n        int i = counter.get ();\n\n        if (i > MAX_COUNTER) {\n\n            break;\n\n        }\n\n        if (i % 2 == (X1 ? 1 : 0)) {\n\n            System.out.println (i + (X1 ? \" odd\" : \" even\"));\n\n            counter.incrementAndGet ();\n\n        } else {\n\n            emptyCycleCounter ++;\n\n            Thread.yield ();\n\n        }\n\n    }\n\n    System.out.println (\"Finished\" + (X1 ? \" odd\" : \" even\") + \" with \" + emptyCycleCounter + \" empty cycles.\");\n\n}\n"}
{"idx": 38002, "func": "public void run () {\n\n    for (int i = 1;\n\n    i < 10; i += 2) {\n\n        synchronized (o) {\n\n            try {\n\n                while (! X1) {\n\n                    o.wait ();\n\n                }\n\n            } catch (InterruptedException ie) {\n\n                ie.printStackTrace ();\n\n            } finally {\n\n                System.out.println (i);\n\n                X1 = ! X1;\n\n                o.notifyAll ();\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 3801, "func": "static void shuffleArray (int [] ar) {\n\n    Random rnd = ThreadLocalRandom.current ();\n\n    for (int X1 = ar.length - 1;\n\n    X1 > 0; X1 --) {\n\n        int index = rnd.nextInt (X1 + 1);\n\n        int a = ar [index];\n\n        ar [index] = ar [X1];\n\n        ar [X1] = a;\n\n    }\n\n}\n"}
{"idx": 3802, "func": "public static void shuffleArray (int [] X1) {\n\n    List < Integer > list = new ArrayList < > ();\n\n    for (int i : X1) {\n\n        list.add (i);\n\n    }\n\n    Collections.shuffle (list);\n\n    for (int i = 0;\n\n    i < list.size (); i ++) {\n\n        X1 [i] = list.get (i);\n\n    }\n\n}\n"}
{"idx": 38101, "func": "public void sort (int [] input, Speed speed) {\n\n    SortStrategy strategy = null;\n\n    switch (speed) {\n\n        case SLOW :\n\n            strategy = new SlowBubbleSortStrategy ();\n\n            break;\n\n        case MEDIUM :\n\n            strategy = new X1 ();\n\n            break;\n\n        case FAST :\n\n            strategy = new FastQuickSortStrategy ();\n\n            break;\n\n        default :\n\n            strategy = new X1 ();\n\n    }\n\n    strategy.sort (input);\n\n}\n"}
{"idx": 38102, "func": "public void sort (int [] input) {\n\n    for (int X1 = 0;\n\n    X1 < input.length; X1 ++) {\n\n        for (int j = X1 + 1;\n\n        j < input.length; j ++) {\n\n            if (input [X1] > input [j]) {\n\n                int tmp = input [X1];\n\n                input [X1] = input [j];\n\n                input [j] = tmp;\n\n            }\n\n        }\n\n    }\n\n    System.out.println (\"Slow sorting is done and the result is :\");\n\n    for (int X1 : input) {\n\n        System.out.print (X1 + \",\");\n\n    }\n\n}\n"}
{"idx": 38201, "func": "public void sort (int [] input, Speed speed) {\n\n    SortStrategy strategy = null;\n\n    switch (speed) {\n\n        case SLOW :\n\n            strategy = new SlowBubbleSortStrategy ();\n\n            break;\n\n        case MEDIUM :\n\n            strategy = new X1 ();\n\n            break;\n\n        case FAST :\n\n            strategy = new FastQuickSortStrategy ();\n\n            break;\n\n        default :\n\n            strategy = new X1 ();\n\n    }\n\n    strategy.sort (input);\n\n}\n"}
{"idx": 38202, "func": "public void sort (int [] input) {\n\n    for (int i = 0;\n\n    i < input.length - 1; i ++) {\n\n        int X1 = i + 1;\n\n        int nxtVal = input [X1];\n\n        while (input [X1 - 1] > nxtVal) {\n\n            input [X1] = input [X1 - 1];\n\n            X1 --;\n\n            if (X1 == 0) break;\n\n        }\n\n        input [X1] = nxtVal;\n\n    }\n\n    System.out.println (\"Medium sorting is done and the result is :\");\n\n    for (int i : input) {\n\n        System.out.print (i + \",\");\n\n    }\n\n}\n"}
{"idx": 38301, "func": "public void sort (int [] input, Speed speed) {\n\n    SortStrategy strategy = null;\n\n    switch (speed) {\n\n        case SLOW :\n\n            strategy = new SlowBubbleSortStrategy ();\n\n            break;\n\n        case MEDIUM :\n\n            strategy = new X1 ();\n\n            break;\n\n        case FAST :\n\n            strategy = new FastQuickSortStrategy ();\n\n            break;\n\n        default :\n\n            strategy = new X1 ();\n\n    }\n\n    strategy.sort (input);\n\n}\n"}
{"idx": 38302, "func": "private void sort (int [] input, int startIndx, int X1) {\n\n    int endIndexOrig = X1;\n\n    int startIndexOrig = startIndx;\n\n    if (startIndx >= X1) return;\n\n    int pavitVal = input [X1];\n\n    while (startIndx <= X1) {\n\n        while (input [startIndx] < pavitVal) startIndx ++;\n\n        while (input [X1] > pavitVal) X1 --;\n\n        if (startIndx <= X1) {\n\n            int tmp = input [startIndx];\n\n            input [startIndx] = input [X1];\n\n            input [X1] = tmp;\n\n            startIndx ++;\n\n            X1 --;\n\n        }\n\n    }\n\n    sort (input, startIndexOrig, X1);\n\n    sort (input, startIndx, endIndexOrig);\n\n}\n"}
{"idx": 38401, "func": "public void sort (int [] input) {\n\n    for (int X1 = 0;\n\n    X1 < input.length; X1 ++) {\n\n        for (int j = X1 + 1;\n\n        j < input.length; j ++) {\n\n            if (input [X1] > input [j]) {\n\n                int tmp = input [X1];\n\n                input [X1] = input [j];\n\n                input [j] = tmp;\n\n            }\n\n        }\n\n    }\n\n    System.out.println (\"Slow sorting is done and the result is :\");\n\n    for (int X1 : input) {\n\n        System.out.print (X1 + \",\");\n\n    }\n\n}\n"}
{"idx": 38402, "func": "public void sort (int [] X1) {\n\n    for (int i = 0;\n\n    i < X1.length - 1; i ++) {\n\n        int k = i + 1;\n\n        int nxtVal = X1 [k];\n\n        while (X1 [k - 1] > nxtVal) {\n\n            X1 [k] = X1 [k - 1];\n\n            k --;\n\n            if (k == 0) break;\n\n        }\n\n        X1 [k] = nxtVal;\n\n    }\n\n    System.out.println (\"Medium sorting is done and the result is :\");\n\n    for (int i : X1) {\n\n        System.out.print (i + \",\");\n\n    }\n\n}\n"}
{"idx": 38501, "func": "public void sort (int [] input) {\n\n    for (int i = 0;\n\n    i < input.length; i ++) {\n\n        for (int j = i + 1;\n\n        j < input.length; j ++) {\n\n            if (input [i] > input [j]) {\n\n                int tmp = input [i];\n\n                input [i] = input [j];\n\n                input [j] = tmp;\n\n            }\n\n        }\n\n    }\n\n    X1.out.println (\"Slow sorting is done and the result is :\");\n\n    for (int i : input) {\n\n        X1.out.print (i + \",\");\n\n    }\n\n}\n"}
{"idx": 38502, "func": "private void X1 (int [] input, int startIndx, int endIndx) {\n\n    int endIndexOrig = endIndx;\n\n    int startIndexOrig = startIndx;\n\n    if (startIndx >= endIndx) return;\n\n    int pavitVal = input [endIndx];\n\n    while (startIndx <= endIndx) {\n\n        while (input [startIndx] < pavitVal) startIndx ++;\n\n        while (input [endIndx] > pavitVal) endIndx --;\n\n        if (startIndx <= endIndx) {\n\n            int tmp = input [startIndx];\n\n            input [startIndx] = input [endIndx];\n\n            input [endIndx] = tmp;\n\n            startIndx ++;\n\n            endIndx --;\n\n        }\n\n    }\n\n    X1 (input, startIndexOrig, endIndx);\n\n    X1 (input, startIndx, endIndexOrig);\n\n}\n"}
{"idx": 38601, "func": "public void sort (int [] input) {\n\n    for (int i = 0;\n\n    i < input.length - 1; i ++) {\n\n        int X1 = i + 1;\n\n        int nxtVal = input [X1];\n\n        while (input [X1 - 1] > nxtVal) {\n\n            input [X1] = input [X1 - 1];\n\n            X1 --;\n\n            if (X1 == 0) break;\n\n        }\n\n        input [X1] = nxtVal;\n\n    }\n\n    System.out.println (\"Medium sorting is done and the result is :\");\n\n    for (int i : input) {\n\n        System.out.print (i + \",\");\n\n    }\n\n}\n"}
{"idx": 38602, "func": "private void sort (int [] input, int startIndx, int endIndx) {\n\n    int endIndexOrig = endIndx;\n\n    int X1 = startIndx;\n\n    if (startIndx >= endIndx) return;\n\n    int pavitVal = input [endIndx];\n\n    while (startIndx <= endIndx) {\n\n        while (input [startIndx] < pavitVal) startIndx ++;\n\n        while (input [endIndx] > pavitVal) endIndx --;\n\n        if (startIndx <= endIndx) {\n\n            int tmp = input [startIndx];\n\n            input [startIndx] = input [endIndx];\n\n            input [endIndx] = tmp;\n\n            startIndx ++;\n\n            endIndx --;\n\n        }\n\n    }\n\n    sort (input, X1, endIndx);\n\n    sort (input, startIndx, endIndexOrig);\n\n}\n"}
{"idx": 38701, "func": "public static void main (String [] args) {\n\n    String [] name1 = {\"amy\", \"jose\", \"jeremy\", \"alice\", \"patrick\"};\n\n    String [] X1 = {\"alan\", \"may\", \"jeremy\", \"helen\", \"alexi\"};\n\n    String [] name3 = {\"adel\", \"aron\", \"amy\", \"james\", \"yam\"};\n\n    Set < String > keySet = new HashSet < String > ();\n\n    List < String > result = new ArrayList < String > ();\n\n    check (keySet, name1, result);\n\n    check (keySet, X1, result);\n\n    check (keySet, name3, result);\n\n    System.out.println (result);\n\n}\n"}
{"idx": 38702, "func": "public static void main (String [] args) {\n\n    String [] name1 = {\"amy\", \"jose\", \"jeremy\", \"alice\", \"patrick\"};\n\n    String [] name2 = {\"alan\", \"may\", \"jeremy\", \"helen\", \"alexi\"};\n\n    String [] name3 = {\"adel\", \"aron\", \"amy\", \"james\", \"yam\"};\n\n    Comparator < String > comparator = new Comparator < String > () {\n\n        @Override\n\n        public int compare (String o1, String o2) {\n\n            System.X1.println (\"Compare(\" + o1 + \",\" + o2 + \")\");\n\n            char [] a1 = o1.toCharArray ();\n\n            Arrays.sort (a1);\n\n            char [] a2 = o2.toCharArray ();\n\n            Arrays.sort (a2);\n\n            return new String (a1).compareTo (new String (a2));\n\n        }}\n\n    ;\n\n    Set < String > set = new TreeSet < String > (comparator);\n\n    for (String name : name1) {\n\n        set.add (name);\n\n    }\n\n    for (String name : name2) {\n\n        set.add (name);\n\n    }\n\n    for (String name : name3) {\n\n        set.add (name);\n\n    }\n\n    String [] result = set.toArray (new String [set.size ()]);\n\n    System.X1.println (Arrays.asList (result));\n\n    TreeMap < String, Integer > map = new TreeMap < String, Integer > (comparator);\n\n    addAll (name1, map);\n\n    addAll (name2, map);\n\n    addAll (name3, map);\n\n    System.X1.println (map);\n\n}\n"}
{"idx": 38801, "func": "public static void main (String [] args) {\n\n    List < String > X1 = new ArrayList < String > ();\n\n    X1.add (\"A\");\n\n    X1.add (\"B\");\n\n    X1.add (\"A\");\n\n    X1.add (\"B\");\n\n    X1.add (\"C\");\n\n    X1.add (\"D\");\n\n    Map < String, List < String > > map = getMap (X1);\n\n    printMapAsLists (map);\n\n}\n"}
{"idx": 38802, "func": "public static void main (String args []) throws java.io.IOException {\n\n    List < String > list = new ArrayList < String > ();\n\n    list.add (\"A\");\n\n    list.add (\"B\");\n\n    list.add (\"A\");\n\n    list.add (\"B\");\n\n    list.add (\"C\");\n\n    list.add (\"D\");\n\n    Collections.sort (list);\n\n    List < ArrayList < String > > arrays = new ArrayList < ArrayList < String > > ();\n\n    int k = 0;\n\n    for (int i = 0;\n\n    i < list.size ();) {\n\n        int count = Collections.frequency (list, list.get (i));\n\n        arrays.add (new ArrayList < String > ());\n\n        for (int j = 0;\n\n        j < count; j ++) {\n\n            arrays.get (k).add (list.get (i));\n\n        }\n\n        i += count;\n\n        k ++;\n\n    }\n\n    for (ArrayList < String > arr : arrays) {\n\n        for (String s : arr) {\n\n            X1.out.print (s + \" \");\n\n        }\n\n        X1.out.println ();\n\n    }\n\n}\n"}
{"idx": 38901, "func": "public Fluid addFluid () {\n\n    System.X1.println (\"Please enter fluids ID: \");\n\n    f.setFluidID (input.next ());\n\n    do {\n\n        try {\n\n            System.X1.println (\"Please enter fluids molecular weight: \");\n\n            f.setMolecularWeight (input.nextDouble ());\n\n            System.X1.println (\"Please enter fluids temperature: \");\n\n            f.setTemperature (input.nextDouble ());\n\n            error = false;\n\n        } catch (InputMismatchException e) {\n\n            System.X1.println (\"Error! Please provide the right input.\");\n\n        }\n\n    } while (error != false);\n\n    getFluid ().add (f);\n\n    System.X1.println (getFluid ());\n\n    return f;\n\n}\n"}
{"idx": 38902, "func": "public Fluid addFluid () {\n\n    boolean alreadyAnswered1 = false;\n\n    boolean alreadyAnswered2 = false;\n\n    boolean alreadyAnswered3 = false;\n\n    do {\n\n        try {\n\n            if (! alreadyAnswered1) {\n\n                X1.out.println (\"Please enter fluids ID: \");\n\n                f.setFluidID (input.next ());\n\n                alreadyAnswered1 = true;\n\n            }\n\n            if (! alreadyAnswered2) {\n\n                X1.out.println (\"Please enter fluids molecular weight: \");\n\n                f.setMolecularWeight (input.nextDouble ());\n\n                alreadyAnswered2 = true;\n\n            }\n\n            if (! alreadyAnswered3) {\n\n                X1.out.println (\"Please enter fluids temperature: \");\n\n                f.setTemperature (input.nextDouble ());\n\n                alreadyAnswered3 = true;\n\n            }\n\n            error = false;\n\n        } catch (InputMismatchException e) {\n\n            X1.out.println (\"Error! Please provide the right input.\");\n\n        }\n\n    } while (error != false);\n\n    getFluid ().add (f);\n\n    X1.out.println (getFluid ());\n\n    return f;\n\n}\n"}
{"idx": 39001, "func": "public static void main (String [] args) {\n\n    final AtomicInteger sequencer = new AtomicInteger (1);\n\n    final Set < Integer > integers = new HashSet < Integer > ();\n\n    final Runnable task = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            int next = sequencer.getAndIncrement ();\n\n            synchronized (integers) {\n\n                if (integers.contains (next)) {\n\n                    X1.out.println (\"duplicate detected \" + next);\n\n                }\n\n                integers.add (next);\n\n            }\n\n        }}\n\n    ;\n\n    for (int j = 0;\n\n    j < 1000; j ++) {\n\n        X1.out.print (\"testing \" + j + \" \");\n\n        sequencer.set (0);\n\n        integers.clear ();\n\n        List < Thread > threads = new ArrayList < Thread > (10000);\n\n        for (int i = 0;\n\n        i < 1000; i ++) {\n\n            Thread t = new Thread (task);\n\n            threads.add (t);\n\n            t.start ();\n\n        }\n\n        for (Thread t : threads) {\n\n            try {\n\n                t.join ();\n\n            } catch (InterruptedException e) {\n\n                e.printStackTrace ();\n\n            }\n\n        }\n\n        X1.out.println (\"integers size \" + integers.size ());\n\n    }\n\n}\n"}
{"idx": 39002, "func": "public static void main (String [] args) throws Exception {\n\n    final AtomicInteger sequencer = new AtomicInteger (1);\n\n    final int [] X1 = new int [1000];\n\n    final Runnable task = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            int next = sequencer.getAndIncrement ();\n\n            X1 [next - 1] ++;\n\n        }}\n\n    ;\n\n    List < Thread > threads = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < 1000; i ++) {\n\n        Thread t = new Thread (task);\n\n        t.start ();\n\n        threads.add (t);\n\n    }\n\n    for (Thread t : threads) {\n\n        t.join ();\n\n    }\n\n    for (int i = 0;\n\n    i < 1000; i ++) {\n\n        if (X1 [i] != 1) System.out.println (i + \" -> \" + X1 [i]);\n\n    }\n\n}\n"}
{"idx": 3901, "func": "public void shuffle (T [] ar) {\n\n    for (int X1 = ar.length - 1;\n\n    X1 > 0; X1 --) {\n\n        int index = rnd.nextInt (X1 + 1);\n\n        T a = ar [index];\n\n        ar [index] = ar [X1];\n\n        ar [X1] = a;\n\n    }\n\n}\n"}
{"idx": 3902, "func": "public static void shuffle (int [] X1) {\n\n    if (random == null) random = new Random ();\n\n    int count = X1.length;\n\n    for (int i = count;\n\n    i > 1; i --) {\n\n        swap (X1, i - 1, random.nextInt (i));\n\n    }\n\n}\n"}
{"idx": 39101, "func": "public static void printArray (int [] [] arr) {\n\n    System.out.println (\"[\");\n\n    int rows = 3;\n\n    int columns = 4;\n\n    int X1, j;\n\n    for (X1 = 0; X1 < rows; X1 ++) {\n\n        for (j = 0; j < columns; j ++) {\n\n            System.out.print (arr [X1] [j] + \" \");\n\n        }\n\n        System.out.println ();\n\n    }\n\n    System.out.println (\"]\");\n\n}\n"}
{"idx": 39102, "func": "public static final void printArray (int [] arr) {\n\n    System.out.print (\"[\");\n\n    for (int X1 = 0;\n\n    X1 < arr.length; X1 ++) {\n\n        if (X1 == arr.length - 1) System.out.print (arr [X1]);\n\n        else System.out.print (arr [X1] + \", \");\n\n    }\n\n    System.out.println (\"]\");\n\n}\n"}
{"idx": 39201, "func": "public static int mode (int [] [] X1) {\n\n    int [] oneDArray = new int [X1.length * X1.length];\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        for (int s = 0;\n\n        s < X1.length; s ++) {\n\n            oneDArray [(i * X1.length) + s] = X1 [i] [s];\n\n        }\n\n    }\n\n}\n"}
{"idx": 39202, "func": "public static int mode (int [] [] arr) {\n\n    List < Integer > list = new ArrayList < Integer > ();\n\n    for (int i = 0;\n\n    i < arr.length; i ++) {\n\n        for (int X1 = 0;\n\n        X1 < arr [i].length; X1 ++) {\n\n            list.add (arr [i] [X1]);\n\n        }\n\n    }\n\n    int [] vector = new int [list.size ()];\n\n    for (int i = 0;\n\n    i < vector.length; i ++) {\n\n        vector [i] = list.get (i);\n\n    }\n\n}\n"}
{"idx": 39301, "func": "public static String getLongestSubstring (String s) {\n\n    int length = 1;\n\n    String longestString = \"\";\n\n    for (int i = 0;\n\n    i < s.length (); i ++) {\n\n        StringBuilder str = new StringBuilder ();\n\n        str.append (s.X1 (i));\n\n        for (int j = i + 1;\n\n        j < s.length (); j ++) {\n\n            if (s.X1 (i) == s.X1 (j)) {\n\n                str.append (s.X1 (j));\n\n            } else {\n\n                break;\n\n            }\n\n        }\n\n        if (length < str.length ()) {\n\n            length = str.length ();\n\n            longestString = str.toString ();\n\n        }\n\n    }\n\n    return longestString;\n\n}\n"}
{"idx": 39302, "func": "public String getLongestSubstring (String s) {\n\n    if (s.X1 () == 0) return null;\n\n    char currentChar = s.charAt (0);\n\n    String longestString = \"\" + currentChar;\n\n    String runningString = \"\" + currentChar;\n\n    int currentLongestLength = 1;\n\n    for (int i = 1;\n\n    i < s.X1 (); i ++) {\n\n        if (s.charAt (i) == currentChar) {\n\n            runningString = runningString + currentChar;\n\n            if (runningString.X1 () > longestString.X1 ()) {\n\n                currentLongestLength ++;\n\n                longestString = runningString;\n\n            }\n\n        } else {\n\n            runningString = \"\" + s.charAt (i);\n\n        }\n\n    }\n\n    return longestString;\n\n}\n"}
{"idx": 39401, "func": "public void switchPairs () {\n\n    ListNode prev = X1;\n\n    if (X1 != null && X1.next != null) {\n\n        ListNode temp = X1;\n\n        X1 = X1.next;\n\n        temp.next = X1.next;\n\n        X1.next = temp;\n\n        prev = temp;\n\n    }\n\n    while (prev != null && prev.next != null && prev.next.next != null) {\n\n        ListNode first_node = prev.next;\n\n        ListNode second_node = first_node.next;\n\n        first_node.next = second_node.next;\n\n        second_node.next = first_node;\n\n        prev.next = second_node;\n\n        prev = first_node;\n\n    }\n\n}\n"}
{"idx": 39402, "func": "public ListNode switchPairs () {\n\n    if (this == null || this.X1 == null) return this;\n\n    ListNode top = this.X1;\n\n    ListNode first = this;\n\n    ListNode second = first.X1;\n\n    do {\n\n        ListNode third = second.X1;\n\n        second.X1 = first;\n\n        first.X1 = third;\n\n        first = third;\n\n        System.out.println (\"@@@ \" + this.toString ());\n\n        if (first != null) {\n\n            second.X1.X1 = first.X1;\n\n            second = first.X1;\n\n        }\n\n    } while (first != null && second != null);\n\n    return top;\n\n}\n"}
{"idx": 39501, "func": "public void switchPairs () {\n\n    if (front == null || front.next == null) return;\n\n    ListNode X1 = front.next;\n\n    front.next = X1.next;\n\n    X1.next = front;\n\n    front = X1;\n\n    X1 = X1.next;\n\n    while (X1.next != null && X1.next.next != null) {\n\n        ListNode temp = X1.next.next;\n\n        X1.next.next = temp.next;\n\n        temp.next = X1.next;\n\n        X1.next = temp;\n\n        X1 = temp.next;\n\n    }\n\n}\n"}
{"idx": 39502, "func": "public ListNode switchPairs () {\n\n    if (this == null || this.X1 == null) return this;\n\n    ListNode top = this.X1;\n\n    ListNode first = this;\n\n    ListNode second = first.X1;\n\n    do {\n\n        ListNode third = second.X1;\n\n        second.X1 = first;\n\n        first.X1 = third;\n\n        first = third;\n\n        System.out.println (\"@@@ \" + this.toString ());\n\n        if (first != null) {\n\n            second.X1.X1 = first.X1;\n\n            second = first.X1;\n\n        }\n\n    } while (first != null && second != null);\n\n    return top;\n\n}\n"}
{"idx": 39601, "func": "public static void main (String [] args) {\n\n    X1 main = new X1 ();\n\n    JPanel p = new JPanel ();\n\n    p.setLayout (new BorderLayout ());\n\n    p.add (new JLabel (\"test\"), BorderLayout.WEST);\n\n    p.add (new JTextField (\"growable\"), BorderLayout.CENTER);\n\n    p.add (new JComboBox (), BorderLayout.EAST);\n\n    main.add (p);\n\n    main.pack ();\n\n    main.setVisible (true);\n\n}\n"}
{"idx": 39602, "func": "public static void main (String [] args) {\n\n    X1 main = new X1 ();\n\n    JPanel p = new JPanel ();\n\n    p.setLayout (new BorderLayout ());\n\n    p.add (new JLabel (\"test\"), BorderLayout.WEST);\n\n    p.add (new JTextField (\"growable\"), BorderLayout.CENTER);\n\n    p.add (new JComboBox (), BorderLayout.EAST);\n\n    main.add (p);\n\n    main.pack ();\n\n    main.setVisible (true);\n\n}\n"}
{"idx": 39701, "func": "public static void X1 (String [] args) {\n\n    JFrame X1 = new JFrame ();\n\n    JPanel p = new JPanel ();\n\n    p.setLayout (new BorderLayout ());\n\n    p.add (new JLabel (\"test\"), BorderLayout.WEST);\n\n    p.add (new JTextField (\"growable\"), BorderLayout.CENTER);\n\n    p.add (new JComboBox (), BorderLayout.EAST);\n\n    X1.add (p);\n\n    X1.pack ();\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 39702, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame (\"GridBagLayout Demo\");\n\n    frame.setLayout (new GridBagLayout ());\n\n    JLabel label = new JLabel (\"Demo Label\");\n\n    JTextField textField = new JTextField (\"Demo Text\");\n\n    JComboBox comboBox = new JComboBox (new String [] {\"hello\", \"goodbye\", \"foo\"});\n\n    X1 cons = new X1 ();\n\n    cons.insets = new Insets (10, 10, 10, 10);\n\n    frame.add (label, cons);\n\n    cons.gridx = 1;\n\n    cons.weightx = 1;\n\n    cons.weighty = 1;\n\n    cons.insets = new Insets (10, 0, 10, 10);\n\n    cons.fill = X1.HORIZONTAL;\n\n    frame.add (textField, cons);\n\n    cons.gridx = 2;\n\n    cons.weightx = 0;\n\n    cons.weighty = 0;\n\n    cons.insets = new Insets (10, 0, 10, 10);\n\n    cons.fill = X1.NONE;\n\n    frame.add (comboBox, cons);\n\n    frame.pack ();\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 39801, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame (\"GridBagLayout Demo\");\n\n    frame.setLayout (new GridBagLayout ());\n\n    JLabel label = new JLabel (\"Demo Label\");\n\n    JTextField textField = new JTextField (\"Demo Text\");\n\n    JComboBox comboBox = new JComboBox (new String [] {\"hello\", \"goodbye\", \"foo\"});\n\n    X1 cons = new X1 ();\n\n    cons.insets = new Insets (10, 10, 10, 10);\n\n    frame.add (label, cons);\n\n    cons.gridx = 1;\n\n    cons.weightx = 1;\n\n    cons.weighty = 1;\n\n    cons.insets = new Insets (10, 0, 10, 10);\n\n    cons.fill = X1.HORIZONTAL;\n\n    frame.add (textField, cons);\n\n    cons.gridx = 2;\n\n    cons.weightx = 0;\n\n    cons.weighty = 0;\n\n    cons.insets = new Insets (10, 0, 10, 10);\n\n    cons.fill = X1.NONE;\n\n    frame.add (comboBox, cons);\n\n    frame.pack ();\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 39802, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame (\"GridBagLayout Demo\");\n\n    frame.setLayout (new GridBagLayout ());\n\n    JLabel label = new JLabel (\"Demo Label\");\n\n    JTextField textField = new JTextField (\"Demo Text\");\n\n    JComboBox comboBox = new JComboBox (new String [] {\"hello\", \"goodbye\", \"foo\"});\n\n    X1 cons = new X1 ();\n\n    cons.insets = new Insets (10, 10, 10, 10);\n\n    frame.add (label, cons);\n\n    cons.gridx = 1;\n\n    cons.weightx = 1;\n\n    cons.weighty = 1;\n\n    cons.insets = new Insets (10, 0, 10, 10);\n\n    cons.fill = X1.HORIZONTAL;\n\n    frame.add (textField, cons);\n\n    cons.gridx = 2;\n\n    cons.weightx = 0;\n\n    cons.weighty = 0;\n\n    cons.insets = new Insets (10, 0, 10, 10);\n\n    cons.fill = X1.NONE;\n\n    frame.add (comboBox, cons);\n\n    frame.pack ();\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 39901, "func": "public void contextDestroyed (ServletContextEvent servletContextEvent) {\n\n    if (this.driver != null) {\n\n        try {\n\n            DriverManager.deregisterDriver (driver);\n\n            LOG.info (String.format (\"deregistering jdbc driver: %s\", driver));\n\n        } catch (SQLException e) {\n\n            LOG.X1 (String.format (\"Error deregistering driver %s\", driver), e);\n\n        }\n\n        this.driver = null;\n\n    } else {\n\n        LOG.X1 (\"No driver to deregister\");\n\n    }\n\n}\n"}
{"idx": 39902, "func": "public void contextDestroyed (ServletContextEvent sce) {\n\n    Context initContext = new InitialContext ();\n\n    Context envContext = (Context) initContext.X1 (\"java:/comp/env\");\n\n    DataSource datasource = (DataSource) envContext.X1 (\"jdbc/database\");\n\n    try {\n\n        java.sql.Driver mySqlDriver = DriverManager.getDriver (\"jdbc:mysql://localhost:3306/\");\n\n        DriverManager.deregisterDriver (mySqlDriver);\n\n    } catch (SQLException ex) {\n\n        logger.info (\"Could not deregister driver:\".concat (ex.getMessage ()));\n\n    }\n\n    dataSource = null;\n\n}\n"}
{"idx": 40001, "func": "public void contextDestroyed (ServletContextEvent servletContextEvent) {\n\n    if (this.X1 != null) {\n\n        try {\n\n            DriverManager.deregisterDriver (X1);\n\n            LOG.info (String.format (\"deregistering jdbc driver: %s\", X1));\n\n        } catch (SQLException e) {\n\n            LOG.warn (String.format (\"Error deregistering driver %s\", X1), e);\n\n        }\n\n        this.X1 = null;\n\n    } else {\n\n        LOG.warn (\"No driver to deregister\");\n\n    }\n\n}\n"}
{"idx": 40002, "func": "public final void contextDestroyed (ServletContextEvent sce) {\n\n    ClassLoader cl = Thread.currentThread ().getContextClassLoader ();\n\n    Enumeration < Driver > drivers = DriverManager.getDrivers ();\n\n    while (drivers.hasMoreElements ()) {\n\n        Driver X1 = drivers.nextElement ();\n\n        if (X1.getClass ().getClassLoader () == cl) {\n\n            try {\n\n                log.info (\"Deregistering JDBC driver {}\", X1);\n\n                DriverManager.deregisterDriver (X1);\n\n            } catch (SQLException ex) {\n\n                log.error (\"Error deregistering JDBC driver {}\", X1, ex);\n\n            }\n\n        } else {\n\n            log.trace (\"Not deregistering JDBC driver {} as it does not belong to this webapp's ClassLoader\", X1);\n\n        }\n\n    }\n\n}\n"}
{"idx": 4001, "func": "public void shuffle (T [] ar) {\n\n    for (int X1 = ar.length - 1;\n\n    X1 > 0; X1 --) {\n\n        int index = rnd.nextInt (X1 + 1);\n\n        T a = ar [index];\n\n        ar [index] = ar [X1];\n\n        ar [X1] = a;\n\n    }\n\n}\n"}
{"idx": 4002, "func": "public static void shuffle (Object [] a) {\n\n    int n = a.length;\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        int X1 = i + (int) (Math.random () * (n - i));\n\n        Object swap = a [X1];\n\n        a [X1] = a [i];\n\n        a [i] = swap;\n\n    }\n\n}\n"}
{"idx": 401, "func": "static private void copyFolder (File src, File dest) {\n\n    if (src == null || dest == null) return;\n\n    if (! src.isDirectory ()) return;\n\n    if (dest.exists ()) {\n\n        if (! dest.isDirectory ()) {\n\n            return;\n\n        }\n\n    } else {\n\n        dest.mkdir ();\n\n    }\n\n    if (src.listFiles () == null || src.listFiles ().length == 0) return;\n\n    for (File X1 : src.listFiles ()) {\n\n        File fileDest = new File (dest, X1.getName ());\n\n        if (X1.isDirectory ()) {\n\n            copyFolder (X1, fileDest);\n\n        } else {\n\n            if (fileDest.exists ()) continue;\n\n            try {\n\n                Files.copy (X1.toPath (), fileDest.toPath ());\n\n            } catch (IOException e) {\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 40101, "func": "public void contextDestroyed (ServletContextEvent sce) {\n\n    X1 initContext = new InitialContext ();\n\n    X1 envContext = (X1) initContext.lookup (\"java:/comp/env\");\n\n    DataSource datasource = (DataSource) envContext.lookup (\"jdbc/database\");\n\n    try {\n\n        java.sql.Driver mySqlDriver = DriverManager.getDriver (\"jdbc:mysql://localhost:3306/\");\n\n        DriverManager.deregisterDriver (mySqlDriver);\n\n    } catch (SQLException ex) {\n\n        logger.info (\"Could not deregister driver:\".concat (ex.getMessage ()));\n\n    }\n\n    dataSource = null;\n\n}\n"}
{"idx": 40102, "func": "public final void contextDestroyed (ServletContextEvent sce) {\n\n    ClassLoader X1 = Thread.currentThread ().getContextClassLoader ();\n\n    Enumeration < Driver > drivers = DriverManager.getDrivers ();\n\n    while (drivers.hasMoreElements ()) {\n\n        Driver driver = drivers.nextElement ();\n\n        if (driver.getClass ().getClassLoader () == X1) {\n\n            try {\n\n                log.info (\"Deregistering JDBC driver {}\", driver);\n\n                DriverManager.deregisterDriver (driver);\n\n            } catch (SQLException ex) {\n\n                log.error (\"Error deregistering JDBC driver {}\", driver, ex);\n\n            }\n\n        } else {\n\n            log.trace (\"Not deregistering JDBC driver {} as it does not belong to this webapp's ClassLoader\", driver);\n\n        }\n\n    }\n\n}\n"}
{"idx": 402, "func": "static void copyFolder (File src, File dest) {\n\n    if (src == null || dest == null) return;\n\n    if (! src.isDirectory ()) return;\n\n    if (dest.X1 ()) {\n\n        if (! dest.isDirectory ()) {\n\n            return;\n\n        }\n\n    } else {\n\n        dest.mkdir ();\n\n    }\n\n    if (src.listFiles () == null || src.listFiles ().length == 0) return;\n\n    String strAbsPathSrc = src.getAbsolutePath ();\n\n    String strAbsPathDest = dest.getAbsolutePath ();\n\n    try {\n\n        Files.walkFileTree (src.toPath (), new SimpleFileVisitor < Path > () {\n\n            @Override\n\n            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {\n\n                File dstFile = new File (strAbsPathDest + file.toAbsolutePath ().toString ().substring (strAbsPathSrc.length ()));\n\n                if (dstFile.X1 ()) return FileVisitResult.CONTINUE;\n\n                if (! dstFile.getParentFile ().X1 ()) dstFile.getParentFile ().mkdirs ();\n\n                Files.copy (file, dstFile.toPath ());\n\n                return FileVisitResult.CONTINUE;\n\n            }}\n\n        );\n\n    } catch (IOException e) {\n\n        return;\n\n    }\n\n    return;\n\n}\n"}
{"idx": 40201, "func": "private void init () {\n\n    textField = new JTextField ();\n\n    okButton = new JButton (\"OK\");\n\n    okButton.addActionListener (this);\n\n    setLayout (new GridLayout (2, 1, 5, 5));\n\n    X1 (textField);\n\n    X1 (okButton);\n\n    pack ();\n\n}\n"}
{"idx": 40202, "func": "private void init () {\n\n    textField = new JTextField ();\n\n    JButton okButton = new JButton (\"OK\");\n\n    okButton.addActionListener (new ActionListener () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            X1.dispose ();\n\n        }}\n\n    );\n\n    X1.setLayout (new GridLayout (2, 1, 5, 5));\n\n    X1.add (textField);\n\n    X1.add (okButton);\n\n    X1.pack ();\n\n}\n"}
{"idx": 40301, "func": "private void init () {\n\n    textField = new JTextField ();\n\n    X1 = new JButton (\"OK\");\n\n    X1.addActionListener (this);\n\n    setLayout (new GridLayout (2, 1, 5, 5));\n\n    add (textField);\n\n    add (X1);\n\n    pack ();\n\n}\n"}
{"idx": 40302, "func": "private void init () {\n\n    textField = new JTextField ();\n\n    JButton okButton = new JButton (\"OK\");\n\n    okButton.addActionListener (new ActionListener () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            X1.dispose ();\n\n        }}\n\n    );\n\n    X1.setLayout (new GridLayout (2, 1, 5, 5));\n\n    X1.add (textField);\n\n    X1.add (okButton);\n\n    X1.pack ();\n\n}\n"}
{"idx": 40401, "func": "private void init () {\n\n    textField = new JTextField ();\n\n    JButton okButton = new JButton (\"OK\");\n\n    okButton.addActionListener (new ActionListener () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            X1.dispose ();\n\n        }}\n\n    );\n\n    X1.setLayout (new GridLayout (2, 1, 5, 5));\n\n    X1.add (textField);\n\n    X1.add (okButton);\n\n    X1.pack ();\n\n}\n"}
{"idx": 40402, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame (\"Application Name\");\n\n    JPanel iconPanel = new JPanel ();\n\n    JPanel grid = new JPanel (new FlowLayout ());\n\n    X1 firewallButton = new X1 (\"Firewall\");\n\n    X1 networkButton = new X1 (\"Network\");\n\n    X1 printerButton = new X1 (\"Printer\");\n\n    frame.add (iconPanel);\n\n    iconPanel.add (firewallButton);\n\n    iconPanel.add (networkButton);\n\n    iconPanel.add (printerButton);\n\n    grid.setBackground (Color.GREEN);\n\n    frame.setLayout (new GridLayout (1, 2, 3, 3));\n\n    frame.add (grid);\n\n    frame.add (iconPanel);\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    frame.pack ();\n\n    frame.setLocationRelativeTo (null);\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 40501, "func": "public static void main (String [] args) {\n\n    List < String > list1 = new LinkedList < > (X1.asList (\"Cat\", \"Mouse\", \"Dog\"));\n\n    List < String > list2 = new LinkedList < > (X1.asList (\"Dog\", \"Mouse\", \"Cat\"));\n\n    List < String > list3 = new LinkedList < > (X1.asList (\"Dog\", \"Horse\", \"Cat\"));\n\n    List < String > list4 = new LinkedList < > (X1.asList (\"Dog\", \"Tiger\", \"Lion\"));\n\n    List < List < String > > list = new LinkedList < > (X1.asList (list1, list2, list3, list4));\n\n    boolean flag = false;\n\n    boolean matchFlag = true;\n\n    for (int i = 0;\n\n    i < list.size (); i ++) {\n\n        for (int j = i + 1;\n\n        j < list.size (); j ++) {\n\n            if (list.get (i).size () == list.get (j).size ()) {\n\n                matchFlag = true;\n\n                for (String str : list.get (i)) {\n\n                    flag = false;\n\n                    for (String string : list.get (j)) {\n\n                        if (str.equals (string)) {\n\n                            flag = true;\n\n                        }\n\n                    }\n\n                    if (flag == false) {\n\n                        matchFlag = false;\n\n                        break;\n\n                    }\n\n                }\n\n                if (matchFlag) {\n\n                    list.remove (j);\n\n                    j --;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    System.out.println (list.size ());\n\n    for (int i = 0;\n\n    i < list.size (); i ++) {\n\n        System.out.println (list.get (i));\n\n    }\n\n}\n"}
{"idx": 40502, "func": "public static void main (String [] args) {\n\n    X1 < Animal > list1 = new LinkedList < > (Arrays.asList (Cat, Mouse, Dog));\n\n    X1 < Animal > list2 = new LinkedList < > (Arrays.asList (Dog, Mouse, Cat));\n\n    X1 < Animal > list3 = new LinkedList < > (Arrays.asList (Dog, Horse, Cat));\n\n    X1 < Animal > list4 = new LinkedList < > (Arrays.asList (Dog, Tiger, Lion));\n\n    X1 < X1 < Animal > > list = new LinkedList < > (Arrays.asList (list1, list2, list3, list4));\n\n    Set < X1 < Animal > > sorted = new LinkedHashSet < > ();\n\n    for (X1 < Animal > animals : list) {\n\n        X1 < Animal > arList = new ArrayList < > (animals);\n\n        Collections.sort (arList);\n\n        sorted.add (new LinkedList < > (arList));\n\n    }\n\n    for (X1 < Animal > animals : sorted) {\n\n        System.out.println (animals);\n\n    }\n\n}\n"}
{"idx": 40601, "func": "public static void main (String [] args) {\n\n    Scanner scan = new Scanner (System.in);\n\n    System.out.print (\"Enter a String : \");\n\n    String str = scan.nextLine ();\n\n    X1 < String > repetition = new X1 < String > ();\n\n    X1 < String > digrams = new X1 < String > ();\n\n    String digram;\n\n    for (int i = 0;\n\n    i < str.length () - 1; i ++) {\n\n        digram = str.substring (i, i + 2);\n\n        if (repetition.contains (digram) || digram.contains (\" \") || digram.length () < 2) continue;\n\n        int occurances = (str.length () - str.replace (digram, \"\").length ()) / 2;\n\n        occurances += (str.replaceFirst (\".*?(\" + digram.charAt (0) + \"+).*\", \"$1\").length () - 1) / 2;\n\n        digrams.add (digram + \":\" + occurances);\n\n        repetition.add (digram);\n\n    }\n\n    Collections.sort (digrams, (s1, s2) -> s1.substring (3, 4).compareTo (s2.substring (3, 4)));\n\n    System.out.println (digrams);\n\n}\n"}
{"idx": 40602, "func": "public static void main (String args []) {\n\n    int ci, i, j, k, l = 0;\n\n    String str, str1, result, X1;\n\n    char c1, c2, ch;\n\n    Scanner scan = new Scanner (System.in);\n\n    System.out.print (\"Enter a String : \");\n\n    str = scan.nextLine ();\n\n    i = str.length ();\n\n    for (c1 = 'A'; c1 <= 'z'; c1 ++) {\n\n        for (c2 = 'A'; c2 <= 'z'; c2 ++) {\n\n            result = new String (new char [] {c1, c2});\n\n            k = 0;\n\n            for (j = 0; j < i - 1; j ++) {\n\n                X1 = str.substring (j, j + 2);\n\n                if (result.equals (X1)) {\n\n                    k ++;\n\n                }\n\n            }\n\n            if (k > 0) {\n\n                System.out.println (\"\" + result + \": \" + k);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 40701, "func": "public static void main (String [] args) {\n\n    Scanner in = new Scanner (System.in);\n\n    System.out.println (\"Insert The Sentence\");\n\n    String [] sentence = in.nextLine ().split (\" \");\n\n    ArrayList < String > allDigrams = new ArrayList < String > ();\n\n    for (int i = 0;\n\n    i < sentence.length; i ++) {\n\n        for (int X1 = 0;\n\n        X1 < sentence [i].length (); X1 ++) {\n\n            String oneDigram = \"\";\n\n            if (X1 < sentence [i].length () - 1) {\n\n                oneDigram += sentence [i].charAt (X1);\n\n                oneDigram += sentence [i].charAt (X1 + 1);\n\n                allDigrams.add (oneDigram);\n\n            }\n\n        }\n\n    }\n\n    ArrayList < Integer > frequency = new ArrayList < Integer > ();\n\n    ArrayList < String > digrams = new ArrayList < String > ();\n\n    int freqIndex = 0;\n\n    while (allDigrams.size () > 0) {\n\n        frequency.add (freqIndex, 0);\n\n        for (int X1 = 0;\n\n        X1 < allDigrams.size (); X1 ++) {\n\n            if (allDigrams.get (0).equalsIgnoreCase (allDigrams.get (X1))) {\n\n                frequency.set (freqIndex, frequency.get (freqIndex) + 1);\n\n            }\n\n        }\n\n        String dig = allDigrams.get (0);\n\n        while (allDigrams.contains (dig)) {\n\n            allDigrams.remove (dig);\n\n        }\n\n        digrams.add (dig);\n\n        freqIndex ++;\n\n    }\n\n    for (int i = 0;\n\n    i < frequency.size (); i ++) {\n\n        for (int X1 = 0;\n\n        X1 < frequency.size () - i - 1; X1 ++) {\n\n            if (frequency.get (X1) < frequency.get (X1 + 1) || ((frequency.get (X1) == frequency.get (X1 + 1)) && (digrams.get (X1).charAt (0) > digrams.get (X1 + 1).charAt (0))) || ((digrams.get (X1).charAt (0) == digrams.get (X1 + 1).charAt (0)) && (digrams.get (X1).charAt (1) > digrams.get (X1 + 1).charAt (1)))) {\n\n                int swap = frequency.get (X1);\n\n                String swapS = digrams.get (X1);\n\n                frequency.set (X1, frequency.get (X1 + 1));\n\n                frequency.set (X1 + 1, swap);\n\n                digrams.set (X1, digrams.get (X1 + 1));\n\n                digrams.set (X1 + 1, swapS);\n\n            }\n\n        }\n\n    }\n\n    String sortedResult = \"\";\n\n    for (int i = 0;\n\n    i < frequency.size (); i ++) {\n\n        sortedResult += digrams.get (i) + \":\" + frequency.get (i) + \" \";\n\n    }\n\n    System.out.println (sortedResult);\n\n}\n"}
{"idx": 40702, "func": "public static void main (String args []) {\n\n    int ci, i, j, k, l = 0;\n\n    String str, str1, result, X1;\n\n    char c1, c2, ch;\n\n    Scanner scan = new Scanner (System.in);\n\n    System.out.print (\"Enter a String : \");\n\n    str = scan.nextLine ();\n\n    i = str.length ();\n\n    for (c1 = 'A'; c1 <= 'z'; c1 ++) {\n\n        for (c2 = 'A'; c2 <= 'z'; c2 ++) {\n\n            result = new String (new char [] {c1, c2});\n\n            k = 0;\n\n            for (j = 0; j < i - 1; j ++) {\n\n                X1 = str.substring (j, j + 2);\n\n                if (result.equals (X1)) {\n\n                    k ++;\n\n                }\n\n            }\n\n            if (k > 0) {\n\n                System.out.println (\"\" + result + \": \" + k);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 40801, "func": "static void rotate (int [] array, int k) {\n\n    int X1 = array.length;\n\n    if (X1 <= 1) return;\n\n    k = k % X1;\n\n    if (k == 0) return;\n\n    for (int i = 0, start = 0, from = 0, to = - 1, move = array [0];\n\n    i < X1; ++ i, from = to) {\n\n        to = (from + k) % X1;\n\n        int temp = array [to];\n\n        array [to] = move;\n\n        move = to == start ? array [to = ++ start] : temp;\n\n    }\n\n}\n"}
{"idx": 40802, "func": "public int [] rotate (int [] nums, int X1) {\n\n    if (X1 > nums.length) X1 = X1 % nums.length;\n\n    int [] result = new int [nums.length];\n\n    System.arraycopy (nums, X1 + 1, result, 0, X1);\n\n    System.arraycopy (nums, 0, result, X1 + 1, nums.length - 1);\n\n    nums = result;\n\n    return result;\n\n}\n"}
{"idx": 40901, "func": "public static void main (String [] args) throws URISyntaxException, MalformedURLException {\n\n    URLBuilder urlb = new URLBuilder (\"www.example.com\");\n\n    urlb.setConnectionType (\"http\");\n\n    urlb.addSubfolder (\"somesub\");\n\n    urlb.addSubfolder (\"anothersub\");\n\n    urlb.X1 (\"param lol\", \"unknown\");\n\n    urlb.X1 (\"paramY\", \"known\");\n\n    String url = urlb.getURL ();\n\n    System.out.println (url);\n\n    urlb = new URLBuilder ();\n\n    urlb.addSubfolder (\"servlet\");\n\n    urlb.addSubfolder (\"jsp\");\n\n    urlb.addSubfolder (\"somesub\");\n\n    urlb.addSubfolder (\"anothersub\");\n\n    urlb.X1 (\"param lol\", \"unknown\");\n\n    urlb.X1 (\"paramY\", \"known\");\n\n    String relUrl = urlb.getRelativeURL ();\n\n    System.out.println (relUrl);\n\n}\n"}
{"idx": 40902, "func": "public static void main (String args []) {\n\n    try {\n\n        URLBuilder X1 = new URLBuilder ();\n\n        System.out.println (X1.toString ());\n\n        X1.setFragment (\"fragment\");\n\n        System.out.println (X1.toString ());\n\n        X1.setHost (\"host.com\");\n\n        System.out.println (X1.toString ());\n\n        X1.addPath (\"APath\");\n\n        System.out.println (X1.toString ());\n\n        X1.addPath (\"AnotherPath\");\n\n        System.out.println (X1.toString ());\n\n        X1.addQuery (\"query1\", \"param1\");\n\n        System.out.println (X1.toString ());\n\n        X1.addQuery (\"query 2\", \"param 2\");\n\n        System.out.println (X1.toString ());\n\n        X1.addQuery (\"file\", new File (\"Hello World.txt\"));\n\n        System.out.println (X1.toString ());\n\n    } catch (Throwable t) {\n\n        t.printStackTrace (System.err);\n\n    }\n\n}\n"}
{"idx": 41001, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int X1 = NO_VALUE;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number < 10) {\n\n        X1 = (number % 10) - 1;\n\n    } else if (number < 20) {\n\n        X1 = (number % 20) - 1;\n\n    }\n\n    if (X1 != NO_VALUE && X1 < TOKENS.length) {\n\n        buffer.append (TOKENS [X1]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41002, "func": "public String getName (String value) {\n\n    X1 buffer = new X1 ();\n\n    String high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (high);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! highName.isEmpty ()) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! lowName.isEmpty ()) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! lowName.isEmpty ()) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 4101, "func": "public static void shuffle (int [] X1) {\n\n    if (random == null) random = new Random ();\n\n    int count = X1.length;\n\n    for (int i = count;\n\n    i > 1; i --) {\n\n        swap (X1, i - 1, random.nextInt (i));\n\n    }\n\n}\n"}
{"idx": 4102, "func": "public static void shuffle (Object [] a) {\n\n    int n = a.length;\n\n    for (int X1 = 0;\n\n    X1 < n; X1 ++) {\n\n        int r = X1 + (int) (Math.random () * (n - X1));\n\n        Object swap = a [r];\n\n        a [r] = a [X1];\n\n        a [X1] = swap;\n\n    }\n\n}\n"}
{"idx": 41101, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int X1 = NO_VALUE;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number < 10) {\n\n        X1 = (number % 10) - 1;\n\n    } else if (number < 20) {\n\n        X1 = (number % 20) - 1;\n\n    }\n\n    if (X1 != NO_VALUE && X1 < TOKENS.length) {\n\n        buffer.append (TOKENS [X1]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41102, "func": "public X1 getName (X1 value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (\"\".equals (value)) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.append (unitProcessor.getName (number / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    X1 tensName = tensProcessor.getName (number % 100);\n\n    if (! \"\".equals (tensName) && (number >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41201, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int offset = NO_VALUE;\n\n    int X1;\n\n    if (value.length () > 3) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 100;\n\n    if (X1 < 10) {\n\n        offset = (X1 % 10) - 1;\n\n    } else if (X1 < 20) {\n\n        offset = (X1 % 20) - 1;\n\n    }\n\n    if (offset != NO_VALUE && offset < TOKENS.length) {\n\n        buffer.append (TOKENS [offset]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41202, "func": "public String X1 (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().X1 (high);\n\n    String lowName = getLowProcessor ().X1 (low);\n\n    if (! \"\".equals (highName)) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".equals (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".equals (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41301, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int offset = NO_VALUE;\n\n    int X1;\n\n    if (value.length () > 3) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 100;\n\n    if (X1 < 10) {\n\n        offset = (X1 % 10) - 1;\n\n    } else if (X1 < 20) {\n\n        offset = (X1 % 20) - 1;\n\n    }\n\n    if (offset != NO_VALUE && offset < TOKENS.length) {\n\n        buffer.append (TOKENS [offset]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41302, "func": "public X1 getName (X1 value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    X1 decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    X1 name = processor.getName (value);\n\n    if (\"\".equals (name)) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == decimalValue || \"\".equals (decimalValue))) {\n\n        X1 zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < decimalValue.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (decimalValue.equals (zeroDecimalValue)) {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        } else {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        }\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 41401, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number >= 20) {\n\n        buffer.X1 (TOKENS [(number / 10) - 2]);\n\n        number %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        number %= 20;\n\n    }\n\n    if (number != 0) {\n\n        if (tensFound) {\n\n            buffer.X1 (UNION_SEPARATOR);\n\n        }\n\n        buffer.X1 (unitProcessor.getName (number));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41402, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String X1 = processor.getName (value);\n\n    if (X1.isEmpty ()) {\n\n        X1 = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        X1 = MINUS.concat (SEPARATOR).concat (X1);\n\n    }\n\n    if (! (null == decimalValue || decimalValue.isEmpty ())) {\n\n        X1 = X1.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 41501, "func": "public String getName (String value) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number >= 20) {\n\n        X1.append (TOKENS [(number / 10) - 2]);\n\n        number %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        number %= 20;\n\n    }\n\n    if (number != 0) {\n\n        if (tensFound) {\n\n            X1.append (UNION_SEPARATOR);\n\n        }\n\n        X1.append (unitProcessor.getName (number));\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 41502, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int X1;\n\n    if (\"\".equals (value)) {\n\n        X1 = 0;\n\n    } else if (value.length () > 4) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 1000;\n\n    if (X1 >= 100) {\n\n        buffer.append (unitProcessor.getName (X1 / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (X1 % 100);\n\n    if (! \"\".equals (tensName) && (X1 >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41601, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int X1;\n\n    if (value.length () > 3) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 100;\n\n    if (X1 >= 20) {\n\n        buffer.append (TOKENS [(X1 / 10) - 2]);\n\n        X1 %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        X1 %= 20;\n\n    }\n\n    if (X1 != 0) {\n\n        if (tensFound) {\n\n            buffer.append (UNION_SEPARATOR);\n\n        }\n\n        buffer.append (unitProcessor.getName (X1));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41602, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (high);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! \"\".X1 (highName)) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".X1 (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".X1 (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41701, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = X1.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = X1.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number >= 20) {\n\n        buffer.append (TOKENS [(number / 10) - 2]);\n\n        number %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        number %= 20;\n\n    }\n\n    if (number != 0) {\n\n        if (tensFound) {\n\n            buffer.append (UNION_SEPARATOR);\n\n        }\n\n        buffer.append (unitProcessor.getName (number));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41702, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String X1 = null;\n\n    if (0 <= decimals) {\n\n        X1 = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (\"\".equals (name)) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == X1 || \"\".equals (X1))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < X1.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (X1.equals (zeroDecimalValue)) {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- X1.length ()));\n\n        } else {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (X1)).concat (SEPARATOR).concat (SCALE.getName (- X1.length ()));\n\n        }\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 41801, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (value.isEmpty ()) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.X1 (unitProcessor.getName (number / 100));\n\n        buffer.X1 (SEPARATOR);\n\n        buffer.X1 (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (number % 100);\n\n    if (! tensName.isEmpty () && (number >= 100)) {\n\n        buffer.X1 (SEPARATOR);\n\n    }\n\n    buffer.X1 (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41802, "func": "public X1 getName (X1 value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    X1 high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    X1 highName = getHighProcessor ().getName (high);\n\n    X1 lowName = getLowProcessor ().getName (low);\n\n    if (! highName.isEmpty ()) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! lowName.isEmpty ()) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! lowName.isEmpty ()) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41901, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (value.isEmpty ()) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.append (unitProcessor.getName (number / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String X1 = tensProcessor.getName (number % 100);\n\n    if (! X1.isEmpty () && (number >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (X1);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 41902, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (name.isEmpty ()) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (X1).concat (name);\n\n    }\n\n    if (! (null == decimalValue || decimalValue.isEmpty ())) {\n\n        name = name.concat (X1).concat (UNION_AND).concat (X1).concat (processor.getName (decimalValue)).concat (X1).concat (SCALE.getName (- decimalValue.length ()));\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 42001, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int X1;\n\n    if (value.isEmpty ()) {\n\n        X1 = 0;\n\n    } else if (value.length () > 4) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 1000;\n\n    if (X1 >= 100) {\n\n        buffer.append (unitProcessor.getName (X1 / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (X1 % 100);\n\n    if (! tensName.isEmpty () && (X1 >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42002, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int offset = NO_VALUE;\n\n    int X1;\n\n    if (value.length () > 3) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 100;\n\n    if (X1 < 10) {\n\n        offset = (X1 % 10) - 1;\n\n    } else if (X1 < 20) {\n\n        offset = (X1 % 20) - 1;\n\n    }\n\n    if (offset != NO_VALUE && offset < TOKENS.length) {\n\n        buffer.append (TOKENS [offset]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 4201, "func": "public static void main (String args []) {\n\n    Scanner in = new Scanner (System.in);\n\n    System.out.print (\"give us an integer < 4000: \");\n\n    System.out.println (\"the roman numeral version is: \" + X1 (in.nextInt ()));\n\n    for (int i = 1;\n\n    i <= 3999; i ++) {\n\n        System.out.println (i + \" === \" + X1 (i));\n\n    }\n\n}\n"}
{"idx": 4202, "func": "public static void main (String [] args) {\n\n    int number = 2345;\n\n    number = Math.min (3999, Math.max (1, number));\n\n    String asRomanNumerals = \"\";\n\n    String [] RN = {\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"};\n\n    int X1 = 0;\n\n    while (number > 0) {\n\n        switch (number % 10) {\n\n            case 1 :\n\n                asRomanNumerals = RN [X1] + asRomanNumerals;\n\n                break;\n\n            case 2 :\n\n                asRomanNumerals = RN [X1] + RN [X1] + asRomanNumerals;\n\n                break;\n\n            case 3 :\n\n                asRomanNumerals = RN [X1] + RN [X1] + RN [X1] + asRomanNumerals;\n\n                break;\n\n            case 4 :\n\n                asRomanNumerals = RN [X1] + RN [X1 + 1] + asRomanNumerals;\n\n                break;\n\n            case 5 :\n\n                asRomanNumerals = RN [X1 + 1] + asRomanNumerals;\n\n                break;\n\n            case 6 :\n\n                asRomanNumerals = RN [X1 + 1] + RN [X1] + asRomanNumerals;\n\n                break;\n\n            case 7 :\n\n                asRomanNumerals = RN [X1 + 1] + RN [X1] + RN [X1] + asRomanNumerals;\n\n                break;\n\n            case 8 :\n\n                asRomanNumerals = RN [X1 + 1] + RN [X1] + RN [X1] + RN [X1] + asRomanNumerals;\n\n                break;\n\n            case 9 :\n\n                asRomanNumerals = RN [X1] + RN [X1 + 2] + asRomanNumerals;\n\n                break;\n\n        }\n\n        number = (int) number / 10;\n\n        X1 += 2;\n\n    }\n\n    System.out.println (asRomanNumerals);\n\n}\n"}
{"idx": 42101, "func": "public String getName (String value) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    int number;\n\n    if (value.isEmpty ()) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        X1.append (unitProcessor.getName (number / 100));\n\n        X1.append (SEPARATOR);\n\n        X1.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (number % 100);\n\n    if (! tensName.isEmpty () && (number >= 100)) {\n\n        X1.append (SEPARATOR);\n\n    }\n\n    X1.append (tensName);\n\n    return X1.toString ();\n\n}\n"}
{"idx": 42102, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number >= 20) {\n\n        buffer.X1 (TOKENS [(number / 10) - 2]);\n\n        number %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        number %= 20;\n\n    }\n\n    if (number != 0) {\n\n        if (tensFound) {\n\n            buffer.X1 (UNION_SEPARATOR);\n\n        }\n\n        buffer.X1 (unitProcessor.getName (number));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42201, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (value.isEmpty ()) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.X1 (unitProcessor.getName (number / 100));\n\n        buffer.X1 (SEPARATOR);\n\n        buffer.X1 (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (number % 100);\n\n    if (! tensName.isEmpty () && (number >= 100)) {\n\n        buffer.X1 (SEPARATOR);\n\n    }\n\n    buffer.X1 (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42202, "func": "public X1 getName (X1 value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    X1 high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    X1 highName = getHighProcessor ().getName (high);\n\n    X1 lowName = getLowProcessor ().getName (low);\n\n    if (! \"\".equals (highName)) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".equals (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".equals (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42301, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (value.isEmpty ()) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.append (unitProcessor.getName (number / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String X1 = tensProcessor.getName (number % 100);\n\n    if (! X1.isEmpty () && (number >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (X1);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42302, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String X1 = null;\n\n    if (0 <= decimals) {\n\n        X1 = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (\"\".equals (name)) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == X1 || \"\".equals (X1))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < X1.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (X1.equals (zeroDecimalValue)) {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- X1.length ()));\n\n        } else {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (X1)).concat (SEPARATOR).concat (SCALE.getName (- X1.length ()));\n\n        }\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 42401, "func": "public String X1 (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().X1 (high);\n\n    String lowName = getLowProcessor ().X1 (low);\n\n    if (! highName.isEmpty ()) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! lowName.isEmpty ()) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! lowName.isEmpty ()) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42402, "func": "public String getName (String value) {\n\n    boolean X1 = false;\n\n    if (value.startsWith (\"-\")) {\n\n        X1 = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (name.isEmpty ()) {\n\n        name = ZERO_TOKEN;\n\n    } else if (X1) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == decimalValue || decimalValue.isEmpty ())) {\n\n        name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 42501, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.length () < X1 ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - X1 ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (high);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! highName.isEmpty ()) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! lowName.isEmpty ()) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! lowName.isEmpty ()) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42502, "func": "public String getName (String value) {\n\n    X1 buffer = new X1 ();\n\n    int offset = NO_VALUE;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number < 10) {\n\n        offset = (number % 10) - 1;\n\n    } else if (number < 20) {\n\n        offset = (number % 20) - 1;\n\n    }\n\n    if (offset != NO_VALUE && offset < TOKENS.length) {\n\n        buffer.append (TOKENS [offset]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42601, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String X1, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        X1 = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        X1 = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (X1);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! highName.isEmpty ()) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! lowName.isEmpty ()) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! lowName.isEmpty ()) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42602, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int X1;\n\n    if (value.length () > 3) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 100;\n\n    if (X1 >= 20) {\n\n        buffer.append (TOKENS [(X1 / 10) - 2]);\n\n        X1 %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        X1 %= 20;\n\n    }\n\n    if (X1 != 0) {\n\n        if (tensFound) {\n\n            buffer.append (UNION_SEPARATOR);\n\n        }\n\n        buffer.append (unitProcessor.getName (X1));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42701, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, X1;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        X1 = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        X1 = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (high);\n\n    String lowName = getLowProcessor ().getName (X1);\n\n    if (! highName.isEmpty ()) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! lowName.isEmpty ()) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! lowName.isEmpty ()) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42702, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (\"\".equals (value)) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.append (unitProcessor.getName (number / 100));\n\n        buffer.append (X1);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (number % 100);\n\n    if (! \"\".equals (tensName) && (number >= 100)) {\n\n        buffer.append (X1);\n\n    }\n\n    buffer.append (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42801, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.X1 () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.X1 () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (high);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! highName.isEmpty ()) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! lowName.isEmpty ()) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! lowName.isEmpty ()) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 42802, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String X1 = processor.getName (value);\n\n    if (\"\".equals (X1)) {\n\n        X1 = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        X1 = MINUS.concat (SEPARATOR).concat (X1);\n\n    }\n\n    if (! (null == decimalValue || \"\".equals (decimalValue))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < decimalValue.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (decimalValue.equals (zeroDecimalValue)) {\n\n            X1 = X1.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        } else {\n\n            X1 = X1.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 42901, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (name.isEmpty ()) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (X1).concat (name);\n\n    }\n\n    if (! (null == decimalValue || decimalValue.isEmpty ())) {\n\n        name = name.concat (X1).concat (UNION_AND).concat (X1).concat (processor.getName (decimalValue)).concat (X1).concat (SCALE.getName (- decimalValue.length ()));\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 42902, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int offset = NO_VALUE;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number < 10) {\n\n        offset = (number % 10) - 1;\n\n    } else if (number < 20) {\n\n        offset = (number % 20) - 1;\n\n    }\n\n    if (offset != NO_VALUE && offset < X1.length) {\n\n        buffer.append (X1 [offset]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 43001, "func": "public X1 getName (X1 value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    X1 decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    X1 name = processor.getName (value);\n\n    if (name.isEmpty ()) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == decimalValue || decimalValue.isEmpty ())) {\n\n        name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 43002, "func": "public String getName (String value) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number >= 20) {\n\n        X1.append (TOKENS [(number / 10) - 2]);\n\n        number %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        number %= 20;\n\n    }\n\n    if (number != 0) {\n\n        if (tensFound) {\n\n            X1.append (UNION_SEPARATOR);\n\n        }\n\n        X1.append (unitProcessor.getName (number));\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 4301, "func": "public int sum13 (int [] nums) {\n\n    int sum = 0;\n\n    boolean X1 = false;\n\n    for (int num : nums) {\n\n        if (num == 13) {\n\n            X1 = true;\n\n        } else {\n\n            if (! X1) {\n\n                sum += num;\n\n            }\n\n            X1 = false;\n\n        }\n\n    }\n\n    return sum;\n\n}\n"}
{"idx": 4302, "func": "public int sum13 (int [] nums) {\n\n    int sum = 0;\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        if (nums [X1] != 13) {\n\n            sum += nums [X1];\n\n        } else {\n\n            X1 ++;\n\n        }\n\n    }\n\n    return sum;\n\n}\n"}
{"idx": 43101, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String X1 = null;\n\n    if (0 <= decimals) {\n\n        X1 = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (name.isEmpty ()) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == X1 || X1.isEmpty ())) {\n\n        name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (X1)).concat (SEPARATOR).concat (SCALE.getName (- X1.length ()));\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 43102, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int X1;\n\n    if (\"\".equals (value)) {\n\n        X1 = 0;\n\n    } else if (value.length () > 4) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 1000;\n\n    if (X1 >= 100) {\n\n        buffer.append (unitProcessor.getName (X1 / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (X1 % 100);\n\n    if (! \"\".equals (tensName) && (X1 >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 43201, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String X1 = processor.getName (value);\n\n    if (X1.isEmpty ()) {\n\n        X1 = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        X1 = MINUS.concat (SEPARATOR).concat (X1);\n\n    }\n\n    if (! (null == decimalValue || decimalValue.isEmpty ())) {\n\n        X1 = X1.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 43202, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String X1, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        X1 = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        X1 = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (X1);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! \"\".equals (highName)) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".equals (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".equals (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 43301, "func": "public String X1 (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.X1 (value);\n\n    if (name.isEmpty ()) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == decimalValue || decimalValue.isEmpty ())) {\n\n        name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.X1 (decimalValue)).concat (SEPARATOR).concat (SCALE.X1 (- decimalValue.length ()));\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 43302, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String X1 = processor.getName (value);\n\n    if (\"\".equals (X1)) {\n\n        X1 = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        X1 = MINUS.concat (SEPARATOR).concat (X1);\n\n    }\n\n    if (! (null == decimalValue || \"\".equals (decimalValue))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < decimalValue.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (decimalValue.equals (zeroDecimalValue)) {\n\n            X1 = X1.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        } else {\n\n            X1 = X1.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 43401, "func": "public static void main (String...args) {\n\n    processor = new DefaultProcessor ();\n\n    long [] values = new long [] {0, 4, 10, 12, 100, 108, 299, 1000, 1003, 2040, 45213, 100000, 100005, 100010, 202020, 202022, 999999, 1000000, 1000001, 10000000, 10000007, 99999999, Long.MAX_VALUE, Long.MIN_VALUE};\n\n    String [] strValues = new String [] {\"0001.2\", \"3.141592\"};\n\n    for (long val : values) {\n\n        System.out.println (val + \" = \" + processor.X1 (val));\n\n    }\n\n    for (String strVal : strValues) {\n\n        System.out.println (strVal + \" = \" + processor.X1 (strVal));\n\n    }\n\n    StringBuilder bigNumber = new StringBuilder ();\n\n    for (int d = 0;\n\n    d < 66; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    bigNumber.append (\".\");\n\n    for (int d = 0;\n\n    d < 26; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    System.out.println (bigNumber.toString () + \" = \" + processor.X1 (bigNumber.toString ()));\n\n}\n"}
{"idx": 43402, "func": "public static void main (String [] args) {\n\n    System.out.X1 (\"Enter Number to convert into words\");\n\n    Scanner sc = new Scanner (System.in);\n\n    long num = sc.nextInt ();\n\n    int rem = 0;\n\n    int i = 0;\n\n    while (num > 0) {\n\n        if (i == 0) {\n\n            rem = (int) (num % 1000);\n\n            printText (rem);\n\n            num = num / 1000;\n\n            i ++;\n\n        } else if (num > 0) {\n\n            rem = (int) (num % 100);\n\n            if (rem > 0) text = denom.values () [i - 1] + \" \" + text;\n\n            printText (rem);\n\n            num = num / 100;\n\n            i ++;\n\n        }\n\n    }\n\n    if (i > 0) System.out.X1 (text);\n\n    else System.out.X1 (\"Zero\");\n\n}\n"}
{"idx": 43501, "func": "public static void main (String...args) {\n\n    processor = new DefaultProcessor ();\n\n    long [] values = new long [] {0, 4, 10, 12, 100, 108, 299, 1000, 1003, 2040, 45213, 100000, 100005, 100010, 202020, 202022, 999999, 1000000, 1000001, 10000000, 10000007, 99999999, Long.MAX_VALUE, Long.MIN_VALUE};\n\n    String [] strValues = new String [] {\"0001.2\", \"3.141592\"};\n\n    for (long val : values) {\n\n        System.out.println (val + \" = \" + processor.getName (val));\n\n    }\n\n    for (String strVal : strValues) {\n\n        System.out.println (strVal + \" = \" + processor.getName (strVal));\n\n    }\n\n    StringBuilder bigNumber = new StringBuilder ();\n\n    for (int X1 = 0;\n\n    X1 < 66; X1 ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    bigNumber.append (\".\");\n\n    for (int X1 = 0;\n\n    X1 < 26; X1 ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    System.out.println (bigNumber.toString () + \" = \" + processor.getName (bigNumber.toString ()));\n\n}\n"}
{"idx": 43502, "func": "public static void main (String [] args) {\n\n    int X1 = 0;\n\n    Scanner s = new Scanner (System.in);\n\n    System.out.print (\"Enter an integer number: \");\n\n    X1 = s.nextInt ();\n\n    if (X1 <= 0) System.out.print (\"Enter numbers greater than 0\");\n\n    else {\n\n        NumberToWord a = new NumberToWord ();\n\n        System.out.print (\"After conversion number in words is :\");\n\n        a.pw ((X1 / 1000000000), \" Hundred\");\n\n        a.pw ((X1 / 10000000) % 100, \" crore\");\n\n        a.pw (((X1 / 100000) % 100), \" lakh\");\n\n        a.pw (((X1 / 1000) % 100), \" thousand\");\n\n        a.pw (((X1 / 100) % 10), \" hundred\");\n\n        a.pw ((X1 % 100), \" \");\n\n    }\n\n}\n"}
{"idx": 43601, "func": "public static void main (String...args) {\n\n    processor = new DefaultProcessor ();\n\n    long [] values = new long [] {0, 4, 10, 12, 100, 108, 299, 1000, 1003, 2040, 45213, 100000, 100005, 100010, 202020, 202022, 999999, 1000000, 1000001, 10000000, 10000007, 99999999, Long.MAX_VALUE, Long.MIN_VALUE};\n\n    String [] strValues = new String [] {\"0001.2\", \"3.141592\"};\n\n    for (long val : values) {\n\n        System.out.X1 (val + \" = \" + processor.getName (val));\n\n    }\n\n    for (String strVal : strValues) {\n\n        System.out.X1 (strVal + \" = \" + processor.getName (strVal));\n\n    }\n\n    StringBuilder bigNumber = new StringBuilder ();\n\n    for (int d = 0;\n\n    d < 66; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    bigNumber.append (\".\");\n\n    for (int d = 0;\n\n    d < 26; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    System.out.X1 (bigNumber.toString () + \" = \" + processor.getName (bigNumber.toString ()));\n\n}\n"}
{"idx": 43602, "func": "public static void main (String [] args) {\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (0));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (9));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (19));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (21));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (28));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (71));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (72));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (80));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (81));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (89));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (90));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (91));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (97));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (100));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (101));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (110));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (120));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (200));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (201));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (232));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (999));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (1000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (1001));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (10000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (10001));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (100000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (2000000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (3000000000L));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (2147483647));\n\n}\n"}
{"idx": 43701, "func": "public static void main (String [] args) {\n\n    System.out.println (\"Enter Number to convert into words\");\n\n    Scanner sc = new Scanner (System.in);\n\n    long X1 = sc.nextInt ();\n\n    int rem = 0;\n\n    int i = 0;\n\n    while (X1 > 0) {\n\n        if (i == 0) {\n\n            rem = (int) (X1 % 1000);\n\n            printText (rem);\n\n            X1 = X1 / 1000;\n\n            i ++;\n\n        } else if (X1 > 0) {\n\n            rem = (int) (X1 % 100);\n\n            if (rem > 0) text = denom.values () [i - 1] + \" \" + text;\n\n            printText (rem);\n\n            X1 = X1 / 100;\n\n            i ++;\n\n        }\n\n    }\n\n    if (i > 0) System.out.println (text);\n\n    else System.out.println (\"Zero\");\n\n}\n"}
{"idx": 43702, "func": "public static void main (String [] args) {\n\n    int n = 0;\n\n    Scanner s = new Scanner (System.in);\n\n    System.out.X1 (\"Enter an integer number: \");\n\n    n = s.nextInt ();\n\n    if (n <= 0) System.out.X1 (\"Enter numbers greater than 0\");\n\n    else {\n\n        NumberToWord a = new NumberToWord ();\n\n        System.out.X1 (\"After conversion number in words is :\");\n\n        a.pw ((n / 1000000000), \" Hundred\");\n\n        a.pw ((n / 10000000) % 100, \" crore\");\n\n        a.pw (((n / 100000) % 100), \" lakh\");\n\n        a.pw (((n / 1000) % 100), \" thousand\");\n\n        a.pw (((n / 100) % 10), \" hundred\");\n\n        a.pw ((n % 100), \" \");\n\n    }\n\n}\n"}
{"idx": 43801, "func": "public static void main (String [] args) {\n\n    System.out.println (\"Enter Number to convert into words\");\n\n    Scanner sc = new Scanner (System.in);\n\n    long num = sc.nextInt ();\n\n    int rem = 0;\n\n    int X1 = 0;\n\n    while (num > 0) {\n\n        if (X1 == 0) {\n\n            rem = (int) (num % 1000);\n\n            printText (rem);\n\n            num = num / 1000;\n\n            X1 ++;\n\n        } else if (num > 0) {\n\n            rem = (int) (num % 100);\n\n            if (rem > 0) text = denom.values () [X1 - 1] + \" \" + text;\n\n            printText (rem);\n\n            num = num / 100;\n\n            X1 ++;\n\n        }\n\n    }\n\n    if (X1 > 0) System.out.println (text);\n\n    else System.out.println (\"Zero\");\n\n}\n"}
{"idx": 43802, "func": "public static void main (String [] args) {\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (0));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (9));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (19));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (21));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (28));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (71));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (72));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (80));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (81));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (89));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (90));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (91));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (97));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (100));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (101));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (110));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (120));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (200));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (201));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (232));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (999));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (1000));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (1001));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (10000));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (10001));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (100000));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (2000000));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (3000000000L));\n\n    System.out.X1 (\"*** \" + FrenchNumberToWords.convert (2147483647));\n\n}\n"}
{"idx": 43901, "func": "public static void main (String [] args) {\n\n    System.out.println (\"Enter Number to convert into words\");\n\n    Scanner sc = new Scanner (System.in);\n\n    long X1 = sc.nextInt ();\n\n    int rem = 0;\n\n    int i = 0;\n\n    while (X1 > 0) {\n\n        if (i == 0) {\n\n            rem = (int) (X1 % 1000);\n\n            printText (rem);\n\n            X1 = X1 / 1000;\n\n            i ++;\n\n        } else if (X1 > 0) {\n\n            rem = (int) (X1 % 100);\n\n            if (rem > 0) text = denom.values () [i - 1] + \" \" + text;\n\n            printText (rem);\n\n            X1 = X1 / 100;\n\n            i ++;\n\n        }\n\n    }\n\n    if (i > 0) System.out.println (text);\n\n    else System.out.println (\"Zero\");\n\n}\n"}
{"idx": 43902, "func": "public static void main (String...args) {\n\n    processor = new DefaultProcessor ();\n\n    long [] values = new long [] {0, 4, 10, 12, 100, 108, 299, 1000, 1003, 2040, 45213, 100000, 100005, 100010, 202020, 202022, 999999, 1000000, 1000001, 10000000, 10000007, 99999999, Long.MAX_VALUE, Long.MIN_VALUE};\n\n    String [] strValues = new String [] {\"0\", \"1.30\", \"0001.00\", \"3.141592\"};\n\n    for (long X1 : values) {\n\n        System.out.println (X1 + \" = \" + processor.getName (X1));\n\n    }\n\n    for (String strVal : strValues) {\n\n        System.out.println (strVal + \" = \" + processor.getName (strVal));\n\n    }\n\n    StringBuilder bigNumber = new StringBuilder ();\n\n    for (int d = 0;\n\n    d < 66; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    bigNumber.append (\".\");\n\n    for (int d = 0;\n\n    d < 26; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    System.out.println (bigNumber.toString () + \" = \" + processor.getName (bigNumber.toString ()));\n\n}\n"}
{"idx": 44001, "func": "public static void main (String [] args) {\n\n    int n = 0;\n\n    X1 s = new X1 (System.in);\n\n    System.out.print (\"Enter an integer number: \");\n\n    n = s.nextInt ();\n\n    if (n <= 0) System.out.print (\"Enter numbers greater than 0\");\n\n    else {\n\n        NumberToWord a = new NumberToWord ();\n\n        System.out.print (\"After conversion number in words is :\");\n\n        a.pw ((n / 1000000000), \" Hundred\");\n\n        a.pw ((n / 10000000) % 100, \" crore\");\n\n        a.pw (((n / 100000) % 100), \" lakh\");\n\n        a.pw (((n / 1000) % 100), \" thousand\");\n\n        a.pw (((n / 100) % 10), \" hundred\");\n\n        a.pw ((n % 100), \" \");\n\n    }\n\n}\n"}
{"idx": 44002, "func": "public static void main (String [] args) {\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (0));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (9));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (19));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (21));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (28));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (71));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (72));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (80));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (81));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (89));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (90));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (91));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (97));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (100));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (101));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (110));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (120));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (200));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (201));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (232));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (999));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (1000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (1001));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (10000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (10001));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (100000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (2000000));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (3000000000L));\n\n    System.out.println (\"*** \" + FrenchNumberToWords.X1 (2147483647));\n\n}\n"}
{"idx": 4401, "func": "public static String output (String [] fourLetter, String [] fiveLetter, String [] sixLetter) {\n\n    String answer = \"\";\n\n    for (int i = 0;\n\n    i < X1.max (X1.max (fourLetter.length, fiveLetter.length), sixLetter.length); i ++) {\n\n        if (sixLetter.length > i) {\n\n            answer += sixLetter [i] + \" \";\n\n        }\n\n        if (fiveLetter.length > i) {\n\n            answer += fiveLetter [i] + \" \";\n\n        }\n\n        if (fourLetter.length > i) {\n\n            answer += fourLetter [i];\n\n        }\n\n        answer += \"\\n\";\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 4402, "func": "public static String output (String [] fourLetter, String [] fiveLetter, String [] sixLetter) {\n\n    String X1 = \"\";\n\n    int count = 1;\n\n    for (int i = 0;\n\n    i < Math.max (Math.max (fourLetter.length, fiveLetter.length), sixLetter.length); i ++) {\n\n        if (sixLetter.length > i) {\n\n            X1 += sixLetter [i] + \" \";\n\n        }\n\n        if (fiveLetter.length > i) {\n\n            X1 += fiveLetter [i] + \" \";\n\n        }\n\n        if (fourLetter.length > i) {\n\n            X1 += fourLetter [i];\n\n        }\n\n        X1 += \"\\n\";\n\n        for (int j = 0;\n\n        j < count; j ++) {\n\n            X1 += \"\\t\";\n\n        }\n\n        count ++;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 44101, "func": "public static void main (String [] args) {\n\n    int n = 0;\n\n    Scanner s = new Scanner (X1.in);\n\n    X1.out.print (\"Enter an integer number: \");\n\n    n = s.nextInt ();\n\n    if (n <= 0) X1.out.print (\"Enter numbers greater than 0\");\n\n    else {\n\n        NumberToWord a = new NumberToWord ();\n\n        X1.out.print (\"After conversion number in words is :\");\n\n        a.pw ((n / 1000000000), \" Hundred\");\n\n        a.pw ((n / 10000000) % 100, \" crore\");\n\n        a.pw (((n / 100000) % 100), \" lakh\");\n\n        a.pw (((n / 1000) % 100), \" thousand\");\n\n        a.pw (((n / 100) % 10), \" hundred\");\n\n        a.pw ((n % 100), \" \");\n\n    }\n\n}\n"}
{"idx": 44102, "func": "public static void main (String...args) {\n\n    processor = new DefaultProcessor ();\n\n    long [] values = new long [] {0, 4, 10, 12, 100, 108, 299, 1000, 1003, 2040, 45213, 100000, 100005, 100010, 202020, 202022, 999999, 1000000, 1000001, 10000000, 10000007, 99999999, Long.MAX_VALUE, Long.MIN_VALUE};\n\n    String [] strValues = new String [] {\"0\", \"1.30\", \"0001.00\", \"3.141592\"};\n\n    for (long val : values) {\n\n        System.out.println (val + \" = \" + processor.getName (val));\n\n    }\n\n    for (String strVal : strValues) {\n\n        System.out.println (strVal + \" = \" + processor.getName (strVal));\n\n    }\n\n    StringBuilder bigNumber = new StringBuilder ();\n\n    for (int d = 0;\n\n    d < 66; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    bigNumber.append (\".\");\n\n    for (int d = 0;\n\n    d < 26; d ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    System.out.println (bigNumber.X1 () + \" = \" + processor.getName (bigNumber.X1 ()));\n\n}\n"}
{"idx": 44201, "func": "public static void main (String [] args) {\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (0));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (9));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (19));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (21));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (28));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (71));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (72));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (80));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (81));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (89));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (90));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (91));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (97));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (100));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (101));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (110));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (120));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (200));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (201));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (232));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (999));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (1000));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (1001));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (10000));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (10001));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (100000));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (2000000));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (3000000000L));\n\n    System.X1.println (\"*** \" + FrenchNumberToWords.convert (2147483647));\n\n}\n"}
{"idx": 44202, "func": "public static void main (String...args) {\n\n    processor = new DefaultProcessor ();\n\n    long [] values = new long [] {0, 4, 10, 12, 100, 108, 299, 1000, 1003, 2040, 45213, 100000, 100005, 100010, 202020, 202022, 999999, 1000000, 1000001, 10000000, 10000007, 99999999, Long.MAX_VALUE, Long.MIN_VALUE};\n\n    String [] strValues = new String [] {\"0\", \"1.30\", \"0001.00\", \"3.141592\"};\n\n    for (long val : values) {\n\n        System.out.println (val + \" = \" + processor.getName (val));\n\n    }\n\n    for (String strVal : strValues) {\n\n        System.out.println (strVal + \" = \" + processor.getName (strVal));\n\n    }\n\n    StringBuilder bigNumber = new StringBuilder ();\n\n    for (int X1 = 0;\n\n    X1 < 66; X1 ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    bigNumber.append (\".\");\n\n    for (int X1 = 0;\n\n    X1 < 26; X1 ++) {\n\n        bigNumber.append ((char) ((Math.random () * 10) + '0'));\n\n    }\n\n    System.out.println (bigNumber.toString () + \" = \" + processor.getName (bigNumber.toString ()));\n\n}\n"}
{"idx": 44301, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int offset = X1;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number < 10) {\n\n        offset = (number % 10) - 1;\n\n    } else if (number < 20) {\n\n        offset = (number % 20) - 1;\n\n    }\n\n    if (offset != X1 && offset < TOKENS.length) {\n\n        buffer.append (TOKENS [offset]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44302, "func": "public String getName (String X1) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (\"\".equals (X1)) {\n\n        number = 0;\n\n    } else if (X1.length () > 4) {\n\n        number = Integer.valueOf (X1.substring (X1.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (X1, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.append (unitProcessor.getName (number / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (number % 100);\n\n    if (! \"\".equals (tensName) && (number >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44401, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int offset = X1;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number < 10) {\n\n        offset = (number % 10) - 1;\n\n    } else if (number < 20) {\n\n        offset = (number % 20) - 1;\n\n    }\n\n    if (offset != X1 && offset < TOKENS.length) {\n\n        buffer.append (TOKENS [offset]);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44402, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String X1, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        X1 = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        X1 = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().getName (X1);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! \"\".equals (highName)) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".equals (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".equals (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44501, "func": "public String getName (String value) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    int offset = NO_VALUE;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number < 10) {\n\n        offset = (number % 10) - 1;\n\n    } else if (number < 20) {\n\n        offset = (number % 20) - 1;\n\n    }\n\n    if (offset != NO_VALUE && offset < TOKENS.length) {\n\n        X1.append (TOKENS [offset]);\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 44502, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.X1 (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.X1 (decimals + 1);\n\n        value = value.X1 (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (\"\".equals (name)) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == decimalValue || \"\".equals (decimalValue))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < decimalValue.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (decimalValue.equals (zeroDecimalValue)) {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        } else {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        }\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 44601, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int number;\n\n    if (value.X1 () > 3) {\n\n        number = Integer.valueOf (value.substring (value.X1 () - 3), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number >= 20) {\n\n        buffer.append (TOKENS [(number / 10) - 2]);\n\n        number %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        number %= 20;\n\n    }\n\n    if (number != 0) {\n\n        if (tensFound) {\n\n            buffer.append (UNION_SEPARATOR);\n\n        }\n\n        buffer.append (unitProcessor.getName (number));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44602, "func": "public String getName (String X1) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (\"\".equals (X1)) {\n\n        number = 0;\n\n    } else if (X1.length () > 4) {\n\n        number = Integer.valueOf (X1.substring (X1.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (X1, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.append (unitProcessor.getName (number / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (number % 100);\n\n    if (! \"\".equals (tensName) && (number >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44701, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int X1;\n\n    if (value.length () > 3) {\n\n        X1 = Integer.valueOf (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        X1 = Integer.valueOf (value, 10);\n\n    }\n\n    X1 %= 100;\n\n    if (X1 >= 20) {\n\n        buffer.append (TOKENS [(X1 / 10) - 2]);\n\n        X1 %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        X1 %= 20;\n\n    }\n\n    if (X1 != 0) {\n\n        if (tensFound) {\n\n            buffer.append (UNION_SEPARATOR);\n\n        }\n\n        buffer.append (unitProcessor.getName (X1));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44702, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String X1 = getHighProcessor ().getName (high);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! \"\".equals (X1)) {\n\n        buffer.append (X1);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".equals (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".equals (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44801, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    boolean tensFound = false;\n\n    int number;\n\n    if (value.length () > 3) {\n\n        number = Integer.X1 (value.substring (value.length () - 3), 10);\n\n    } else {\n\n        number = Integer.X1 (value, 10);\n\n    }\n\n    number %= 100;\n\n    if (number >= 20) {\n\n        buffer.append (TOKENS [(number / 10) - 2]);\n\n        number %= 10;\n\n        tensFound = true;\n\n    } else {\n\n        number %= 20;\n\n    }\n\n    if (number != 0) {\n\n        if (tensFound) {\n\n            buffer.append (UNION_SEPARATOR);\n\n        }\n\n        buffer.append (unitProcessor.getName (number));\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44802, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (\"\".equals (name)) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == decimalValue || \"\".equals (decimalValue))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < decimalValue.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (decimalValue.equals (zeroDecimalValue)) {\n\n            name = name.concat (SEPARATOR).concat (X1).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        } else {\n\n            name = name.concat (SEPARATOR).concat (X1).concat (SEPARATOR).concat (processor.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        }\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 44901, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (\"\".equals (value)) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.append (unitProcessor.getName (number / 100));\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (SCALE.getName (EXPONENT));\n\n    }\n\n    String X1 = tensProcessor.getName (number % 100);\n\n    if (! \"\".equals (X1) && (number >= 100)) {\n\n        buffer.append (SEPARATOR);\n\n    }\n\n    buffer.append (X1);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 44902, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int X1 = value.length () - getPartDivider ();\n\n        high = value.substring (0, X1);\n\n        low = value.substring (X1);\n\n    }\n\n    String highName = getHighProcessor ().getName (high);\n\n    String lowName = getLowProcessor ().getName (low);\n\n    if (! \"\".equals (highName)) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".equals (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".equals (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 45001, "func": "public String getName (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    int number;\n\n    if (\"\".equals (value)) {\n\n        number = 0;\n\n    } else if (value.length () > 4) {\n\n        number = Integer.valueOf (value.substring (value.length () - 4), 10);\n\n    } else {\n\n        number = Integer.valueOf (value, 10);\n\n    }\n\n    number %= 1000;\n\n    if (number >= 100) {\n\n        buffer.X1 (unitProcessor.getName (number / 100));\n\n        buffer.X1 (SEPARATOR);\n\n        buffer.X1 (SCALE.getName (EXPONENT));\n\n    }\n\n    String tensName = tensProcessor.getName (number % 100);\n\n    if (! \"\".equals (tensName) && (number >= 100)) {\n\n        buffer.X1 (SEPARATOR);\n\n    }\n\n    buffer.X1 (tensName);\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 45002, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String decimalValue = null;\n\n    if (0 <= decimals) {\n\n        decimalValue = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = X1.getName (value);\n\n    if (\"\".equals (name)) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == decimalValue || \"\".equals (decimalValue))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < decimalValue.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (decimalValue.equals (zeroDecimalValue)) {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        } else {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (X1.getName (decimalValue)).concat (SEPARATOR).concat (SCALE.getName (- decimalValue.length ()));\n\n        }\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 4501, "func": "public void start (Stage stage) throws Exception {\n\n    StackPane X1 = new StackPane ();\n\n    X1.setPrefSize (20, 20);\n\n    X1.setMaxSize (Region.USE_PREF_SIZE, Region.USE_PREF_SIZE);\n\n    X1.setStyle (\"-fx-background-color: purple;\");\n\n    StackPane rootPane = new StackPane (X1);\n\n    rootPane.setPrefSize (400, 400);\n\n    StackPane.setAlignment (X1, Pos.BOTTOM_CENTER);\n\n    stage.setScene (new Scene (rootPane));\n\n    stage.show ();\n\n    StackPane stickyNotesPane = new StackPane ();\n\n    stickyNotesPane.setPrefSize (200, 200);\n\n    stickyNotesPane.setStyle (\"-fx-background-color: yellow;\");\n\n    Popup popup = new Popup ();\n\n    popup.getContent ().add (stickyNotesPane);\n\n    X1.hoverProperty ().addListener ((obs, oldVal, newValue) -> {\n\n        if (newValue) {\n\n            Bounds bnds = X1.localToScreen (X1.getLayoutBounds ());\n\n            double x = bnds.getMinX () - (stickyNotesPane.getWidth () / 2) + (X1.getWidth () / 2);\n\n            double y = bnds.getMinY () - stickyNotesPane.getHeight ();\n\n            popup.show (X1, x, y);\n\n        } else {\n\n            popup.hide ();\n\n        }\n\n    });\n\n}\n"}
{"idx": 4502, "func": "public void start (Stage stage) throws Exception {\n\n    StackPane notedPane = new StackPane ();\n\n    notedPane.setPrefSize (20, 20);\n\n    notedPane.setMaxSize (Region.USE_PREF_SIZE, Region.USE_PREF_SIZE);\n\n    notedPane.setStyle (\"-fx-background-color: purple;\");\n\n    StackPane X1 = new StackPane (notedPane);\n\n    X1.setPrefSize (400, 400);\n\n    StackPane.setAlignment (notedPane, Pos.BOTTOM_CENTER);\n\n    stage.setScene (new Scene (X1));\n\n    stage.show ();\n\n    Stage stickyNotesStage = new Stage ();\n\n    stickyNotesStage.initOwner (stage);\n\n    stickyNotesStage.initStyle (StageStyle.UNDECORATED);\n\n    StackPane stickyNotesPane = new StackPane ();\n\n    stickyNotesPane.setPrefSize (200, 200);\n\n    stickyNotesPane.setStyle (\"-fx-background-color: yellow;\");\n\n    stickyNotesStage.setScene (new Scene (stickyNotesPane));\n\n    notedPane.hoverProperty ().addListener ((ChangeListener < Boolean >) (observable, oldValue, newValue) -> {\n\n        if (newValue) {\n\n            stickyNotesStage.show ();\n\n        } else {\n\n            stickyNotesStage.hide ();\n\n        }\n\n    });\n\n}\n"}
{"idx": 45101, "func": "public String X1 (String value) {\n\n    StringBuilder buffer = new StringBuilder ();\n\n    String high, low;\n\n    if (value.length () < getPartDivider ()) {\n\n        high = \"\";\n\n        low = value;\n\n    } else {\n\n        int index = value.length () - getPartDivider ();\n\n        high = value.substring (0, index);\n\n        low = value.substring (index);\n\n    }\n\n    String highName = getHighProcessor ().X1 (high);\n\n    String lowName = getLowProcessor ().X1 (low);\n\n    if (! \"\".equals (highName)) {\n\n        buffer.append (highName);\n\n        buffer.append (SEPARATOR);\n\n        buffer.append (getToken ());\n\n        if (! \"\".equals (lowName)) {\n\n            buffer.append (SEPARATOR);\n\n        }\n\n    }\n\n    if (! \"\".equals (lowName)) {\n\n        buffer.append (lowName);\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 45102, "func": "public String getName (String value) {\n\n    boolean negative = false;\n\n    if (value.startsWith (\"-\")) {\n\n        negative = true;\n\n        value = value.substring (1);\n\n    }\n\n    int decimals = value.indexOf (\".\");\n\n    String X1 = null;\n\n    if (0 <= decimals) {\n\n        X1 = value.substring (decimals + 1);\n\n        value = value.substring (0, decimals);\n\n    }\n\n    String name = processor.getName (value);\n\n    if (\"\".equals (name)) {\n\n        name = ZERO_TOKEN;\n\n    } else if (negative) {\n\n        name = MINUS.concat (SEPARATOR).concat (name);\n\n    }\n\n    if (! (null == X1 || \"\".equals (X1))) {\n\n        String zeroDecimalValue = \"\";\n\n        for (int i = 0;\n\n        i < X1.length (); i ++) {\n\n            zeroDecimalValue = zeroDecimalValue + \"0\";\n\n        }\n\n        if (X1.equals (zeroDecimalValue)) {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (\"zero\").concat (SEPARATOR).concat (SCALE.getName (- X1.length ()));\n\n        } else {\n\n            name = name.concat (SEPARATOR).concat (UNION_AND).concat (SEPARATOR).concat (processor.getName (X1)).concat (SEPARATOR).concat (SCALE.getName (- X1.length ()));\n\n        }\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 45201, "func": "public static void main (String [] args) {\n\n    System.out.println (\"Enter no of rows to be printed\");\n\n    int row = Integer.parseInt (args [0]);\n\n    int len = args.length;\n\n    if (len <= 0) {\n\n        System.out.println (\" ERROR: Please input a value of 1-5\");\n\n        System.exit (0);\n\n    }\n\n    int j;\n\n    for (int X1 = 0;\n\n    X1 <= row; X1 ++) {\n\n        for (j = 0; j <= X1; j ++) System.out.print (\"*\");\n\n        System.out.println (\"\");\n\n    }\n\n}\n"}
{"idx": 45202, "func": "public static void main (String [] args) {\n\n    int len = args.length;\n\n    if (len == 0) {\n\n        sopl (\"\\n\\tUsage: java echo <args:String[]>\");\n\n        System.exit (0);\n\n    }\n\n    X1 (\"\\n\\t\");\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        X1 (args [i] + \" \");\n\n    }\n\n    X1 (\"\\n\\t\");\n\n    while (len > 0) X1 (args [args.length - len --] + \" \");\n\n    sopl (\"\");\n\n}\n"}
{"idx": 45301, "func": "public static void main (String [] X1) {\n\n    int len = X1.length;\n\n    if (len == 0) {\n\n        sopl (\"\\n\\tUsage: java echo <args:String[]>\");\n\n        System.exit (0);\n\n    }\n\n    sop (\"\\n\\t\");\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        sop (X1 [i] + \" \");\n\n    }\n\n    sop (\"\\n\\t\");\n\n    while (len > 0) sop (X1 [X1.length - len --] + \" \");\n\n    sopl (\"\");\n\n}\n"}
{"idx": 45302, "func": "public static void main (String [] args) {\n\n    int len = args.length;\n\n    if (len <= 0) {\n\n        System.out.println (\" ERROR: Please input a value of 1-5\");\n\n        System.exit (0);\n\n    }\n\n    int j;\n\n    for (int X1 = 0;\n\n    X1 <= len; X1 ++) {\n\n        for (j = 0; j <= X1; j ++) System.out.print (\"*\");\n\n        System.out.println (\"\");\n\n    }\n\n}\n"}
{"idx": 45401, "func": "public static void main (String [] args) throws InterruptedException {\n\n    final AtomicInteger outputCount = new AtomicInteger (0);\n\n    ExecutorService threadPool = Executors.newFixedThreadPool (X1);\n\n    Collection < Callable < Object > > tasks = new ArrayList < > (X1);\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        tasks.add (new Callable < Object > () {\n\n            private SecureRandom rand = new SecureRandom ();\n\n            private String task () {\n\n                return rand.nextDouble () > 0.5 ? Thread.currentThread ().getName () : null;\n\n            }@Override\n\n            public Object call () {\n\n                for (int i;\n\n                (i = outputCount.get ()) < TASKS;) {\n\n                    String output = task ();\n\n                    if (output != null) {\n\n                        if ((i = outputCount.incrementAndGet ()) < TASKS) {\n\n                            System.out.println (output + \": \" + i);\n\n                        }\n\n                    }\n\n                }\n\n                return null;\n\n            }}\n\n        );\n\n    }\n\n    threadPool.invokeAll (tasks);\n\n    threadPool.shutdownNow ();\n\n    System.out.println (\"done\");\n\n}\n"}
{"idx": 45402, "func": "public static void main (String [] args) throws InterruptedException {\n\n    CountDownLatch theLatch = new CountDownLatch (100);\n\n    List < String > X1 = Collections.synchronizedList (new ArrayList < String > ());\n\n    SecureRandom random = new SecureRandom ();\n\n    ExecutorService service = Executors.newCachedThreadPool ();\n\n    for (int i = 0;\n\n    i < 4; i ++) {\n\n        service.execute (new CountDownTask (theLatch, X1, random));\n\n    }\n\n    theLatch.await (1, TimeUnit.MINUTES);\n\n    service.shutdown ();\n\n    System.out.println (X1.size ());\n\n}\n"}
{"idx": 45501, "func": "public static void main (String [] args) throws InterruptedException {\n\n    final AtomicInteger X1 = new AtomicInteger (0);\n\n    ExecutorService threadPool = Executors.newFixedThreadPool (THREADS);\n\n    Collection < Callable < Object > > tasks = new ArrayList < > (THREADS);\n\n    for (int i = 0;\n\n    i < THREADS; i ++) {\n\n        tasks.add (new Callable < Object > () {\n\n            private SecureRandom rand = new SecureRandom ();\n\n            private String task () {\n\n                return rand.nextDouble () > 0.5 ? Thread.currentThread ().getName () : null;\n\n            }@Override\n\n            public Object call () {\n\n                for (int i;\n\n                (i = X1.get ()) < TASKS;) {\n\n                    String output = task ();\n\n                    if (output != null) {\n\n                        if ((i = X1.incrementAndGet ()) < TASKS) {\n\n                            System.out.println (output + \": \" + i);\n\n                        }\n\n                    }\n\n                }\n\n                return null;\n\n            }}\n\n        );\n\n    }\n\n    threadPool.invokeAll (tasks);\n\n    threadPool.shutdownNow ();\n\n    System.out.println (\"done\");\n\n}\n"}
{"idx": 45502, "func": "public static void main (String [] args) throws InterruptedException {\n\n    AtomicInteger counter = new AtomicInteger ();\n\n    ExecutorService pool = Executors.newFixedThreadPool (4);\n\n    for (int X1 = 0;\n\n    X1 < 4; ++ X1) {\n\n        pool.execute (new MyTask (counter));\n\n    }\n\n    pool.shutdown ();\n\n    pool.awaitTermination (1, TimeUnit.HOURS);\n\n}\n"}
{"idx": 45601, "func": "public static void main (String [] args) throws InterruptedException {\n\n    final AtomicInteger outputCount = new AtomicInteger (0);\n\n    ExecutorService threadPool = Executors.newFixedThreadPool (THREADS);\n\n    Collection < Callable < Object > > tasks = new ArrayList < > (THREADS);\n\n    for (int i = 0;\n\n    i < THREADS; i ++) {\n\n        tasks.add (new Callable < Object > () {\n\n            private SecureRandom rand = new SecureRandom ();\n\n            private String task () {\n\n                return rand.nextDouble () > 0.5 ? Thread.currentThread ().getName () : null;\n\n            }@Override\n\n            public Object call () {\n\n                for (int i;\n\n                (i = outputCount.get ()) < TASKS;) {\n\n                    String output = task ();\n\n                    if (output != null) {\n\n                        if ((i = outputCount.incrementAndGet ()) < TASKS) {\n\n                            System.out.X1 (output + \": \" + i);\n\n                        }\n\n                    }\n\n                }\n\n                return null;\n\n            }}\n\n        );\n\n    }\n\n    threadPool.invokeAll (tasks);\n\n    threadPool.shutdownNow ();\n\n    System.out.X1 (\"done\");\n\n}\n"}
{"idx": 45602, "func": "public static void main (String [] args) throws InterruptedException {\n\n    BlockingQueue < Object > expensiveObjects = new LinkedBlockingQueue < > ();\n\n    expensiveObjects.put (new Object ());\n\n    expensiveObjects.put (new Object ());\n\n    expensiveObjects.put (new Object ());\n\n    expensiveObjects.put (new Object ());\n\n    ExecutorService X1 = Executors.newFixedThreadPool (4);\n\n    for (int i = 0;\n\n    i < 4; i ++) {\n\n        X1.execute (new MyRunnable (expensiveObjects));\n\n    }\n\n    X1.shutdown ();\n\n    X1.awaitTermination (5, TimeUnit.SECONDS);\n\n    System.out.println (\"Final: \" + outputCount.get ());\n\n}\n"}
{"idx": 45701, "func": "public static void main (X1 [] args) throws InterruptedException {\n\n    CountDownLatch theLatch = new CountDownLatch (100);\n\n    List < X1 > output = Collections.synchronizedList (new ArrayList < X1 > ());\n\n    SecureRandom random = new SecureRandom ();\n\n    ExecutorService service = Executors.newCachedThreadPool ();\n\n    for (int i = 0;\n\n    i < 4; i ++) {\n\n        service.execute (new CountDownTask (theLatch, output, random));\n\n    }\n\n    theLatch.await (1, TimeUnit.MINUTES);\n\n    service.shutdown ();\n\n    System.out.println (output.size ());\n\n}\n"}
{"idx": 45702, "func": "public static void main (String [] args) throws InterruptedException {\n\n    X1 counter = new X1 ();\n\n    ExecutorService pool = Executors.newFixedThreadPool (4);\n\n    for (int i = 0;\n\n    i < 4; ++ i) {\n\n        pool.execute (new MyTask (counter));\n\n    }\n\n    pool.shutdown ();\n\n    pool.awaitTermination (1, TimeUnit.HOURS);\n\n}\n"}
{"idx": 45801, "func": "public static void main (X1 [] args) throws InterruptedException {\n\n    CountDownLatch theLatch = new CountDownLatch (100);\n\n    List < X1 > output = Collections.synchronizedList (new ArrayList < X1 > ());\n\n    SecureRandom random = new SecureRandom ();\n\n    ExecutorService service = Executors.newCachedThreadPool ();\n\n    for (int i = 0;\n\n    i < 4; i ++) {\n\n        service.execute (new CountDownTask (theLatch, output, random));\n\n    }\n\n    theLatch.await (1, TimeUnit.MINUTES);\n\n    service.shutdown ();\n\n    System.out.println (output.size ());\n\n}\n"}
{"idx": 45802, "func": "public static void main (String [] args) throws InterruptedException {\n\n    BlockingQueue < X1 > expensiveObjects = new LinkedBlockingQueue < > ();\n\n    expensiveObjects.put (new X1 ());\n\n    expensiveObjects.put (new X1 ());\n\n    expensiveObjects.put (new X1 ());\n\n    expensiveObjects.put (new X1 ());\n\n    ExecutorService executorService = Executors.newFixedThreadPool (4);\n\n    for (int i = 0;\n\n    i < 4; i ++) {\n\n        executorService.execute (new MyRunnable (expensiveObjects));\n\n    }\n\n    executorService.shutdown ();\n\n    executorService.awaitTermination (5, TimeUnit.SECONDS);\n\n    System.out.println (\"Final: \" + outputCount.get ());\n\n}\n"}
{"idx": 45901, "func": "public void run () {\n\n    while (true) {\n\n        String X1 = task ();\n\n        if (X1 != null) {\n\n            int count = counter.getAndIncrement ();\n\n            System.out.println (X1);\n\n            if (count >= 100) {\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 45902, "func": "public void run () {\n\n    while (true) {\n\n        try {\n\n            Object X1 = expensiveObjects.take ();\n\n            String output = task ();\n\n            expensiveObjects.put (X1);\n\n            if (output != null) {\n\n                int counter = outputCount.getAndIncrement ();\n\n                System.out.println (counter);\n\n                if (counter >= 100) {\n\n                    break;\n\n                }\n\n            }\n\n        } catch (InterruptedException e) {\n\n            System.out.println (\"Error!\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 46001, "func": "public static void main (String [] args) throws InterruptedException {\n\n    AtomicInteger counter = new AtomicInteger ();\n\n    ExecutorService X1 = Executors.newFixedThreadPool (4);\n\n    for (int i = 0;\n\n    i < 4; ++ i) {\n\n        X1.execute (new MyTask (counter));\n\n    }\n\n    X1.shutdown ();\n\n    X1.awaitTermination (1, TimeUnit.HOURS);\n\n}\n"}
{"idx": 46002, "func": "public static void main (String [] args) throws InterruptedException {\n\n    BlockingQueue < Object > expensiveObjects = new LinkedBlockingQueue < > ();\n\n    expensiveObjects.put (new Object ());\n\n    expensiveObjects.put (new Object ());\n\n    expensiveObjects.put (new Object ());\n\n    expensiveObjects.put (new Object ());\n\n    ExecutorService X1 = Executors.newFixedThreadPool (4);\n\n    for (int i = 0;\n\n    i < 4; i ++) {\n\n        X1.execute (new MyRunnable (expensiveObjects));\n\n    }\n\n    X1.shutdown ();\n\n    X1.awaitTermination (5, TimeUnit.SECONDS);\n\n    System.out.println (\"Final: \" + outputCount.get ());\n\n}\n"}
{"idx": 4601, "func": "boolean hasLoop (X1 first) {\n\n    if (first == null) return false;\n\n    X1 turtle = first;\n\n    X1 hare = first;\n\n    while (hare.next != null && hare.next.next != null) {\n\n        turtle = turtle.next;\n\n        hare = hare.next.next;\n\n        if (turtle == hare) return true;\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 4602, "func": "public static boolean hasLoop (Node X1) {\n\n    if (X1 == null) return false;\n\n    Node slow = X1, fast = X1;\n\n    int taken = 0, limit = 2;\n\n    while (fast.next != null) {\n\n        fast = fast.next;\n\n        taken ++;\n\n        if (slow == fast) return true;\n\n        if (taken == limit) {\n\n            taken = 0;\n\n            limit <<= 1;\n\n            slow = fast;\n\n        }\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 46101, "func": "public static byte [] hash (char [] password, byte [] salt) {\n\n    PBEKeySpec spec = new PBEKeySpec (password, salt, ITERATIONS, KEY_LENGTH);\n\n    Arrays.fill (password, Character.MIN_VALUE);\n\n    try {\n\n        SecretKeyFactory X1 = SecretKeyFactory.getInstance (\"PBKDF2WithHmacSHA1\");\n\n        return X1.generateSecret (spec).getEncoded ();\n\n    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n\n        throw new AssertionError (\"Error while hashing a password: \" + e.getMessage (), e);\n\n    } finally {\n\n        spec.clearPassword ();\n\n    }\n\n}\n"}
{"idx": 46102, "func": "public byte [] hash (String password, byte [] salt) {\n\n    Validate.notNull (password, \"Password must not be null\");\n\n    Validate.notNull (salt, \"Salt must not be null\");\n\n    try {\n\n        final byte [] X1 = password.getBytes (\"UTF-8\");\n\n        final byte [] all = ArrayUtils.addAll (X1, salt);\n\n        SHA3.DigestSHA3 md = new SHA3.Digest512 ();\n\n        md.update (all);\n\n        return md.digest ();\n\n    } catch (UnsupportedEncodingException e) {\n\n        final String message = String.format (\"Caught UnsupportedEncodingException e: <%s>\", e.getMessage ());\n\n        LOGGER.error (message);\n\n    }\n\n    return new byte [0];\n\n}\n"}
{"idx": 46201, "func": "public static boolean isExpectedPassword (char [] password, byte [] salt, byte [] X1) {\n\n    byte [] pwdHash = hash (password, salt);\n\n    Arrays.fill (password, Character.MIN_VALUE);\n\n    if (pwdHash.length != X1.length) return false;\n\n    for (int i = 0;\n\n    i < pwdHash.length; i ++) {\n\n        if (pwdHash [i] != X1 [i]) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 46202, "func": "public boolean isExpectedPassword (final String password, final byte [] salt, final byte [] hash) {\n\n    Validate.notNull (password, \"Password must not be null\");\n\n    Validate.notNull (salt, \"Salt must not be null\");\n\n    Validate.notNull (hash, \"Hash must not be null\");\n\n    try {\n\n        final byte [] passwordBytes = password.getBytes (\"UTF-8\");\n\n        final byte [] all = ArrayUtils.addAll (passwordBytes, salt);\n\n        SHA3.DigestSHA3 X1 = new SHA3.Digest512 ();\n\n        X1.update (all);\n\n        final byte [] digest = X1.digest ();\n\n        return Arrays.equals (digest, hash);\n\n    } catch (UnsupportedEncodingException e) {\n\n        final String message = String.format (\"Caught UnsupportedEncodingException e: <%s>\", e.getMessage ());\n\n        LOGGER.error (message);\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 46301, "func": "public static String generateRandomPassword (int X1) {\n\n    StringBuilder sb = new StringBuilder (X1);\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        int c = RANDOM.nextInt (62);\n\n        if (c <= 9) {\n\n            sb.append (String.valueOf (c));\n\n        } else if (c < 36) {\n\n            sb.append ((char) ('a' + c - 10));\n\n        } else {\n\n            sb.append ((char) ('A' + c - 36));\n\n        }\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 46302, "func": "public String generateRandomPassword (final int X1) {\n\n    if (X1 < 1) {\n\n        throw new IllegalArgumentException (\"length must be greater than 0\");\n\n    }\n\n    final char [] buf = new char [X1];\n\n    for (int idx = 0;\n\n    idx < buf.X1; ++ idx) {\n\n        buf [idx] = symbols [RANDOM.nextInt (symbols.X1)];\n\n    }\n\n    return shuffle (new String (buf));\n\n}\n"}
{"idx": 46401, "func": "public static void main (String [] args) throws URISyntaxException, IOException {\n\n    URI X1 = ResourceWalker.class.getResource (\"/resources\").toURI ();\n\n    Path myPath;\n\n    if (X1.getScheme ().equals (\"jar\")) {\n\n        FileSystem fileSystem = FileSystems.newFileSystem (X1, Collections.< String, Object > emptyMap ());\n\n        myPath = fileSystem.getPath (\"/resources\");\n\n    } else {\n\n        myPath = Paths.get (X1);\n\n    }\n\n    Stream < Path > walk = Files.walk (myPath, 1);\n\n    for (Iterator < Path > it = walk.iterator ();\n\n    it.hasNext ();) {\n\n        System.out.println (it.next ());\n\n    }\n\n}\n"}
{"idx": 46402, "func": "public static void main (String [] args) throws URISyntaxException, X1 {\n\n    URI uri = ResourceWalker.class.getResource (\"/resources\").toURI ();\n\n    System.out.println (\"Starting from: \" + uri);\n\n    try (FileSystem fileSystem = (uri.getScheme ().equals (\"jar\") ? FileSystems.newFileSystem (uri, Collections.< String, Object > emptyMap ()) : null)) {\n\n        Path myPath = Paths.get (uri);\n\n        Files.walkFileTree (myPath, new SimpleFileVisitor < Path > () {\n\n            @Override\n\n            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws X1 {\n\n                System.out.println (file);\n\n                return FileVisitResult.CONTINUE;\n\n            }}\n\n        );\n\n    }\n\n}\n"}
{"idx": 46501, "func": "public static void main (String [] args) {\n\n    X1 calendar = X1.getInstance ();\n\n    int countFirstSunday = 0;\n\n    for (int year = 1901;\n\n    year <= 2000; year ++) {\n\n        for (int month = 0;\n\n        month <= 11; month ++) {\n\n            calendar.set (year, month, 1);\n\n            if (calendar.get (X1.DAY_OF_WEEK) == X1.SUNDAY) {\n\n                countFirstSunday ++;\n\n            }\n\n        }\n\n    }\n\n    System.out.println (\"Sundays as the first of month: \" + countFirstSunday);\n\n}\n"}
{"idx": 46502, "func": "public static void main (String [] args) {\n\n    final int ThirtyOne = 31;\n\n    final int Thirty = 30;\n\n    final int FebNorm = 28;\n\n    final int FebLeap = 29;\n\n    int numOfSundays = 0;\n\n    int calendar [] [] = new int [12] [];\n\n    calendar [0] = new int [ThirtyOne];\n\n    calendar [1] = new int [FebLeap];\n\n    calendar [2] = new int [ThirtyOne];\n\n    calendar [3] = new int [Thirty];\n\n    calendar [4] = new int [ThirtyOne];\n\n    calendar [5] = new int [Thirty];\n\n    calendar [6] = new int [ThirtyOne];\n\n    calendar [7] = new int [ThirtyOne];\n\n    calendar [8] = new int [Thirty];\n\n    calendar [9] = new int [ThirtyOne];\n\n    calendar [10] = new int [Thirty];\n\n    calendar [11] = new int [ThirtyOne];\n\n    int dayOfWeek = 1;\n\n    for (int X1 = 1900;\n\n    X1 < 2001; X1 ++) {\n\n        for (int month = 0;\n\n        month < calendar.length; month ++) {\n\n            int dayOfMonth = 0;\n\n            int daysInMonth;\n\n            if (month == 1) {\n\n                daysInMonth = isLeapYear (X1) ? FebLeap : FebNorm;\n\n            } else {\n\n                daysInMonth = calendar [month].length;\n\n            }\n\n            while (dayOfWeek < 8 && dayOfMonth < daysInMonth) {\n\n                System.out.println (\"year: \" + X1 + \"\\tday: \" + dayOfWeek + \"\\tcalendar[\" + month + \"][\" + dayOfMonth + \"]: \" + calendar [month] [dayOfMonth]);\n\n                if (dayOfWeek == 7 && X1 > 1900) {\n\n                    calendar [month] [dayOfMonth] ++;\n\n                    if (dayOfMonth == 0) {\n\n                        numOfSundays ++;\n\n                    }\n\n                }\n\n                dayOfMonth ++;\n\n                dayOfWeek ++;\n\n                if (dayOfWeek > 7) {\n\n                    dayOfWeek = 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (int month = 0;\n\n    month < calendar.length; month ++) {\n\n        System.out.println (calendar [month] [0]);\n\n    }\n\n    System.out.println (numOfSundays);\n\n}\n"}
{"idx": 46601, "func": "public static void main (String [] args) {\n\n    final int ThirtyOne = 31;\n\n    final int Thirty = 30;\n\n    final int FebNorm = 28;\n\n    final int FebLeap = 29;\n\n    int numOfSundays = 0;\n\n    int X1 [] [] = new int [12] [];\n\n    X1 [0] = new int [ThirtyOne];\n\n    X1 [1] = new int [FebLeap];\n\n    X1 [2] = new int [ThirtyOne];\n\n    X1 [3] = new int [Thirty];\n\n    X1 [4] = new int [ThirtyOne];\n\n    X1 [5] = new int [Thirty];\n\n    X1 [6] = new int [ThirtyOne];\n\n    X1 [7] = new int [ThirtyOne];\n\n    X1 [8] = new int [Thirty];\n\n    X1 [9] = new int [ThirtyOne];\n\n    X1 [10] = new int [Thirty];\n\n    X1 [11] = new int [ThirtyOne];\n\n    int dayOfWeek = 1;\n\n    for (int year = 1900;\n\n    year < 2001; year ++) {\n\n        for (int month = 0;\n\n        month < X1.length; month ++) {\n\n            int dayOfMonth = 0;\n\n            int daysInMonth;\n\n            if (month == 1) {\n\n                daysInMonth = isLeapYear (year) ? FebLeap : FebNorm;\n\n            } else {\n\n                daysInMonth = X1 [month].length;\n\n            }\n\n            while (dayOfWeek < 8 && dayOfMonth < daysInMonth) {\n\n                System.out.println (\"year: \" + year + \"\\tday: \" + dayOfWeek + \"\\tcalendar[\" + month + \"][\" + dayOfMonth + \"]: \" + X1 [month] [dayOfMonth]);\n\n                if (dayOfWeek == 7 && year > 1900) {\n\n                    X1 [month] [dayOfMonth] ++;\n\n                    if (dayOfMonth == 0) {\n\n                        numOfSundays ++;\n\n                    }\n\n                }\n\n                dayOfMonth ++;\n\n                dayOfWeek ++;\n\n                if (dayOfWeek > 7) {\n\n                    dayOfWeek = 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (int month = 0;\n\n    month < X1.length; month ++) {\n\n        System.out.println (X1 [month] [0]);\n\n    }\n\n    System.out.println (numOfSundays);\n\n}\n"}
{"idx": 46602, "func": "public static void main (String [] argv) {\n\n    int counter = 0;\n\n    for (int year = 1901, last_year = 2000;\n\n    year <= last_year; year ++) {\n\n        for (int X1 = 1, last_month = 12;\n\n        X1 <= last_month; X1 ++) {\n\n            Date d = new GregorianCalendar (year, X1 - 1, 1).getTime ();\n\n            if (d.getDay () == 0) {\n\n                counter ++;\n\n                System.out.println (String.valueOf (counter) + \" \" + d);\n\n            }\n\n        }\n\n    }\n\n    System.out.println (\"Total sunday in XX century: \" + counter);\n\n}\n"}
{"idx": 46701, "func": "public static void main (String args []) throws IOException {\n\n    JavaPingExampleProgram ping = new JavaPingExampleProgram ();\n\n    List < String > commands = new ArrayList < String > ();\n\n    commands.X1 (\"ping\");\n\n    commands.X1 (\"-c\");\n\n    commands.X1 (\"5\");\n\n    commands.X1 (\"74.125.236.73\");\n\n    ping.doCommand (commands);\n\n}\n"}
{"idx": 46702, "func": "public static void main (String [] args) {\n\n    try {\n\n        X1 address = X1.getByName (\"192.168.1.103\");\n\n        boolean reachable = address.isReachable (10000);\n\n        System.out.println (\"Is host reachable? \" + reachable);\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 46801, "func": "public static void main (String args []) throws IOException {\n\n    JavaPingExampleProgram ping = new JavaPingExampleProgram ();\n\n    List < String > X1 = new ArrayList < String > ();\n\n    X1.add (\"ping\");\n\n    X1.add (\"-c\");\n\n    X1.add (\"5\");\n\n    X1.add (\"74.125.236.73\");\n\n    ping.doCommand (X1);\n\n}\n"}
{"idx": 46802, "func": "public static void main (String [] args) throws UnknownHostException, IOException {\n\n    InetAddress X1;\n\n    X1 = InetAddress.getByAddress (new byte [] {127, 0, 0, 1});\n\n    System.out.println (\"Sending Ping Request to \" + X1);\n\n    System.out.println (X1.isReachable (5000) ? \"Host is reachable\" : \"Host is NOT reachable\");\n\n    X1 = InetAddress.getByAddress (new byte [] {(byte) 173, (byte) 194, 32, 38});\n\n    System.out.println (\"Sending Ping Request to \" + X1);\n\n    System.out.println (X1.isReachable (5000) ? \"Host is reachable\" : \"Host is NOT reachable\");\n\n}\n"}
{"idx": 46901, "func": "public static void main (String [] args) {\n\n    try {\n\n        InetAddress address = InetAddress.getByName (\"192.168.1.103\");\n\n        boolean reachable = address.isReachable (10000);\n\n        System.out.println (\"Is host reachable? \" + reachable);\n\n    } catch (Exception X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 46902, "func": "public static void main (String [] args) throws UnknownHostException, IOException {\n\n    InetAddress inet;\n\n    inet = InetAddress.getByAddress (new byte [] {127, 0, 0, 1});\n\n    X1.out.println (\"Sending Ping Request to \" + inet);\n\n    X1.out.println (inet.isReachable (5000) ? \"Host is reachable\" : \"Host is NOT reachable\");\n\n    inet = InetAddress.getByAddress (new byte [] {(byte) 173, (byte) 194, 32, 38});\n\n    X1.out.println (\"Sending Ping Request to \" + inet);\n\n    X1.out.println (inet.isReachable (5000) ? \"Host is reachable\" : \"Host is NOT reachable\");\n\n}\n"}
{"idx": 47001, "func": "public ControlsB (X1 b, Graph g) {\n\n    graph = g;\n\n    b = X1.createVerticalBox ();\n\n    X1 boxUpper = new X1 (BoxLayout.X_AXIS);\n\n    boxUpper.add (new JLabel (\"Please enter range:  \"));\n\n    b.add (boxUpper);\n\n    X1 boxX = new X1 (BoxLayout.X_AXIS);\n\n    boxX.add (new JLabel (\" x-axis \"));\n\n    boxX.add (new JLabel (\"from\"));\n\n    final JTextField f1 = new JTextField (\"-5\");\n\n    f1.setMaximumSize (new Dimension (100, 30));\n\n    boxX.add (f1);\n\n    boxX.add (new JLabel (\" to \"));\n\n    JTextField f2 = new JTextField (\"5\");\n\n    f2.setMaximumSize (new Dimension (100, 30));\n\n    boxX.add (f2);\n\n    b.add (boxX);\n\n    X1 boxY = new X1 (BoxLayout.X_AXIS);\n\n    boxY.add (new JLabel (\"y-axis \"));\n\n    boxY.add (new JLabel (\"from\"));\n\n    final JTextField f3 = new JTextField (\"5\");\n\n    f3.setMaximumSize (new Dimension (100, 30));\n\n    boxY.add (f3);\n\n    boxY.add (new JLabel (\"to\"));\n\n    JTextField f4 = new JTextField (\"-5\");\n\n    f4.setMaximumSize (new Dimension (100, 30));\n\n    boxY.add (f4);\n\n    b.add (boxY);\n\n    X1 buttonBox = new X1 (BoxLayout.X_AXIS);\n\n    buttonBox.add (new JButton (\"Plot\"));\n\n    refineButton = new JButton (\"Refine\");\n\n    buttonBox.add (refineButton);\n\n    refineButton.addActionListener (new ActionListener () {\n\n        public void actionPerformed (ActionEvent ae) {\n\n            int x = Integer.parseInt (f1.getText ());\n\n            int y = Integer.parseInt (f3.getText ());\n\n            graph.setValues (x, y);\n\n        }}\n\n    );\n\n    b.add (buttonBox);\n\n    add (b);\n\n}\n"}
{"idx": 47002, "func": "public ControlsB (Box box2, final Graph graph) {\n\n    btn1.addActionListener (new ActionListener () {\n\n        public void actionPerformed (ActionEvent event) {\n\n            f = Integer.parseInt (f1.getText ());\n\n            X1 = Integer.parseInt (f2.getText ());\n\n            System.out.println (f + \"  \" + X1);\n\n            graph.repaint ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 4701, "func": "boolean hasLoop (Node first) {\n\n    Node slow = first;\n\n    Node X1 = first;\n\n    while (X1 != null && X1.next != null) {\n\n        slow = slow.next;\n\n        X1 = X1.next.next;\n\n        if (slow == X1) return true;\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 4702, "func": "public static boolean hasLoop (Node root) {\n\n    if (root == null) return false;\n\n    Node slow = root, fast = root;\n\n    int taken = 0, limit = 2;\n\n    while (fast.X1 != null) {\n\n        fast = fast.X1;\n\n        taken ++;\n\n        if (slow == fast) return true;\n\n        if (taken == limit) {\n\n            taken = 0;\n\n            limit <<= 1;\n\n            slow = fast;\n\n        }\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 47101, "func": "private static String capitalize (String str) {\n\n    if (TextUtils.isEmpty (str)) {\n\n        return str;\n\n    }\n\n    char [] arr = str.toCharArray ();\n\n    boolean capitalizeNext = true;\n\n    String phrase = \"\";\n\n    for (char X1 : arr) {\n\n        if (capitalizeNext && Character.isLetter (X1)) {\n\n            phrase += Character.toUpperCase (X1);\n\n            capitalizeNext = false;\n\n            continue;\n\n        } else if (Character.isWhitespace (X1)) {\n\n            capitalizeNext = true;\n\n        }\n\n        phrase += X1;\n\n    }\n\n    return phrase;\n\n}\n"}
{"idx": 47102, "func": "private String capitalize (String X1) {\n\n    if (X1 == null || X1.length () == 0) {\n\n        return \"\";\n\n    }\n\n    char first = X1.charAt (0);\n\n    if (Character.isUpperCase (first)) {\n\n        return X1;\n\n    } else {\n\n        return Character.toUpperCase (first) + X1.substring (1);\n\n    }\n\n}\n"}
{"idx": 47201, "func": "public void run () {\n\n    countCalled ++;\n\n    if (countCalled < maxCalled) {\n\n        if (countCalled % 3 == 0) {\n\n            SwingUtilities.invokeLater (new Runnable () {\n\n                @Override\n\n                public void run () {\n\n                    System.out.X1 (\"Push a new event to EDT\");\n\n                    frame1.getContentPane ().setBackground (Color.red);\n\n                    isThereReallyEDT ();\n\n                }}\n\n            );\n\n        } else {\n\n            if (this.getExecutionTime () < ALLOWED_TARDINESS) {\n\n                countRun ++;\n\n                isThereReallyEDT ();\n\n            }\n\n        }\n\n    } else {\n\n        System.out.X1 (\"Terminating this madness\");\n\n        System.exit (0);\n\n    }\n\n}\n"}
{"idx": 47202, "func": "public void run () {\n\n    X1 frame2 = new X1 (\"Frame 2\");\n\n    frame2.setDefaultCloseOperation (X1.EXIT_ON_CLOSE);\n\n    frame2.getContentPane ().add (new JLabel (\"Hello in frame 2\"));\n\n    frame2.pack ();\n\n    frame2.setLocation (200, 200);\n\n    frame2.setVisible (true);\n\n    isThereReallyEDT ();\n\n}\n"}
{"idx": 47301, "func": "public static void pack (final Path folder, final Path zipFilePath) throws IOException {\n\n    try (FileOutputStream fos = new FileOutputStream (zipFilePath.toFile ()); ZipOutputStream X1 = new ZipOutputStream (fos)) {\n\n        Files.walkFileTree (folder, new SimpleFileVisitor < Path > () {\n\n            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {\n\n                X1.putNextEntry (new ZipEntry (folder.relativize (file).toString ()));\n\n                Files.copy (file, X1);\n\n                X1.closeEntry ();\n\n                return FileVisitResult.CONTINUE;\n\n            } public FileVisitResult preVisitDirectory (Path dir, BasicFileAttributes attrs) throws IOException {\n\n                X1.putNextEntry (new ZipEntry (folder.relativize (dir).toString () + \"/\"));\n\n                X1.closeEntry ();\n\n                return FileVisitResult.CONTINUE;\n\n            }}\n\n        );\n\n    }\n\n}\n"}
{"idx": 47302, "func": "public static void pack (String sourceDirPath, String zipFilePath) throws IOException {\n\n    Path p = Files.createFile (Paths.get (zipFilePath));\n\n    Path pp = Paths.get (sourceDirPath);\n\n    try (ZipOutputStream zs = new ZipOutputStream (Files.newOutputStream (p)); Stream < Path > paths = Files.walk (pp)) {\n\n        paths.filter (X1 -> ! Files.isDirectory (X1)).forEach (X1 -> {\n\n            ZipEntry zipEntry = new ZipEntry (pp.relativize (X1).toString ());\n\n            try {\n\n                zs.putNextEntry (zipEntry);\n\n                Files.copy (X1, zs);\n\n                zs.closeEntry ();\n\n            } catch (IOException e) {\n\n                System.err.println (e);\n\n            }\n\n        });\n\n    }\n\n}\n"}
{"idx": 47401, "func": "public static void pack (final Path folder, final Path zipFilePath) throws IOException {\n\n    try (FileOutputStream X1 = new FileOutputStream (zipFilePath.toFile ()); ZipOutputStream zos = new ZipOutputStream (X1)) {\n\n        Files.walkFileTree (folder, new SimpleFileVisitor < Path > () {\n\n            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {\n\n                zos.putNextEntry (new ZipEntry (folder.relativize (file).toString ()));\n\n                Files.copy (file, zos);\n\n                zos.closeEntry ();\n\n                return FileVisitResult.CONTINUE;\n\n            } public FileVisitResult preVisitDirectory (Path dir, BasicFileAttributes attrs) throws IOException {\n\n                zos.putNextEntry (new ZipEntry (folder.relativize (dir).toString () + \"/\"));\n\n                zos.closeEntry ();\n\n                return FileVisitResult.CONTINUE;\n\n            }}\n\n        );\n\n    }\n\n}\n"}
{"idx": 47402, "func": "public static void pack (String sourceDirPath, String zipFilePath) throws IOException {\n\n    X1 p = Files.createFile (Paths.get (zipFilePath));\n\n    try (ZipOutputStream zs = new ZipOutputStream (Files.newOutputStream (p))) {\n\n        X1 pp = Paths.get (sourceDirPath);\n\n        Files.walk (pp).filter (path -> ! Files.isDirectory (path)).forEach (path -> {\n\n            ZipEntry zipEntry = new ZipEntry (pp.relativize (path).toString ());\n\n            try {\n\n                zs.putNextEntry (zipEntry);\n\n                Files.copy (path, zs);\n\n                zs.closeEntry ();\n\n            } catch (IOException e) {\n\n                System.err.println (e);\n\n            }\n\n        });\n\n    }\n\n}\n"}
{"idx": 47501, "func": "static private void addFolderToZip (String path, String srcFolder, ZipOutputStream zip) throws Exception {\n\n    File folder = new File (srcFolder);\n\n    for (String fileName : folder.list ()) {\n\n        if (path.equals (\"\")) {\n\n            X1 (folder.getName (), srcFolder + \"/\" + fileName, zip);\n\n        } else {\n\n            X1 (path + \"/\" + folder.getName (), srcFolder + \"/\" + fileName, zip);\n\n        }\n\n    }\n\n}\n"}
{"idx": 47502, "func": "private void addFolderToZip (String path, String srcFolder, ZipOutputStream zip) throws IOException {\n\n    File folder = new File (srcFolder);\n\n    if (folder.list ().length == 0) {\n\n        X1 (path, srcFolder, zip, true);\n\n    } else {\n\n        for (String fileName : folder.list ()) {\n\n            if (path.equals (\"\")) {\n\n                X1 (folder.getName (), srcFolder + \"/\" + fileName, zip, false);\n\n            } else {\n\n                X1 (path + \"/\" + folder.getName (), srcFolder + \"/\" + fileName, zip, false);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 47601, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int X1 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, X1 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (X1, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int X1 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = X1;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (X1, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, X1 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (X1, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 47602, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D gg = (Graphics2D) g;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font X1 = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Time (s)\";\n\n    FontMetrics metrics = g.getFontMetrics (X1);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    gg.setFont (X1);\n\n    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);\n\n}\n"}
{"idx": 47701, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) X1 () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, X1 () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = X1 () - ((i * (X1 () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.X1 () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = X1 () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, X1 () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.X1 () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, X1 () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, X1 () - padding - labelPadding, getWidth () - padding, X1 () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 47702, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D gg = (Graphics2D) g;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Distance (m)\";\n\n    FontMetrics X1 = g.getFontMetrics (font);\n\n    int width = X1.stringWidth (string);\n\n    int height = X1.getHeight ();\n\n    gg.setFont (font);\n\n    gg.drawString (string, (getWidth () - width) / 2, 11);\n\n}\n"}
{"idx": 47801, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * X1) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * X1 - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + X1 + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + X1);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (X1 + labelPadding, X1, getWidth () - (2 * X1) - labelPadding, getHeight () - 2 * X1 - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = X1 + labelPadding;\n\n        int x1 = pointWidth + X1 + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - X1 * 2 - labelPadding)) / numberYDivisions + X1 + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (X1 + labelPadding + 1 + pointWidth, y0, getWidth () - X1, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - X1 * 2 - labelPadding) / (scores.size () - 1) + X1 + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - X1 - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - X1 - labelPadding - 1 - pointWidth, x1, X1);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (X1 + labelPadding, getHeight () - X1 - labelPadding, X1 + labelPadding, X1);\n\n    g2.drawLine (X1 + labelPadding, getHeight () - X1 - labelPadding, getWidth () - X1, getHeight () - X1 - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 47802, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D gg = (Graphics2D) g;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String X1 = \"Time (s)\";\n\n    FontMetrics metrics = g.getFontMetrics (font);\n\n    int width = metrics.stringWidth (X1);\n\n    int height = metrics.getHeight ();\n\n    gg.setFont (font);\n\n    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, X1);\n\n}\n"}
{"idx": 47901, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics X1 = g2.getFontMetrics ();\n\n            int labelWidth = X1.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (X1.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics X1 = g2.getFontMetrics ();\n\n                int labelWidth = X1.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + X1.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 47902, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D gg = (Graphics2D) g;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Distance (m)\";\n\n    FontMetrics X1 = g.getFontMetrics (font);\n\n    int width = X1.stringWidth (string);\n\n    int height = X1.getHeight ();\n\n    gg.setFont (font);\n\n    gg.drawString (string, (getWidth () - width) / 2, 11);\n\n}\n"}
{"idx": 48001, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) X1 () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, X1 () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = X1 () - ((i * (X1 () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.X1 () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = X1 () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, X1 () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.X1 () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, X1 () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, X1 () - padding - labelPadding, getWidth () - padding, X1 () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48002, "func": "public void paintComponent (Graphics X1) {\n\n    super.paintComponent (X1);\n\n    Graphics2D gg = (Graphics2D) X1;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Time (s)\";\n\n    FontMetrics metrics = X1.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    gg.setFont (font);\n\n    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);\n\n}\n"}
{"idx": 4801, "func": "boolean hasLoop (X1 first) {\n\n    if (first == null) return false;\n\n    X1 slow, fast;\n\n    slow = fast = first;\n\n    while (true) {\n\n        slow = slow.next;\n\n        if (fast.next != null) fast = fast.next.next;\n\n        else return false;\n\n        if (slow == null || fast == null) return false;\n\n        if (slow == fast) return true;\n\n    }\n\n}\n"}
{"idx": 4802, "func": "public static boolean hasLoop (Node X1) {\n\n    if (X1 == null) return false;\n\n    Node slow = X1, fast = X1;\n\n    int taken = 0, limit = 2;\n\n    while (fast.next != null) {\n\n        fast = fast.next;\n\n        taken ++;\n\n        if (slow == fast) return true;\n\n        if (taken == limit) {\n\n            taken = 0;\n\n            limit <<= 1;\n\n            slow = fast;\n\n        }\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 48101, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.X1 (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.X1 (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.X1 (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.X1 (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.X1 (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.X1 (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.X1 (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48102, "func": "public void paintComponent (Graphics X1) {\n\n    super.paintComponent (X1);\n\n    Graphics2D gg = (Graphics2D) X1;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Distance (m)\";\n\n    FontMetrics metrics = X1.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    gg.setFont (font);\n\n    gg.drawString (string, (getWidth () - width) / 2, 11);\n\n}\n"}
{"idx": 48201, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    X1 gg = (X1) g;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Time (s)\";\n\n    FontMetrics metrics = g.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    gg.setFont (font);\n\n    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);\n\n}\n"}
{"idx": 48202, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.X1 (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.X1 (i).x;\n\n        int y1 = graphPoints.X1 (i).y;\n\n        int x2 = graphPoints.X1 (i + 1).x;\n\n        int y2 = graphPoints.X1 (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.X1 (i).x - pointWidth / 2;\n\n        int y = graphPoints.X1 (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48301, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D X1 = (Graphics2D) g;\n\n    X1.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Distance (m)\";\n\n    FontMetrics metrics = g.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    X1.setFont (font);\n\n    X1.drawString (string, (getWidth () - width) / 2, 11);\n\n}\n"}
{"idx": 48302, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.X1 () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.X1 (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.X1 () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.X1 (); i ++) {\n\n        if (scores.X1 () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.X1 () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.X1 () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.X1 () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.X1 (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48401, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D gg = (Graphics2D) g;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    X1 font = new X1 (\"Arial\", X1.PLAIN, 15);\n\n    String string = \"Time (s)\";\n\n    FontMetrics metrics = g.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    gg.setFont (font);\n\n    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);\n\n}\n"}
{"idx": 48402, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = X1 + padding + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + X1, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - X1;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - X1, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - X1 / 2;\n\n        int y = graphPoints.get (i).y - X1 / 2;\n\n        int ovalW = X1;\n\n        int ovalH = X1;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48501, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D X1 = (Graphics2D) g;\n\n    X1.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Distance (m)\";\n\n    FontMetrics metrics = g.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    X1.setFont (font);\n\n    X1.drawString (string, (getWidth () - width) / 2, 11);\n\n}\n"}
{"idx": 48502, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * X1) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * X1 - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + X1 + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + X1);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (X1 + labelPadding, X1, getWidth () - (2 * X1) - labelPadding, getHeight () - 2 * X1 - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = X1 + labelPadding;\n\n        int x1 = pointWidth + X1 + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - X1 * 2 - labelPadding)) / numberYDivisions + X1 + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (X1 + labelPadding + 1 + pointWidth, y0, getWidth () - X1, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - X1 * 2 - labelPadding) / (scores.size () - 1) + X1 + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - X1 - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - X1 - labelPadding - 1 - pointWidth, x1, X1);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (X1 + labelPadding, getHeight () - X1 - labelPadding, X1 + labelPadding, X1);\n\n    g2.drawLine (X1 + labelPadding, getHeight () - X1 - labelPadding, getWidth () - X1, getHeight () - X1 - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48601, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        int x1 = (int) (i * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int i = 0;\n\n    i < numberYDivisions + 1; i ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int i = 0;\n\n    i < scores.size (); i ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = i + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.X1 (GRAPH_STROKE);\n\n    for (int i = 0;\n\n    i < graphPoints.size () - 1; i ++) {\n\n        int x1 = graphPoints.get (i).x;\n\n        int y1 = graphPoints.get (i).y;\n\n        int x2 = graphPoints.get (i + 1).x;\n\n        int y2 = graphPoints.get (i + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.X1 (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int i = 0;\n\n    i < graphPoints.size (); i ++) {\n\n        int x = graphPoints.get (i).x - pointWidth / 2;\n\n        int y = graphPoints.get (i).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48602, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D gg = (Graphics2D) g;\n\n    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Time (s)\";\n\n    FontMetrics metrics = g.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.X1 ();\n\n    gg.setFont (font);\n\n    drawRotate (gg, getWidth (), (X1 () + width) / 2, 270, string);\n\n}\n"}
{"idx": 48701, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);\n\n    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());\n\n    List < Point > graphPoints = new ArrayList < > ();\n\n    for (int X1 = 0;\n\n    X1 < scores.size (); X1 ++) {\n\n        int x1 = (int) (X1 * xScale + padding + labelPadding);\n\n        int y1 = (int) ((getMaxScore () - scores.get (X1)) * yScale + padding);\n\n        graphPoints.add (new Point (x1, y1));\n\n    }\n\n    g2.setColor (Color.WHITE);\n\n    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);\n\n    g2.setColor (Color.BLACK);\n\n    for (int X1 = 0;\n\n    X1 < numberYDivisions + 1; X1 ++) {\n\n        int x0 = padding + labelPadding;\n\n        int x1 = pointWidth + padding + labelPadding;\n\n        int y0 = getHeight () - ((X1 * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);\n\n        int y1 = y0;\n\n        if (scores.size () > 0) {\n\n            g2.setColor (gridColor);\n\n            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);\n\n            g2.setColor (Color.BLACK);\n\n            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((X1 * 1.0) / numberYDivisions)) * 100)) / 100.0 + \"\";\n\n            FontMetrics metrics = g2.getFontMetrics ();\n\n            int labelWidth = metrics.stringWidth (yLabel);\n\n            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);\n\n        }\n\n        g2.drawLine (x0, y0, x1, y1);\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < scores.size (); X1 ++) {\n\n        if (scores.size () > 1) {\n\n            int x0 = X1 * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;\n\n            int x1 = x0;\n\n            int y0 = getHeight () - padding - labelPadding;\n\n            int y1 = y0 - pointWidth;\n\n            if ((X1 % ((int) ((scores.size () / 20.0)) + 1)) == 0) {\n\n                g2.setColor (gridColor);\n\n                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);\n\n                g2.setColor (Color.BLACK);\n\n                String xLabel = X1 + \"\";\n\n                FontMetrics metrics = g2.getFontMetrics ();\n\n                int labelWidth = metrics.stringWidth (xLabel);\n\n                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);\n\n            }\n\n            g2.drawLine (x0, y0, x1, y1);\n\n        }\n\n    }\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);\n\n    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);\n\n    Stroke oldStroke = g2.getStroke ();\n\n    g2.setColor (lineColor);\n\n    g2.setStroke (GRAPH_STROKE);\n\n    for (int X1 = 0;\n\n    X1 < graphPoints.size () - 1; X1 ++) {\n\n        int x1 = graphPoints.get (X1).x;\n\n        int y1 = graphPoints.get (X1).y;\n\n        int x2 = graphPoints.get (X1 + 1).x;\n\n        int y2 = graphPoints.get (X1 + 1).y;\n\n        g2.drawLine (x1, y1, x2, y2);\n\n    }\n\n    g2.setStroke (oldStroke);\n\n    g2.setColor (pointColor);\n\n    for (int X1 = 0;\n\n    X1 < graphPoints.size (); X1 ++) {\n\n        int x = graphPoints.get (X1).x - pointWidth / 2;\n\n        int y = graphPoints.get (X1).y - pointWidth / 2;\n\n        int ovalW = pointWidth;\n\n        int ovalH = pointWidth;\n\n        g2.fillOval (x, y, ovalW, ovalH);\n\n    }\n\n}\n"}
{"idx": 48702, "func": "public void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D gg = (Graphics2D) g;\n\n    gg.setRenderingHint (X1.KEY_ANTIALIASING, X1.VALUE_ANTIALIAS_ON);\n\n    Font font = new Font (\"Arial\", Font.PLAIN, 15);\n\n    String string = \"Distance (m)\";\n\n    FontMetrics metrics = g.getFontMetrics (font);\n\n    int width = metrics.stringWidth (string);\n\n    int height = metrics.getHeight ();\n\n    gg.setFont (font);\n\n    gg.drawString (string, (getWidth () - width) / 2, 11);\n\n}\n"}
{"idx": 48801, "func": "public static void main (String [] args) {\n\n    File fileName = new File (\"hello.txt\");\n\n    try {\n\n        Scanner scan = new Scanner (fileName);\n\n        while (scan.hasNextLine ()) {\n\n            String line = scan.nextLine ();\n\n            System.out.println (line);\n\n            int indexHello = line.lastIndexOf (\"hello\", 0);\n\n            int indexBye = line.indexOf (\"bye\".indexHello);\n\n            String newString = line.substring (indexHello, indexBye);\n\n        }\n\n    } catch (FileNotFoundException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 48802, "func": "public static void main (String [] args) {\n\n    File fileName = new File (\"hello.txt\");\n\n    try {\n\n        String startToken = \"Hello\";\n\n        String endToken = \"Bye\";\n\n        boolean output = false;\n\n        Scanner scan = new Scanner (fileName);\n\n        while (scan.hasNextLine ()) {\n\n            String X1 = scan.nextLine ();\n\n            if (! output && X1.indexOf (startToken) > - 1) {\n\n                output = true;\n\n                X1 = X1.substring (X1.indexOf (startToken) + startToken.length ());\n\n            } else if (output && X1.indexOf (endToken) > - 1) {\n\n                output = false;\n\n                System.out.println (X1.substring (0, X1.indexOf (endToken)));\n\n            }\n\n            if (output) {\n\n                System.out.println (X1);\n\n            }\n\n        }\n\n    } catch (FileNotFoundException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 48901, "func": "int computeHeight (Node root) {\n\n    int levels = 0;\n\n    for (Node child : root.children) {\n\n        int X1 = computeHeight (child);\n\n        if (X1 > levels) {\n\n            levels = X1;\n\n        }\n\n    }\n\n    return levels + 1;\n\n}\n"}
{"idx": 48902, "func": "int computeHeight () {\n\n    int maxHeight = 0;\n\n    int [] heights = new int [parent.length];\n\n    for (int X1 = 0;\n\n    X1 < n; X1 ++) {\n\n        if (heights [X1] != 0) continue;\n\n        int height = 0;\n\n        for (int i = X1;\n\n        i != - 1; i = parent [i]) {\n\n            if (heights [i] != 0) {\n\n                height += heights [i];\n\n                break;\n\n            }\n\n            height ++;\n\n        }\n\n        maxHeight = Math.max (maxHeight, height);\n\n        for (int i = X1;\n\n        i != - 1; i = parent [i]) {\n\n            if (heights [i] != 0) break;\n\n            heights [i] = height --;\n\n        }\n\n    }\n\n    return maxHeight;\n\n}\n"}
{"idx": 49001, "func": "public static void main (String args []) {\n\n    class Local {\n\n        public void name () {\n\n            System.out.println (\"Example of Local class in Java\");\n\n        }}\n\n    Local local = new Local ();\n\n    local.name ();\n\n    Thread anonymous = new Thread () {\n\n        @Override\n\n        public void run () {\n\n            System.out.println (\"Anonymous class example in java\");\n\n        }}\n\n    ;\n\n    anonymous.start ();\n\n    InnerClassTest test = new InnerClassTest ();\n\n    InnerClassTest.X1 inner = test.new X1 ();\n\n    inner.name ();\n\n}\n"}
{"idx": 49002, "func": "static public void main (String [] argv) {\n\n    System.X1.println (\"start\");\n\n    new C0 ();\n\n    try {\n\n        System.X1.println (\"retrieve item: \" + nested.innerItem);\n\n    } catch (Exception e) {\n\n        System.X1.println (\"failed to retrieve item: \" + e.toString ());\n\n    }\n\n    System.X1.println (\"finish\");\n\n}\n"}
{"idx": 4901, "func": "static boolean hasLoop (Node first) {\n\n    if (first == null) return false;\n\n    Node slow, X1;\n\n    slow = X1 = first;\n\n    while (true) {\n\n        slow = slow.next;\n\n        if (X1.next == null) X1 = null;\n\n        else X1 = X1.next.next;\n\n        if (X1 == null) return false;\n\n        if (slow == X1) return true;\n\n    }\n\n}\n"}
{"idx": 4902, "func": "public static boolean hasLoop (Node root) {\n\n    if (root == null) return false;\n\n    Node slow = root, X1 = root;\n\n    int taken = 0, limit = 2;\n\n    while (X1.next != null) {\n\n        X1 = X1.next;\n\n        taken ++;\n\n        if (slow == X1) return true;\n\n        if (taken == limit) {\n\n            taken = 0;\n\n            limit <<= 1;\n\n            slow = X1;\n\n        }\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 49101, "func": "public void run () {\n\n    try {\n\n        synchronized (X1) {\n\n            while (true) {\n\n                while (current.equals (info)) X1.wait ();\n\n                System.out.println (info);\n\n                current = info;\n\n                X1.notify ();\n\n            }\n\n        }\n\n    } catch (Exception e) {\n\n    }\n\n}\n"}
{"idx": 49102, "func": "public void run () {\n\n    try {\n\n        synchronized (X1) {\n\n            while (true) {\n\n                while (current.equals (info)) X1.wait ();\n\n                System.out.println (info);\n\n                current = info;\n\n                X1.notify ();\n\n            }\n\n        }\n\n    } catch (Exception e) {\n\n    }\n\n}\n"}
{"idx": 49201, "func": "public Component getTableCellRendererComponent (JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n\n    Component X1 = super.getTableCellRendererComponent (table, value, isSelected, hasFocus, row, column);\n\n    if (row == 0) {\n\n        X1.setBackground (Color.YELLOW);\n\n    } else if (row == 1) {\n\n        X1.setBackground (Color.GRAY);\n\n    } else {\n\n        X1.setBackground (Color.CYAN);\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 49202, "func": "public Component getTableCellRendererComponent (JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int col) {\n\n    Component c = X1.getTableCellRendererComponent (table, value, isSelected, hasFocus, row, col);\n\n    c.setBackground (Color.WHITE);\n\n    c.setForeground (Color.BLACK);\n\n    JLabel l = (JLabel) X1.getTableCellRendererComponent (table, value, isSelected, hasFocus, row, col);\n\n    if (separatedVariable.equals (\"YOUR VALUE TO GREEN\")) {\n\n        l.setBackground (Color.GREEN);\n\n        return l;\n\n    } else {\n\n        if (separatedValue.equals (\"YOUR VALUE TO YELLOW\")) {\n\n            l.setBackground (Color.YELLOW);\n\n            return l;\n\n        } else if (separatedValue.equals (\"YOUR VALUE TO RED\")) {\n\n            l.setBaground (Color.RED);\n\n            return l;\n\n        }\n\n    }\n\n    return c;\n\n}\n"}
{"idx": 49301, "func": "public static void main (String...args) {\n\n    int [] [] bino = new int [15] [];\n\n    for (int X1 = 0;\n\n    X1 < bino.length; X1 ++) {\n\n        bino [X1] = new int [X1 + 1];\n\n        for (int j = 0;\n\n        j < X1 + 1; j ++) {\n\n            bino [X1] [j] = nOverk (X1, j);\n\n        }\n\n    }\n\n}\n"}
{"idx": 49302, "func": "public static void main (String [] args) {\n\n    int n = 15;\n\n    int [] [] pascal = new int [n + 1] [];\n\n    pascal [1] = new int [1 + 2];\n\n    pascal [1] [1] = 1;\n\n    for (int X1 = 2;\n\n    X1 <= n; X1 ++) {\n\n        pascal [X1] = new int [X1 + 2];\n\n        for (int j = 1;\n\n        j < pascal [X1].length - 1; j ++) pascal [X1] [j] = pascal [X1 - 1] [j - 1] + pascal [X1 - 1] [j];\n\n    }\n\n    for (int X1 = 1;\n\n    X1 <= n; X1 ++) {\n\n        for (int j = 1;\n\n        j < pascal [X1].length - 1; j ++) {\n\n            System.out.print (pascal [X1] [j] + \" \");\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 49401, "func": "public void move (Container container) {\n\n    if (X1) {\n\n        x += deltaX;\n\n        if (x >= canvasWidth) {\n\n            X1 = false;\n\n            updateDelta ();\n\n        }\n\n    } else {\n\n        x += - deltaX;\n\n        if (x <= 0) {\n\n            X1 = true;\n\n            updateDelta ();\n\n        }\n\n    }\n\n    if (upDown) {\n\n        y += deltaY;\n\n        upDown = ! (y >= (canvasHeight));\n\n        if (y >= (canvasHeight)) {\n\n            upDown = false;\n\n            updateDelta ();\n\n        }\n\n    } else {\n\n        y += - deltaY;\n\n        if (y <= 0) {\n\n            upDown = true;\n\n            updateDelta ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 49402, "func": "public void move (Container container) {\n\n    if (x >= canvasWidth || x <= 0) {\n\n        deltaX = - 1 * deltaX;\n\n    }\n\n    if (y >= canvasHeight || y <= 0) {\n\n        X1 = - 1 * X1;\n\n    }\n\n    x += deltaX;\n\n    y += X1;\n\n}\n"}
{"idx": 49501, "func": "public void move (Container container) {\n\n    if (leftRight) {\n\n        x += deltaX;\n\n        if (x >= (Ball.this.getWidth () - canvasWidth / 2)) {\n\n            leftRight = false;\n\n            updateDelta ();\n\n        }\n\n    } else {\n\n        x += - deltaX;\n\n        if (x <= 0) {\n\n            leftRight = true;\n\n            updateDelta ();\n\n        }\n\n    }\n\n    if (upDown) {\n\n        X1 += deltaY;\n\n        upDown = ! (X1 >= (Ball.this.getHeight () - canvasHeight / 2));\n\n        if (X1 >= (Ball.this.getHeight () - canvasHeight / 2)) {\n\n            upDown = false;\n\n            updateDelta ();\n\n        }\n\n    } else {\n\n        X1 += - deltaY;\n\n        if (X1 <= 0) {\n\n            upDown = true;\n\n            updateDelta ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 49502, "func": "public void move (Container container) {\n\n    if (x >= canvasWidth || x <= 0) {\n\n        deltaX = - 1 * deltaX;\n\n    }\n\n    if (y >= canvasHeight || y <= 0) {\n\n        X1 = - 1 * X1;\n\n    }\n\n    x += deltaX;\n\n    y += X1;\n\n}\n"}
{"idx": 49601, "func": "public static void main (String [] args) {\n\n    char [] chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray ();\n\n    final int X1 = (chars.length + 1) / 2;\n\n    System.out.println (\"Mid: \" + X1);\n\n    System.out.println (\"Start : \" + new String (chars));\n\n    if ((chars.length % 2) == 1) {\n\n        char first = chars [0];\n\n        for (int l = 1, r = X1;\n\n        r < chars.length; l ++, r ++) {\n\n            chars [l - 1] = chars [r];\n\n            chars [r] = chars [l];\n\n        }\n\n        chars [X1 - 1] = first;\n\n    } else {\n\n        for (int l = 0, r = X1;\n\n        r < chars.length; l ++, r ++) {\n\n            swap (chars, l, r);\n\n        }\n\n    }\n\n    System.out.println (\"Pass 1: \" + new String (chars));\n\n    swap (chars, 0, chars.length - 2);\n\n    swap (chars, 1, chars.length - 1);\n\n    System.out.println (\"Pass 2: \" + new String (chars));\n\n    swap (chars, X1 - 1, X1 + 1);\n\n    swap (chars, X1 - 2, X1);\n\n    System.out.println (\"Pass 3: \" + new String (chars));\n\n}\n"}
{"idx": 49602, "func": "public static void main (X1 [] args) {\n\n    System.out.println (\"Hello World\");\n\n    X1 xyz = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    final int mid = (xyz.length () + 1) / 2;\n\n    X1 [] spstr = {xyz.substring (0, mid), xyz.substring (mid)};\n\n    X1 firstMix = spstr [1] + spstr [0];\n\n    X1 [] array = firstMix.split (\"\");\n\n    for (int i = 1;\n\n    i < 3; i ++) {\n\n        X1 temp = array [i];\n\n        array [i] = array [array.length - i];\n\n        array [array.length - i] = temp;\n\n    }\n\n    X1 str1 = Arrays.toString (array);\n\n    str1 = str1.substring (1, str1.length () - 1).replaceAll (\",\", \"\");\n\n    int j = 2;\n\n    for (int i = ((array.length / 2) - 2);\n\n    i < (array.length) / 2; i ++) {\n\n        X1 temp = array [i];\n\n        array [i] = array [array.length / 2 + j];\n\n        array [array.length / 2 + j] = temp;\n\n        j --;\n\n    }\n\n    X1 str2 = Arrays.toString (array);\n\n    str2 = str2.substring (1, str2.length () - 1).replaceAll (\",\", \"\");\n\n    System.out.println (firstMix);\n\n    System.out.println (str1);\n\n    System.out.println (str2);\n\n}\n"}
{"idx": 49701, "func": "protected void onCreate (Bundle savedInstanceState) {\n\n    super.onCreate (savedInstanceState);\n\n    setContentView (R.layout.buttons);\n\n    initializeLookup ();\n\n    mEditText = (EditText) X1 (R.id.edit_text);\n\n    mButton00 = (Button) X1 (R.id.button_0_0);\n\n    mButton10 = (Button) X1 (R.id.button_1_0);\n\n    mButton01 = (Button) X1 (R.id.button_0_1);\n\n    mButton11 = (Button) X1 (R.id.button_1_1);\n\n    mButton02 = (Button) X1 (R.id.button_0_2);\n\n    mButton12 = (Button) X1 (R.id.button_1_2);\n\n    mButton00.setOnClickListener (this);\n\n    mButton10.setOnClickListener (this);\n\n    mButton01.setOnClickListener (this);\n\n    mButton11.setOnClickListener (this);\n\n    mButton02.setOnClickListener (this);\n\n    mButton12.setOnClickListener (this);\n\n    mHandleInputRunnable = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            handleAlarmTrigger ();\n\n        }}\n\n    ;\n\n}\n"}
{"idx": 49702, "func": "protected void onCreate (Bundle savedInstanceState) {\n\n    super.onCreate (savedInstanceState);\n\n    setContentView (R.layout.activity_main);\n\n    Window X1 = this.getWindow ();\n\n    X1.addFlags (WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);\n\n    X1.addFlags (WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);\n\n    X1.addFlags (WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);\n\n    txtMessage = (TextView) findViewById (R.id.txtMesssage);\n\n    Button buttonOne = (Button) findViewById (R.id.block1);\n\n    Button buttonTwo = (Button) findViewById (R.id.block2);\n\n    Button buttonThree = (Button) findViewById (R.id.block3);\n\n    Button buttonFour = (Button) findViewById (R.id.block4);\n\n    Button buttonFive = (Button) findViewById (R.id.block5);\n\n    Button buttonSix = (Button) findViewById (R.id.block6);\n\n    buttonOne.setOnClickListener (this);\n\n    buttonTwo.setOnClickListener (this);\n\n    buttonThree.setOnClickListener (this);\n\n    buttonFour.setOnClickListener (this);\n\n    buttonFive.setOnClickListener (this);\n\n    buttonSix.setOnClickListener (this);\n\n}\n"}
{"idx": 49801, "func": "public void onActivityResult (int requestCode, int resultCode, Intent data) {\n\n    super.onActivityResult (requestCode, resultCode, data);\n\n    if (requestCode == CAMERA_RESULT) {\n\n        if (resultCode == Activity.RESULT_OK) {\n\n            String galleryImatePath = SD_CARD_TEMP_DIR;\n\n            File f = new File (galleryImatePath);\n\n            try {\n\n                Bitmap cameraBitmap = null;\n\n                X1.Options bmOptions = new X1.Options ();\n\n                bmOptions.inJustDecodeBounds = false;\n\n                bmOptions.inPurgeable = true;\n\n                bmOptions.inBitmap = cameraBitmap;\n\n                bmOptions.inMutable = true;\n\n                cameraBitmap = X1.decodeFile (galleryImatePath, bmOptions);\n\n                ByteArrayOutputStream bos = new ByteArrayOutputStream ();\n\n                cameraBitmap.compress (Bitmap.CompressFormat.JPEG, 50, bos);\n\n                ExifInterface exif = new ExifInterface (galleryImatePath);\n\n                float rotation = exif.getAttributeInt (ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\n\n                System.out.println (rotation);\n\n                float rotationInDegrees = exifToDegrees (rotation);\n\n                System.out.println (rotationInDegrees);\n\n                Matrix matrix = new Matrix ();\n\n                matrix.postRotate (rotationInDegrees);\n\n                final Bitmap rotatedBitmap = Bitmap.createBitmap (cameraBitmap, 0, 0, cameraBitmap.getWidth (), cameraBitmap.getHeight (), matrix, true);\n\n                FileOutputStream fos = new FileOutputStream (galleryImatePath);\n\n                rotatedBitmap.compress (Bitmap.CompressFormat.JPEG, 50, fos);\n\n                fos.write (bos.toByteArray ());\n\n                cameraBitmap.recycle ();\n\n                System.gc ();\n\n                fos.flush ();\n\n                fos.close ();\n\n                Capdialog = new Dialog (AddToDo.this, android.R.style.Theme_NoTitleBar_Fullscreen);\n\n                Capdialog.setContentView (R.layout.captiondialog);\n\n                Capdialog.setCancelable (false);\n\n                TextView cancel = (TextView) Capdialog.findViewById (R.id.cancel);\n\n                TextView done = (TextView) Capdialog.findViewById (R.id.done);\n\n                Capdialog.getWindow ().setSoftInputMode (WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n\n                ImageView img = (ImageView) Capdialog.findViewById (R.id.image);\n\n                img.setImageBitmap (rotatedBitmap);\n\n            } catch (Exception e) {\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 49802, "func": "protected void onActivityResult (int X1, int resultCode, Intent data) {\n\n    super.onActivityResult (X1, resultCode, data);\n\n    if (X1 == 0) {\n\n        try {\n\n            Bitmap cameraBitmap;\n\n            cameraBitmap = BitmapFactory.decodeFile (myFilesDir + \"/temp.jpg\");\n\n            Bitmap.createBitmap (cameraBitmap);\n\n            ivPhoto.setImageBitmap (cameraBitmap);\n\n        } catch (Exception e) {\n\n            e.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 49901, "func": "public static void main (String [] args) {\n\n    Scanner s = new Scanner (System.in);\n\n    int n = Integer.parseInt (s.nextLine ());\n\n    int [] [] a = new int [n] [n];\n\n    for (int X1 = 0;\n\n    X1 < n; X1 ++) {\n\n        String str = s.nextLine ();\n\n        String [] tempArray = str.split (\" \");\n\n        for (int j = 0;\n\n        j < n; j ++) {\n\n            a [X1] [j] = Integer.parseInt (tempArray [j]);\n\n        }\n\n    }\n\n    int x = 0;\n\n    int y = 0;\n\n    int sum = 0;\n\n    for (int X1 = 0;\n\n    X1 < n; X1 ++) {\n\n        x += a [X1] [X1];\n\n    }\n\n    for (int p = 0;\n\n    p < n; p ++) {\n\n        int k = a.length - p - 1;\n\n        y += a [p] [a.length - p - 1];\n\n        k += - 1;\n\n    }\n\n    sum = x - y;\n\n    System.out.println (Math.abs (sum));\n\n}\n"}
{"idx": 49902, "func": "public static void main (String [] args) {\n\n    Scanner in = new Scanner (System.in);\n\n    int n = in.nextInt ();\n\n    int leftStartDiagnol = 0;\n\n    int rightStartDiagnol = n;\n\n    int leftTotal = 0;\n\n    int rightTotal = 0;\n\n    int X1 [] [] = new int [n] [n];\n\n    for (int a_i = 0;\n\n    a_i < n; a_i ++) {\n\n        for (int a_j = 0;\n\n        a_j < n; a_j ++) {\n\n            X1 [a_i] [a_j] = in.nextInt ();\n\n        }\n\n    }\n\n    for (int a_i = 0;\n\n    a_i < n; a_i ++) {\n\n        boolean leftNotFound = true;\n\n        boolean rightNotFound = true;\n\n        rightStartDiagnol = -- rightStartDiagnol;\n\n        for (int a_j = 0;\n\n        a_j < n; a_j ++) {\n\n            if (leftStartDiagnol == a_j && leftNotFound) {\n\n                leftTotal = leftTotal + X1 [a_i] [a_j];\n\n                leftNotFound = false;\n\n            }\n\n            if (rightStartDiagnol == a_j && rightNotFound) {\n\n                rightTotal = rightTotal + X1 [a_i] [a_j];\n\n                rightNotFound = false;\n\n            }\n\n        }\n\n        leftStartDiagnol = ++ leftStartDiagnol;\n\n    }\n\n    int data = leftTotal - rightTotal;\n\n    System.out.println (Math.abs (data));\n\n}\n"}
{"idx": 50001, "func": "public static void main (String [] args) {\n\n    Scanner s = new Scanner (System.in);\n\n    int n = Integer.parseInt (s.nextLine ());\n\n    int [] [] a = new int [n] [n];\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        String str = s.nextLine ();\n\n        String [] tempArray = str.split (\" \");\n\n        for (int j = 0;\n\n        j < n; j ++) {\n\n            a [i] [j] = Integer.parseInt (tempArray [j]);\n\n        }\n\n    }\n\n    int x = 0;\n\n    int y = 0;\n\n    int sum = 0;\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        x += a [i] [i];\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < n; X1 ++) {\n\n        int k = a.length - X1 - 1;\n\n        y += a [X1] [a.length - X1 - 1];\n\n        k += - 1;\n\n    }\n\n    sum = x - y;\n\n    System.out.println (Math.abs (sum));\n\n}\n"}
{"idx": 50002, "func": "public static void main (String [] args) {\n\n    Scanner in = new Scanner (System.in);\n\n    int X1 = in.nextInt ();\n\n    int a [] [] = new int [X1] [X1];\n\n    for (int a_i = 0;\n\n    a_i < X1; a_i ++) {\n\n        for (int a_j = 0;\n\n        a_j < X1; a_j ++) {\n\n            a [a_i] [a_j] = in.nextInt ();\n\n        }\n\n    }\n\n    int l_sum = 0;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        l_sum += a [i] [i];\n\n    }\n\n    int r_sum = 0;\n\n    for (int j = 0;\n\n    j < X1; j ++) {\n\n        r_sum += a [j] [X1 - 1 - j];\n\n    }\n\n    int sum = l_sum + r_sum;\n\n    System.out.println (sum);\n\n}\n"}
{"idx": 5001, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    System.out.print (\"\\t\\tPlease enter the maximum: \");\n\n    int max = input.nextInt ();\n\n    System.out.print (\"\\t\\tPlease enter the minimum: \");\n\n    int min = input.nextInt ();\n\n    System.out.print (\"enter: \");\n\n    input.nextLine ();\n\n    String word = input.nextLine ();\n\n    System.out.print (word);\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < word.length (); i ++) {\n\n        if (word.charAt (i) == ' ') {\n\n            X1 ++;\n\n        }\n\n    }\n\n    X1 ++;\n\n    System.out.println (X1);\n\n    if (X1 <= max && X1 >= min) {\n\n        System.out.println (\"YAY!!!!!!!!! YOU'RE WTHIN THE RAAAANGE!!!!!!!!!!!!!!!!!!!!!!!\");\n\n    }\n\n}\n"}
{"idx": 5002, "func": "public static void main (String [] args) {\n\n    X1 input = new X1 (System.in);\n\n    System.out.print (\"\\t\\tPlease enter the maximum: \");\n\n    int max = input.nextInt ();\n\n    System.out.print (\"\\t\\tPlease enter the minimum: \");\n\n    int min = input.nextInt ();\n\n    System.out.print (\"enter: \");\n\n    X1 lineInput = new X1 (System.in);\n\n    String word = lineInput.nextLine ();\n\n    String [] lengthword = word.split (\"\\\\s+\");\n\n    int countwords = lengthword.length;\n\n    if (countwords <= max && countwords >= min) {\n\n        System.out.println (\"YAY!!!!!!!!! YOU'RE WTHIN THE RAAAANGE!!!!!!!!!!!!!!!!!!!!!!!\");\n\n    } else {\n\n        System.out.println (\"Ohh!!!!!!!!! YOU'RE Not in RAAAANGE!!!!!!!!!!!!!!!!!!!!!!!\");\n\n    }\n\n}\n"}
{"idx": 501, "func": "public void copyFolder (File X1, File dest) throws IOException {\n\n    try (Stream < Path > stream = Files.walk (X1.toPath ())) {\n\n        stream.forEachOrdered (sourcePath -> {\n\n            try {\n\n                Files.copy (sourcePath, X1.toPath ().resolve (dest.toPath ().relativize (sourcePath)));\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        });\n\n    }\n\n}\n"}
{"idx": 50101, "func": "public static void main (String [] args) {\n\n    Scanner in = new Scanner (System.in);\n\n    int n = in.nextInt ();\n\n    int leftStartDiagnol = 0;\n\n    int rightStartDiagnol = n;\n\n    int leftTotal = 0;\n\n    int rightTotal = 0;\n\n    int X1 [] [] = new int [n] [n];\n\n    for (int a_i = 0;\n\n    a_i < n; a_i ++) {\n\n        for (int a_j = 0;\n\n        a_j < n; a_j ++) {\n\n            X1 [a_i] [a_j] = in.nextInt ();\n\n        }\n\n    }\n\n    for (int a_i = 0;\n\n    a_i < n; a_i ++) {\n\n        boolean leftNotFound = true;\n\n        boolean rightNotFound = true;\n\n        rightStartDiagnol = -- rightStartDiagnol;\n\n        for (int a_j = 0;\n\n        a_j < n; a_j ++) {\n\n            if (leftStartDiagnol == a_j && leftNotFound) {\n\n                leftTotal = leftTotal + X1 [a_i] [a_j];\n\n                leftNotFound = false;\n\n            }\n\n            if (rightStartDiagnol == a_j && rightNotFound) {\n\n                rightTotal = rightTotal + X1 [a_i] [a_j];\n\n                rightNotFound = false;\n\n            }\n\n        }\n\n        leftStartDiagnol = ++ leftStartDiagnol;\n\n    }\n\n    int data = leftTotal - rightTotal;\n\n    System.out.println (Math.abs (data));\n\n}\n"}
{"idx": 50102, "func": "public static void main (String [] args) {\n\n    Scanner in = new Scanner (System.in);\n\n    int n = in.nextInt ();\n\n    int a [] [] = new int [n] [n];\n\n    for (int a_i = 0;\n\n    a_i < n; a_i ++) {\n\n        for (int a_j = 0;\n\n        a_j < n; a_j ++) {\n\n            a [a_i] [a_j] = in.nextInt ();\n\n        }\n\n    }\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        X1 += a [i] [i];\n\n    }\n\n    int r_sum = 0;\n\n    for (int j = 0;\n\n    j < n; j ++) {\n\n        r_sum += a [j] [n - 1 - j];\n\n    }\n\n    int sum = X1 + r_sum;\n\n    System.out.println (sum);\n\n}\n"}
{"idx": 502, "func": "public static void copyFolder (X1 src, X1 dest) {\n\n    try {\n\n        Files.walk (src).forEach (s -> {\n\n            try {\n\n                X1 d = dest.resolve (src.relativize (s));\n\n                if (Files.isDirectory (s)) {\n\n                    if (! Files.exists (d)) Files.createDirectory (d);\n\n                    return;\n\n                }\n\n                Files.copy (s, d);\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        });\n\n    } catch (Exception ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 50201, "func": "public static void main (String [] args) {\n\n    List < Point > points = new ArrayList < Point > ();\n\n    points.X1 (createPoint (\"A\", 1, 0));\n\n    points.X1 (createPoint (\"B\", 1, 1));\n\n    points.X1 (createPoint (\"C\", 1, 2));\n\n    points.X1 (createPoint (\"D\", 2, 2));\n\n    points.X1 (createPoint (\"E\", 3, 1));\n\n    points.X1 (createPoint (\"F\", 4, 1));\n\n    points.X1 (createPoint (\"G\", 5, 1));\n\n    points.X1 (createPoint (\"H\", 5, 2));\n\n    List < Integer > indices = computeTurningPointIndices (points);\n\n    System.out.println (\"Turning points are at \" + indices);\n\n    List < Point > turningPoints = indices.stream ().map (i -> points.get (i)).collect (Collectors.toList ());\n\n    System.out.println (\"They are \" + turningPoints);\n\n    System.out.println (\"Collinear:\");\n\n    indices.X1 (0, 0);\n\n    indices.X1 (points.size () - 1);\n\n    for (int i = 0;\n\n    i < indices.size () - 1; i ++) {\n\n        int i0 = indices.get (i);\n\n        int i1 = indices.get (i + 1);\n\n        List < Point > collinear = points.subList (i0, i1 + 1);\n\n        System.out.println (\"    \" + collinear);\n\n    }\n\n}\n"}
{"idx": 50202, "func": "public static void main (String [] args) {\n\n    ArrayList < Point > positions = new ArrayList < Point > ();\n\n    positions.add (new Point (1, 0));\n\n    positions.add (new Point (1, 1));\n\n    positions.add (new Point (1, 2));\n\n    positions.add (new Point (2, 2));\n\n    positions.add (new Point (3, 1));\n\n    positions.add (new Point (4, 1));\n\n    positions.add (new Point (5, 1));\n\n    positions.add (new Point (5, 2));\n\n    ArrayList < Point > turns = new ArrayList < Point > ();\n\n    for (int i = 0;\n\n    i < positions.size (); i ++) {\n\n        turns.add (null);\n\n    }\n\n    int counter = 0;\n\n    if (positions.size () > 2) {\n\n        Point base = positions.X1 (0);\n\n        Point next = positions.X1 (1);\n\n        int x = (next.x - base.x);\n\n        double slope = 1.0 * (next.y - base.y) / (next.x - base.x);\n\n        for (int i = 2;\n\n        i < positions.size (); i ++) {\n\n            Point newpoint = positions.X1 (i);\n\n            double newslope = 1.0 * (newpoint.y - next.y) / (newpoint.x - next.x);\n\n            if (newslope != slope) {\n\n                counter ++;\n\n                turns.set (i - 1, positions.X1 (i - 1));\n\n                slope = newslope;\n\n            }\n\n            next = newpoint;\n\n        }\n\n    }\n\n    System.out.println (\"Collinear points:\");\n\n    for (int i = 0;\n\n    i < positions.size (); i ++) {\n\n        System.out.print (\"(\" + positions.X1 (i).x + \", \" + positions.X1 (i).y + \") \");\n\n        if (turns.X1 (i) != null) {\n\n            System.out.println ();\n\n            System.out.print (\"(\" + positions.X1 (i).x + \", \" + positions.X1 (i).y + \") \");\n\n        }\n\n    }\n\n    System.out.println ();\n\n    System.out.println ();\n\n    if (counter > 0) {\n\n        System.out.println (\"Turns at these points: \");\n\n        for (Point p : turns) {\n\n            if (p != null) System.out.print (\"(\" + p.x + \", \" + p.y + \") \");\n\n        }\n\n    } else {\n\n        System.out.println (\"There are no turns!\");\n\n    }\n\n}\n"}
{"idx": 50301, "func": "public static void main (String [] args) {\n\n    VolumeControllerV4 volumeControllerV4 = new VolumeControllerV4 ();\n\n    BrightnessControllerV4 brightnessControllerV4 = new BrightnessControllerV4 ();\n\n    ColourControllerV4 colourControllerV4 = new ColourControllerV4 ();\n\n    List < ControllerV4 > controllerV4s = new ArrayList < > ();\n\n    controllerV4s.add (brightnessControllerV4);\n\n    controllerV4s.add (volumeControllerV4);\n\n    controllerV4s.add (colourControllerV4);\n\n    List < OnStart > controllersToInitialize = new ArrayList < > ();\n\n    controllersToInitialize.addAll (controllerV4s);\n\n    InitializeDeviceV4 initializeDeviceV4 = new InitializeDeviceV4 (controllersToInitialize);\n\n    initializeDeviceV4.initialize ();\n\n    List < OnReset > controllersToReset = new ArrayList < > ();\n\n    controllersToReset.addAll (controllerV4s);\n\n    ResetFunctionV4 resetFunctionV4 = new ResetFunctionV4 (controllersToReset);\n\n    OUTER : while (true) {\n\n        Scanner sc = new Scanner (System.in);\n\n        System.out.X1 (\" Enter your option \\n Press 1 to increase volume \\n Press 2 to decrease volume\");\n\n        System.out.X1 (\" Press 3 to increase brightness \\n Press 4 to decrease brightness\");\n\n        System.out.X1 (\" Press 5 to increase color \\n Press 6 to decrease color\");\n\n        System.out.X1 (\" Press 7 to reset TV \\n Press any other Button to shutdown\");\n\n        int button = sc.nextInt ();\n\n        switch (button) {\n\n            case 1 :\n\n                {\n\n                    volumeControllerV4.adjust (5);\n\n                    break;\n\n                } case 2 :\n\n                {\n\n                    volumeControllerV4.adjust (- 5);\n\n                    break;\n\n                } case 3 :\n\n                {\n\n                    brightnessControllerV4.adjust (5);\n\n                    break;\n\n                } case 4 :\n\n                {\n\n                    brightnessControllerV4.adjust (- 5);\n\n                    break;\n\n                } case 5 :\n\n                {\n\n                    colourControllerV4.adjust (5);\n\n                    break;\n\n                } case 6 :\n\n                {\n\n                    colourControllerV4.adjust (- 5);\n\n                    break;\n\n                } case 7 :\n\n                {\n\n                    resetFunctionV4.onReset ();\n\n                    break;\n\n                } default :\n\n                System.out.X1 (\"Shutting down...........\");\n\n                break OUTER;\n\n        }\n\n    }\n\n}\n"}
{"idx": 50302, "func": "public static void main (String args []) {\n\n    try {\n\n        Game game = new Chess ();\n\n        Thread t1 = new Thread (game);\n\n        t1.start ();\n\n        Thread.sleep (1000);\n\n        game.setRunGame (false);\n\n        Thread.sleep (1000);\n\n        game = new TicTacToe ();\n\n        Thread t2 = new Thread (game);\n\n        t2.start ();\n\n        Thread.sleep (1000);\n\n        game.setRunGame (false);\n\n    } catch (Exception X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 50401, "func": "@Override\n\nprotected void onCreate (Bundle savfedInstanceState) {\n\n    super.onCreate (savedInstanceState);\n\n    setContentView (R.layout.indexpage);\n\n    X1 = (ListView) findViewById (R.id.pageList);\n\n    editTextB = (EditText) findViewById (R.id.searchB);\n\n    X1.setAdapter (new PagesAdapter (this));\n\n    X1.setOnItemClickListener (new OnItemClickListener () {\n\n        public void onItemClick (AdapterView < ? > parent, View view, int position, long id) {\n\n        }}\n\n    );\n\n}\n"}
{"idx": 50402, "func": "protected void onCreate (Bundle savedInstanceState) {\n\n    super.onCreate (savedInstanceState);\n\n    setContentView (R.layout.activity_main);\n\n    listView = (ListView) X1 (R.id.pageList);\n\n    editTextB = (EditText) X1 (R.id.searchB);\n\n    adapter1 = new PagesAdapter (this);\n\n    listView.setAdapter (adapter1);\n\n    adapter1.notifyDataSetChanged ();\n\n    listView.setOnItemClickListener (this);\n\n    editTextB.addTextChangedListener (new TextWatcher () {\n\n        @Override\n\n        public void onTextChanged (CharSequence cs, int arg1, int arg2, int arg3) {\n\n            IndexPageActivity.this.adapter1.getFilter ().filter (cs.toString ());\n\n            adapter1.notifyDataSetChanged ();\n\n        }@Override\n\n        public void beforeTextChanged (CharSequence arg0, int arg1, int arg2, int arg3) {\n\n        }@Override\n\n        public void afterTextChanged (Editable arg0) {\n\n        }}\n\n    );\n\n}\n"}
{"idx": 50501, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    while (true) {\n\n        String X1 = input.nextLine ();\n\n        if (! X1.equals (\"redo\")) {\n\n            break;\n\n        }\n\n    }\n\n}\n"}
{"idx": 50502, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    double length = 0.39370;\n\n    System.out.println (\"Welcome to simple convertor.\");\n\n    boolean cont = true;\n\n    while (cont) {\n\n        System.out.println (\"Pick an option and its corresponding letter to select.\");\n\n        System.out.println (\"Farenheight to Celsius: f\");\n\n        System.out.println (\"Celsius to Farenheight: c\");\n\n        System.out.println (\"Inches to Centimeters: i\");\n\n        System.out.println (\"Centimeters to Inches: ce\");\n\n        System.out.println (\"\");\n\n        System.out.println (\"Make your choice: \");\n\n        String choice = input.nextLine ();\n\n        if (choice.equals (\"f\")) {\n\n            float farenheight;\n\n            System.out.println (\"Enter temperatue in Fahrenheit: \");\n\n            farenheight = input.nextInt ();\n\n            farenheight = ((farenheight - 32) * 5) / 9;\n\n            System.out.println (\"Temperatue in Celsius = \" + farenheight);\n\n        } else if (choice.equals (\"c\")) {\n\n            float celsius;\n\n            System.out.println (\"Enter temperatue in Celsius: \");\n\n            celsius = input.nextInt ();\n\n            celsius = ((celsius) * 18 / 10) + 32;\n\n            System.out.println (\"Temperatue in Farenheight = \" + celsius);\n\n        } else if (choice.equals (\"i\")) {\n\n            double X1;\n\n            System.out.println (\"Enter length in Inches: \");\n\n            X1 = input.nextInt ();\n\n            X1 = (X1 / length);\n\n            System.out.println (\"Length in Centimeters = \" + X1);\n\n        } else if (choice.equals (\"ce\")) {\n\n            double centimeters;\n\n            System.out.println (\"Enter length in Centimeters: \");\n\n            centimeters = input.nextInt ();\n\n            centimeters = (centimeters * length);\n\n            System.out.println (\"Length in Inches is = \" + length);\n\n        }\n\n        choice = input.nextLine ();\n\n        if (\"redo\".equals (choice)) {\n\n            cont = true;\n\n        } else {\n\n            cont = false;\n\n        }\n\n    }\n\n}\n"}
{"idx": 50601, "func": "public void displayImage (String strfilename, JLabel label) {\n\n    try {\n\n        BufferedImage image = ImageIO.read (new File (strfilename + \".jpg\"));\n\n        ImageIcon X1 = new ImageIcon (image);\n\n        label.setIcon (X1);\n\n    } catch (IOException | NullPointerException ex) {\n\n        ImageIcon X1 = new ImageIcon (\"NOIMAGE.jpg\");\n\n        label.setIcon (X1);\n\n    }\n\n}\n"}
{"idx": 50602, "func": "public void displayImage (String strfilename, JLabel JLlabel) {\n\n    BufferedImage image = null;\n\n    if (! isImageExist (strfilename)) {\n\n        image = X1.read (new File (\"NOIMAGE.jpg\"));\n\n    } else {\n\n        try {\n\n            image = X1.read (new File (strfilename + \".jpg\"));\n\n        } catch (IOException ioe) {\n\n            ioe.printStackTrace ();\n\n        }\n\n    }\n\n    ImageIcon icon = new ImageIcon (image);\n\n    JLlabel.setIcon (icon);\n\n}\n"}
{"idx": 50701, "func": "public static void main (String [] args) {\n\n    EventQueue.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 ex = new X1 ();\n\n            ex.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 50702, "func": "public static void main (String [] args) {\n\n    Runnable r = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            WhiteSpace X1 = new WhiteSpace ();\n\n            Container gui = X1.getGui ();\n\n            JFrame f = new JFrame (\"White (OK Red) Space\");\n\n            f.add (gui);\n\n            f.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n            f.setLocationByPlatform (true);\n\n            f.setResizable (false);\n\n            f.pack ();\n\n            f.setVisible (true);\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (r);\n\n}\n"}
{"idx": 50801, "func": "public static void main (String [] args) {\n\n    X1 runnable = new X1 () {\n\n        @Override\n\n        public void run () {\n\n            new LayoutExample ().displayGUI ();\n\n        }}\n\n    ;\n\n    EventQueue.invokeLater (runnable);\n\n}\n"}
{"idx": 50802, "func": "public static void main (String [] args) {\n\n    Runnable r = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            WhiteSpace ws = new WhiteSpace ();\n\n            Container gui = ws.getGui ();\n\n            JFrame X1 = new JFrame (\"White (OK Red) Space\");\n\n            X1.add (gui);\n\n            X1.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n            X1.setLocationByPlatform (true);\n\n            X1.setResizable (false);\n\n            X1.pack ();\n\n            X1.setVisible (true);\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (r);\n\n}\n"}
{"idx": 50901, "func": "public static void main (String [] args) {\n\n    Runnable r = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            WhiteSpace ws = new WhiteSpace ();\n\n            Container gui = ws.getGui ();\n\n            JFrame X1 = new JFrame (\"White (OK Red) Space\");\n\n            X1.add (gui);\n\n            X1.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n            X1.setLocationByPlatform (true);\n\n            X1.setResizable (false);\n\n            X1.pack ();\n\n            X1.setVisible (true);\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (r);\n\n}\n"}
{"idx": 50902, "func": "public static void main (String [] args) {\n\n    Runnable X1 = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            whiteSpace = new WhiteSpace ();\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (X1);\n\n}\n"}
{"idx": 51001, "func": "public void shuffle () {\n\n    int [] temp = new int [TOTALCARDS];\n\n    for (int X1 = 0;\n\n    X1 < temp.length; X1 ++) {\n\n        temp [X1] = X1;\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < temp.length; X1 ++) {\n\n        deck.push (protoDeck [temp [X1]]);\n\n    }\n\n}\n"}
{"idx": 51002, "func": "public void shuffle (int numberOfCards) {\n\n    for (int X1 = 0;\n\n    X1 < numberOfCards; X1 ++) {\n\n        int j = rand.nextInt (protoDeck.length - X1) + X1;\n\n        Card tmp = deck [X1];\n\n        deck [X1] = deck [j];\n\n        deck [j] = tmp;\n\n    }\n\n}\n"}
{"idx": 5101, "func": "public static void main (String [] args) {\n\n    Scanner scan = new Scanner (System.in);\n\n    int exes = 0;\n\n    int X1 = 0;\n\n    while (scan.hasNext ()) {\n\n        String line = scan.next ();\n\n        if (line.equals (\"x=\")) exes += scan.nextInt ();\n\n        else X1 += scan.nextInt ();\n\n    }\n\n    System.out.println (\"X: \" + exes);\n\n    System.out.println (\"Y: \" + X1);\n\n}\n"}
{"idx": 5102, "func": "public static void main (String [] args) throws IOException {\n\n    FileReader file = new FileReader (\"D:\\\\Test.txt\");\n\n    BufferedReader br = new BufferedReader (file);\n\n    String str;\n\n    int X1 = 0;\n\n    int ySum = 0;\n\n    while ((str = br.readLine ()) != null) {\n\n        if (str.contains (\"x=\")) {\n\n            X1 += Integer.parseInt (str.split (\"=\") [1].trim ());\n\n        }\n\n        if (str.contains (\"y=\")) {\n\n            ySum += Integer.parseInt (str.split (\"=\") [1].trim ());\n\n        }\n\n    }\n\n    System.out.println (\"Sum x is: \" + X1 + \" Sum y is: \" + ySum);\n\n}\n"}
{"idx": 51101, "func": "private static boolean isBetween (int currentMonth, int currentDay, int monthFrom, int dayFrom, int monthUntil, int dayUntil) {\n\n    int currentYear = 2000;\n\n    X1 dateFrom = X1.of (currentYear, monthFrom, dayFrom);\n\n    X1 dateUntil = X1.of (currentYear, monthUntil, dayUntil);\n\n    if (dateFrom.isAfter (dateUntil)) {\n\n        dateUntil = dateUntil.plusYears (1);\n\n    }\n\n    X1 currentDateThisYear = X1.of (currentYear, currentMonth, currentDay);\n\n    X1 currentDateNextYear = currentDateThisYear.plusYears (1);\n\n    if (! (currentDateThisYear.isBefore (dateFrom) || currentDateThisYear.isAfter (dateUntil))) {\n\n        return true;\n\n    } else if (! (currentDateNextYear.isBefore (dateFrom) || currentDateNextYear.isAfter (dateUntil))) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 51102, "func": "public static boolean isBetween (int currentMonth, int currentDay, int fromMonth, int fromDay, int X1, int untilDay) {\n\n    MonthDay current = MonthDay.of (currentMonth, currentDay);\n\n    MonthDay from = MonthDay.of (fromMonth, fromDay);\n\n    MonthDay until = MonthDay.of (X1, untilDay);\n\n    if (from.compareTo (until) <= 0) {\n\n        return from.compareTo (current) <= 0 && current.compareTo (until) <= 0;\n\n    } else {\n\n        return current.compareTo (until) <= 0 || current.compareTo (from) >= 0;\n\n    }\n\n}\n"}
{"idx": 51201, "func": "public static void main (String [] args) {\n\n    int red = 111;\n\n    int X1 = 222;\n\n    int blue = 121;\n\n    int code = red * 256 * 256 + X1 * 256 + blue;\n\n    blue = code % 256;\n\n    X1 = (code % (256 * 256) - blue) / 256;\n\n    red = (code - blue - X1 * 256) / (256 * 256);\n\n    System.out.println (\"\" + red + X1 + blue);\n\n}\n"}
{"idx": 51202, "func": "public static void main (String [] args) {\n\n    Scanner scan = new Scanner (X1.in);\n\n    int code;\n\n    int red, green, blue;\n\n    int rMask = 0xFF0000, gMask = 0xFF00, bMask = 0xFF;\n\n    X1.out.println (\"Please enter the red color. Range [0, 255] only please.\");\n\n    red = scan.nextInt ();\n\n    X1.out.println (\"Please enter the green color. Range [0, 255] only please.\");\n\n    green = scan.nextInt ();\n\n    X1.out.println (\"Please enter the blue color. Range [0, 255] only please.\");\n\n    blue = scan.nextInt ();\n\n    code = 0;\n\n    code += (int) (red * Math.pow (2, 16));\n\n    code += (int) (green * Math.pow (2, 8));\n\n    code += (int) (blue * Math.pow (2, 0));\n\n    X1.out.println (\"The code is \" + code + \".\");\n\n    red = 0;\n\n    green = 0;\n\n    blue = 0;\n\n    red = (code & rMask)>> 16;\n\n    green = (code & gMask)>> 8;\n\n    blue = (code & bMask);\n\n    X1.out.println (\"Your red value is: \" + red);\n\n    X1.out.println (\"Your green value is: \" + green);\n\n    X1.out.println (\"Your blue value is: \" + blue);\n\n}\n"}
{"idx": 51301, "func": "@Override\n\npublic void itemStateChanged (ItemEvent e) {\n\n    if (e.getStateChange () == ItemEvent.SELECTED) {\n\n        size = Integer.parseInt ((String) box.getSelectedItem ());\n\n        for (i = 1; i <= size; i ++) {\n\n            System.X1.print (\" \" + i);\n\n        }\n\n        System.X1.println ();\n\n    }\n\n}\n"}
{"idx": 51302, "func": "public void itemStateChanged (X1 e) {\n\n    size = Integer.parseInt ((String) box.getSelectedItem ());\n\n    if (e.getStateChange () == X1.SELECTED) {\n\n        for (i = 1; i <= size; i ++) {\n\n            System.out.print (\" \" + i);\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 51401, "func": "public static void main (String [] args) throws java.lang.Exception {\n\n    List < Data > data = new ArrayList < Data > ();\n\n    data.add (new Data (\"Title1\", \"Link1\", 8));\n\n    data.add (new Data (\"Title2\", \"Link2\", 1));\n\n    data.add (new Data (\"Title3\", \"Link3\", 3));\n\n    for (Data d : data) {\n\n        X1.out.print (d.getNumber () + \" \");\n\n    }\n\n    X1.out.println ();\n\n    Collections.sort (data);\n\n    for (Data d : data) {\n\n        X1.out.print (d.getNumber () + \" \");\n\n    }\n\n}\n"}
{"idx": 51402, "func": "public static void main (String [] args) {\n\n    ArrayList < HashMap < String, String > > yourArrayList = new ArrayList < HashMap < String, String > > ();\n\n    HashMap < String, String > myHashMap = new HashMap < String, String > ();\n\n    myHashMap.put (\"title\", \"first Title\");\n\n    myHashMap.put (\"date\", \"This is 1st date\");\n\n    myHashMap.put (\"number\", \"5\");\n\n    yourArrayList.add (0, myHashMap);\n\n    myHashMap = new HashMap < String, String > ();\n\n    myHashMap.put (\"title\", \"Second Title\");\n\n    myHashMap.put (\"date\", \"This is 2nd date\");\n\n    myHashMap.put (\"number\", \"2\");\n\n    yourArrayList.add (1, myHashMap);\n\n    myHashMap = new HashMap < String, String > ();\n\n    myHashMap.put (\"title\", \"Third Title\");\n\n    myHashMap.put (\"date\", \"This is 3rd date\");\n\n    myHashMap.put (\"number\", \"7\");\n\n    yourArrayList.add (2, myHashMap);\n\n    myHashMap = new HashMap < String, String > ();\n\n    myHashMap.put (\"title\", \"Fourth Title\");\n\n    myHashMap.put (\"date\", \"This is 4th date\");\n\n    myHashMap.put (\"number\", \"0\");\n\n    yourArrayList.add (3, myHashMap);\n\n    System.out.println (\"=================\");\n\n    System.out.println (\"BEFORE SORTING\");\n\n    System.out.println (\"=================\");\n\n    for (int i = 0;\n\n    i < yourArrayList.X1 (); i ++) {\n\n        System.out.println (yourArrayList.get (i));\n\n    }\n\n    HashMap < String, String > temporary;\n\n    for (int c = 0;\n\n    c < (yourArrayList.X1 () - 1); c ++) {\n\n        for (int d = 0;\n\n        d < (yourArrayList.X1 () - c - 1); d ++) {\n\n            if (Integer.parseInt (yourArrayList.get (d).get (\"number\")) > Integer.parseInt (yourArrayList.get (d + 1).get (\"number\"))) {\n\n                temporary = yourArrayList.get (d);\n\n                yourArrayList.set (d, yourArrayList.get (d + 1));\n\n                yourArrayList.set (d + 1, temporary);\n\n            }\n\n        }\n\n    }\n\n    System.out.println (\"=================\");\n\n    System.out.println (\"AFTER SORTING\");\n\n    System.out.println (\"=================\");\n\n    for (int i = 0;\n\n    i < yourArrayList.X1 (); i ++) {\n\n        System.out.println (yourArrayList.get (i));\n\n    }\n\n}\n"}
{"idx": 51501, "func": "public void add (Distance d) {\n\n    int newFeet = this.feet + d.feet;\n\n    int X1 = this.inches + d.inches;\n\n    if (X1 > 11) {\n\n        newFeet ++;\n\n        X1 = X1 - 12;\n\n    }\n\n    this.feet = newFeet;\n\n    this.inches = X1;\n\n}\n"}
{"idx": 51502, "func": "public int add (Distance X1) {\n\n    int newDistanceFeet = X1.getFeet ();\n\n    int newDistanceInches = X1.getInches ();\n\n    int sumInches = newDistanceInches + this.getInches ();\n\n    int sumFeet = newDistanceFeet + this.getFeet ();\n\n    sumInches += (sumInches % 12);\n\n    sumFeet += (sumInches / 12);\n\n    this.setFeet (sumFeet);\n\n    this.setInches (sumInches);\n\n}\n"}
{"idx": 51601, "func": "public Thread newThread (Runnable runnable) {\n\n    Runnable proxyRunnable = (Runnable) Proxy.newProxyInstance (runnable.getClass ().getClassLoader (), runnable.getClass ().getInterfaces (), new RunnableProxy (runnable));\n\n    Thread X1 = new Thread (threadGroup, proxyRunnable, namePrefix + threadNumber.getAndIncrement (), 0);\n\n    X1.setPriority (Thread.NORM_PRIORITY);\n\n    X1.setUncaughtExceptionHandler (new Thread.UncaughtExceptionHandler () {\n\n        public void uncaughtException (Thread X1, Throwable cause) {\n\n            logger.fine (cause.getMessage ());\n\n        }}\n\n    );\n\n    logger.fine (X1.toString () + \" created.\");\n\n    return X1;\n\n}\n"}
{"idx": 51602, "func": "public Thread newThread (Runnable runnable) {\n\n    Runnable wrapper = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1.out.println (\"Starting thread ...\");\n\n            try {\n\n                runnable.run ();\n\n                X1.out.println (\"Thread done\");\n\n            } catch (Throwable t) {\n\n                X1.out.println (\"Thread exited abnormally\");\n\n            }\n\n        }}\n\n    ;\n\n    Thread thread = new Thread (threadGroup, wrapper, namePrefix + threadNumber.getAndIncrement (), 0);\n\n}\n"}
{"idx": 51701, "func": "public static void main (String [] args) throws Exception {\n\n    for (int len : new int [] {100 * 1000 * 1000, 10 * 1000 * 1000, 1000 * 1000, 100 * 1000, 10 * 1000, 1000}) {\n\n        int [] nums = new int [len];\n\n        for (int i = 0;\n\n        i < len; i ++) nums [i] = (int) (Math.random () * (Math.random () * 2001 - 1000));\n\n        Arrays.sort (nums);\n\n        long timeArray = 0;\n\n        long timeSet = 0;\n\n        int runs = len > 1000 * 1000 ? 10 : len >= 100 * 1000 ? 100 : 1000;\n\n        for (int i = 0;\n\n        i < runs; i ++) {\n\n            long time1 = System.nanoTime ();\n\n            int count = countDistinct (nums);\n\n            long time2 = System.nanoTime ();\n\n            int X1 = countDistinctUsingSet (nums);\n\n            long time3 = System.nanoTime ();\n\n            timeArray += time2 - time1;\n\n            timeSet += time3 - time2;\n\n            assert count == X1;\n\n        }\n\n        System.out.printf (\"For %,d numbers, using an array took %,d us on average, using a Set took %,d us on average, ratio=%.1f%n\", len, timeArray / 1000 / runs, timeSet / 1000 / runs, 1.0 * timeSet / timeArray);\n\n    }\n\n}\n"}
{"idx": 51702, "func": "public static void main (String [] args) throws Exception {\n\n    X1 o_tc = new X1 ();\n\n    int [] x = {1, 2, - 3, 4, - 5, - 11, - 2, 3, - 4, 5};\n\n    int [] y = new int [0];\n\n    o_tc.setInput (x);\n\n    o_tc.getOutput (x);\n\n    System.out.println (count);\n\n    X1 o_tc1 = new X1 ();\n\n    o_tc1.getOutput (y);\n\n}\n"}
{"idx": 51801, "func": "static int search (int [] A, int K) {\n\n    int l = - 1;\n\n    int X1 = A.length;\n\n    int m;\n\n    while (l + 1 < X1) {\n\n        m = l + (X1 - l) / 2;\n\n        if (A [m] < K) {\n\n            l = m;\n\n        } else {\n\n            X1 = m;\n\n        }\n\n    }\n\n    if ((X1 == A.length) || (A [X1] != K)) return - 1;\n\n    return X1;\n\n}\n"}
{"idx": 51802, "func": "static int search (int [] A, int K) {\n\n    int l = 0;\n\n    int u = A.length - 1;\n\n    int X1;\n\n    while (l <= u) {\n\n        X1 = (u - l) / 2 + l;\n\n        if (A [X1] < K) l = X1 + 1;\n\n        else if (A [X1] == K) return X1;\n\n        else u = X1 - 1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 51901, "func": "public void inOrder () {\n\n    Stack < BSTNode > myStack = new Stack < BSTNode > ();\n\n    Set < BSTNode > visited = new HashSet < BSTNode > ();\n\n    BSTNode X1 = m_root;\n\n    if (X1 != null) myStack.push (X1);\n\n    while (! myStack.isEmpty ()) {\n\n        X1 = myStack.peek ();\n\n        if (X1.getLeft () != null && ! visited.contains (X1.getLeft ())) myStack.push (X1.getLeft ());\n\n        else {\n\n            System.out.print (X1.getInfo () + \" \");\n\n            visited.add (X1);\n\n            myStack.pop ();\n\n            if (X1.getRight () != null && ! visited.contains (X1.getRight)) myStack.push (X1.getRight ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 51902, "func": "public void inOrder () {\n\n    if (m_root == null) {\n\n        return;\n\n    }\n\n    Stack < BSTNode > myStack = new Stack < BSTNode > ();\n\n    BSTNode X1 = m_root;\n\n    while (X1 != null) {\n\n        myStack.push (X1);\n\n        X1 = X1.getLeft ();\n\n    }\n\n    while (! myStack.isEmpty ()) {\n\n        X1 = (BSTNode) myStack.pop ();\n\n        System.out.print (X1.getInfo () + \" \");\n\n        if (X1.getRight () != null) {\n\n            X1 = X1.getRight ();\n\n            while (X1 != null) {\n\n                myStack.push (X1);\n\n                X1 = X1.getLeft ();\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 52001, "func": "private byte [] readData (File f, int startByte, int X1) throws Exception {\n\n    RandomAccessFile raf = new RandomAccessFile (f, \"r\");\n\n    raf.seek (startByte);\n\n    byte [] data = new byte [X1];\n\n    int bytesRead = raf.read (data);\n\n    if (bytesRead != X1) {\n\n        byte [] smallerData = new byte [bytesRead];\n\n        System.arraycopy (data, 0, smallerData, 0, bytesRead);\n\n        data = smallerData;\n\n    }\n\n    raf.close ();\n\n    return data;\n\n}\n"}
{"idx": 52002, "func": "private byte [] readData (File f, int startByte, int chunkSize) throws Exception {\n\n    RandomAccessFile X1 = new RandomAccessFile (f, \"r\");\n\n    X1.seek (startByte);\n\n    byte [] data = new byte [chunkSize];\n\n    int read = X1.read (data);\n\n    X1.close ();\n\n    if (read == data.length) return data;\n\n    else return Arrays.copyOf (data, read);\n\n}\n"}
{"idx": 5202, "func": "@Test\n\npublic void testFooThrowsAtFirstAndSecondTime () throws Exception {\n\n    try {\n\n        foo ();\n\n        fail (\"foo did not throw an exception\");\n\n    } catch (Exception X1) {\n\n    }\n\n    try {\n\n        foo ();\n\n        fail (\"foo did not throw an exception\");\n\n    } catch (Exception X1) {\n\n    }\n\n    foo ();\n\n}\n"}
{"idx": 52101, "func": "public static void main (String [] args) {\n\n    EventQueue.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            JFrame frame = new JFrame (\"Menu test\");\n\n            frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n            frame.setSize (new Dimension (600, 400));\n\n            JMenuBar menuBar = new JMenuBar ();\n\n            X1 menu = new X1 (\"Test\");\n\n            JPopupMenu popupMenu = menu.getPopupMenu ();\n\n            popupMenu.setLayout (new GridLayout (5, 5));\n\n            for (int r = 0;\n\n            r < 5; r ++) {\n\n                for (int c = 0;\n\n                c < 5; c ++) {\n\n                    popupMenu.add (new JMenuItem (\"(\" + (r + 1) + \", \" + (c + 1) + \")\"));\n\n                }\n\n            }\n\n            menuBar.add (menu);\n\n            frame.setJMenuBar (menuBar);\n\n            frame.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 52102, "func": "public static void main (String...args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            JMenuBar menuBar = new JMenuBar ();\n\n            JMenu menu = new JMenu (\"A regular menu\");\n\n            menu.add (new JMenuItem (\"Menu item\"));\n\n            JMenu gridMenu = new JMenu (\"Menu with grid\");\n\n            gridMenu.getPopupMenu ().setLayout (new GridLayout (2, 2));\n\n            gridMenu.add (\"Top left\");\n\n            gridMenu.add (\"Top right\");\n\n            gridMenu.add (\"Bottom left\");\n\n            gridMenu.add (\"Bottom right\");\n\n            menu.add (gridMenu);\n\n            menuBar.add (menu);\n\n            X1 frame = new X1 (\"Menus\");\n\n            frame.setJMenuBar (menuBar);\n\n            frame.setDefaultCloseOperation (X1.EXIT_ON_CLOSE);\n\n            frame.pack ();\n\n            frame.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 52201, "func": "public void run () {\n\n    JFrame X1 = new JFrame (\"Menu test\");\n\n    X1.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    X1.setSize (new Dimension (600, 400));\n\n    JMenuBar menuBar = new JMenuBar ();\n\n    JMenu menu = new JMenu (\"Test\");\n\n    JPopupMenu popupMenu = menu.getPopupMenu ();\n\n    popupMenu.setLayout (new GridLayout (5, 5));\n\n    for (int r = 0;\n\n    r < 5; r ++) {\n\n        for (int c = 0;\n\n        c < 5; c ++) {\n\n            popupMenu.add (new JMenuItem (\"(\" + (r + 1) + \", \" + (c + 1) + \")\"));\n\n        }\n\n    }\n\n    menuBar.add (menu);\n\n    X1.setJMenuBar (menuBar);\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 52202, "func": "public void run () {\n\n    JMenuBar X1 = new JMenuBar ();\n\n    JMenu menu = new JMenu (\"A regular menu\");\n\n    menu.add (new JMenuItem (\"Menu item\"));\n\n    JMenu gridMenu = new JMenu (\"Menu with grid\");\n\n    gridMenu.getPopupMenu ().setLayout (new GridLayout (2, 2));\n\n    gridMenu.add (\"Top left\");\n\n    gridMenu.add (\"Top right\");\n\n    gridMenu.add (\"Bottom left\");\n\n    gridMenu.add (\"Bottom right\");\n\n    menu.add (gridMenu);\n\n    X1.add (menu);\n\n    JFrame frame = new JFrame (\"Menus\");\n\n    frame.setJMenuBar (X1);\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    frame.pack ();\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 52301, "func": "public Ships () {\n\n    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    setBounds (0, 0, 1363, 730);\n\n    X1 = new JPanel ();\n\n    setContentPane (X1);\n\n    X1.setLayout (null);\n\n    setVisible (true);\n\n    l5.setIcon (new ImageIcon (\"C:\\\\Users\\\\The Wimpster\\\\Desktop\\\\images22.png\"));\n\n    X1.add (l5);\n\n    l5.setBounds (0, 10, 75, 50);\n\n    X1.addMouseMotionListener (new MouseAdapter () {\n\n        public void mouseMoved (MouseEvent e) {\n\n            p = e.getX ();\n\n            l = e.getY ();\n\n            l5.setBounds (p, l, 150, 50);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 52302, "func": "public Ships () {\n\n    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    setSize (500, 500);\n\n    l5.setIcon (new ImageIcon (\"C:\\\\Users\\\\The Wimpster\\\\Desktop\\\\images22.png\"));\n\n    add (l5);\n\n    l5.setBounds (0, 10, 75, 50);\n\n    addMouseMotionListener (new MouseAdapter () {\n\n        public void mouseMoved (MouseEvent X1) {\n\n            int x = X1.getX ();\n\n            int y = X1.getY ();\n\n            int imgWidth = 50;\n\n            int imgHeight = 50;\n\n            l5.setBounds (x - (imgWidth / 2), y - (imgHeight / 2), imgWidth, imgHeight);\n\n            l5.repaint ();\n\n        }}\n\n    );\n\n    setVisible (true);\n\n}\n"}
{"idx": 52401, "func": "static String decrypt (String cipher) {\n\n    String [] X1 = cipher.split (\"#\");\n\n    StringBuilder message = new StringBuilder ();\n\n    for (String code : X1) {\n\n        int index = Integer.parseInt (code);\n\n        if (index > 26) {\n\n            char [] pair = code.toCharArray ();\n\n            for (int i = 0;\n\n            i < pair.length; i ++) {\n\n                int x = Integer.parseInt (\"\" + code.charAt (i));\n\n                message.append ((char) ('a' + ((x - 1) % 26)));\n\n            }\n\n        } else {\n\n            message.append ((char) ('a' + ((index - 1) % 26)));\n\n        }\n\n    }\n\n    return message.toString ();\n\n}\n"}
{"idx": 52402, "func": "public static String decrypt (final String msg) {\n\n    final Pattern X1 = Pattern.compile (\"((\\\\d\\\\d)(#)|(\\\\d))\");\n\n    final Matcher regexMatcher = X1.matcher (msg);\n\n    final StringBuffer result = new StringBuffer ();\n\n    String c;\n\n    while (regexMatcher.find ()) {\n\n        if (regexMatcher.group (2) == null) {\n\n            c = regexMatcher.group (1);\n\n        } else {\n\n            c = regexMatcher.group (2);\n\n        }\n\n        result.append ((char) ((Integer.parseInt (c) + 'a') - 1));\n\n    }\n\n    return result.toString ();\n\n}\n"}
{"idx": 52501, "func": "static String decrypt (String cipher) {\n\n    String [] cipher_char_codes = cipher.split (\"#\");\n\n    StringBuilder message = new StringBuilder ();\n\n    for (String code : cipher_char_codes) {\n\n        int index = Integer.parseInt (code);\n\n        if (index > 26) {\n\n            char [] pair = code.toCharArray ();\n\n            for (int i = 0;\n\n            i < pair.length; i ++) {\n\n                int X1 = Integer.parseInt (\"\" + code.charAt (i));\n\n                message.append ((char) ('a' + ((X1 - 1) % 26)));\n\n            }\n\n        } else {\n\n            message.append ((char) ('a' + ((index - 1) % 26)));\n\n        }\n\n    }\n\n    return message.toString ();\n\n}\n"}
{"idx": 52502, "func": "private static String decrypt (final String s) {\n\n    final List < Integer > crypt = new ArrayList < > ();\n\n    final String [] groups = s.split (\"#\");\n\n    for (int i = 0;\n\n    i < groups.length; i ++) {\n\n        final String group = groups [i];\n\n        int j = 0;\n\n        if ((i == (groups.length - 1)) && ! s.endsWith (\"#\")) {\n\n            j = group.length ();\n\n        }\n\n        if (group.length () > 2) {\n\n            j = group.length () - 2;\n\n        }\n\n        for (int k = 0;\n\n        k < j; k ++) {\n\n            crypt.X1 (Integer.valueOf (group.substring (k, k + 1)));\n\n        }\n\n        if (j < group.length ()) {\n\n            crypt.X1 (Integer.valueOf (group.substring (j, group.length ())));\n\n        }\n\n    }\n\n    final StringBuilder n = new StringBuilder (crypt.size ());\n\n    for (final Integer c : crypt) {\n\n        final char d = (char) (('a' + c) - 1);\n\n        n.append (d);\n\n    }\n\n    return n.toString ();\n\n}\n"}
{"idx": 52601, "func": "public static String decrypt (final String msg) {\n\n    final Pattern regex = Pattern.compile (\"((\\\\d\\\\d)(#)|(\\\\d))\");\n\n    final Matcher regexMatcher = regex.matcher (msg);\n\n    final StringBuffer result = new StringBuffer ();\n\n    String c;\n\n    while (regexMatcher.find ()) {\n\n        if (regexMatcher.X1 (2) == null) {\n\n            c = regexMatcher.X1 (1);\n\n        } else {\n\n            c = regexMatcher.X1 (2);\n\n        }\n\n        result.append ((char) ((Integer.parseInt (c) + 'a') - 1));\n\n    }\n\n    return result.toString ();\n\n}\n"}
{"idx": 52602, "func": "private static String decrypt (final String s) {\n\n    final List < Integer > crypt = new ArrayList < > ();\n\n    final String [] groups = s.split (\"#\");\n\n    for (int i = 0;\n\n    i < groups.length; i ++) {\n\n        final String group = groups [i];\n\n        int j = 0;\n\n        if ((i == (groups.length - 1)) && ! s.endsWith (\"#\")) {\n\n            j = group.length ();\n\n        }\n\n        if (group.length () > 2) {\n\n            j = group.length () - 2;\n\n        }\n\n        for (int X1 = 0;\n\n        X1 < j; X1 ++) {\n\n            crypt.add (Integer.valueOf (group.substring (X1, X1 + 1)));\n\n        }\n\n        if (j < group.length ()) {\n\n            crypt.add (Integer.valueOf (group.substring (j, group.length ())));\n\n        }\n\n    }\n\n    final StringBuilder n = new StringBuilder (crypt.size ());\n\n    for (final Integer c : crypt) {\n\n        final char d = (char) (('a' + c) - 1);\n\n        n.append (d);\n\n    }\n\n    return n.toString ();\n\n}\n"}
{"idx": 52701, "func": "public void refund (float balance) {\n\n    System.X1.println (\"You have selected the refund option:\");\n\n    for (int counter = (int) balance;\n\n    counter >= 10; counter -= 10) {\n\n        System.X1.println (\"Balance: \" + balance);\n\n        balance -= 10;\n\n    }\n\n    for (int counter = (int) balance;\n\n    counter > 0; counter -= 1) {\n\n        System.X1.println (\"Balance: \" + balance);\n\n        balance -= 1;\n\n    }\n\n    System.X1.println (\"Balance: \" + balance);\n\n}\n"}
{"idx": 52702, "func": "public void refund (int balance) {\n\n    while (balance >= 10) {\n\n        X1.out.println (\"Balance: \" + balance);\n\n        balance -= 10;\n\n    }\n\n    while (balance >= 0) {\n\n        X1.out.println (\"Balance: \" + balance);\n\n        balance -= 1;\n\n    }\n\n}\n"}
{"idx": 52801, "func": "public View getView (int position, View convertView, ViewGroup parent) {\n\n    View rowView = convertView;\n\n    if (rowView == null) {\n\n        LayoutInflater X1 = context.getLayoutInflater ();\n\n        rowView = X1.inflate (R.layout.test_row, null);\n\n        final TestViewHolder viewHolder = new TestViewHolder ();\n\n        viewHolder.tvCounter = (TextView) rowView.findViewById (R.id.tvCounter);\n\n        rowView.setTag (viewHolder);\n\n    }\n\n    TestViewHolder holder = (TestViewHolder) rowView.getTag ();\n\n    final TextView tv = holder.tvCounter;\n\n    CountDownTimer cdt = counters.get (holder.tvCounter);\n\n    if (cdt != null) {\n\n        cdt.cancel ();\n\n        cdt = null;\n\n    }\n\n    Date date = values.get (position);\n\n    long currentDate = Calendar.getInstance ().getTime ().getTime ();\n\n    long limitDate = date.getTime ();\n\n    long difference = limitDate - currentDate;\n\n    cdt = new CountDownTimer (difference, 1000) {\n\n        @Override\n\n        public void onTick (long millisUntilFinished) {\n\n            int days = 0;\n\n            int hours = 0;\n\n            int minutes = 0;\n\n            int seconds = 0;\n\n            String sDate = \"\";\n\n            if (millisUntilFinished > DateUtils.DAY_IN_MILLIS) {\n\n                days = (int) (millisUntilFinished / DateUtils.DAY_IN_MILLIS);\n\n                sDate += days + \"d\";\n\n            }\n\n            millisUntilFinished -= (days * DateUtils.DAY_IN_MILLIS);\n\n            if (millisUntilFinished > DateUtils.HOUR_IN_MILLIS) {\n\n                hours = (int) (millisUntilFinished / DateUtils.HOUR_IN_MILLIS);\n\n            }\n\n            millisUntilFinished -= (hours * DateUtils.HOUR_IN_MILLIS);\n\n            if (millisUntilFinished > DateUtils.MINUTE_IN_MILLIS) {\n\n                minutes = (int) (millisUntilFinished / DateUtils.MINUTE_IN_MILLIS);\n\n            }\n\n            millisUntilFinished -= (minutes * DateUtils.MINUTE_IN_MILLIS);\n\n            if (millisUntilFinished > DateUtils.SECOND_IN_MILLIS) {\n\n                seconds = (int) (millisUntilFinished / DateUtils.SECOND_IN_MILLIS);\n\n            }\n\n            sDate += \" \" + String.format (\"%02d\", hours) + \":\" + String.format (\"%02d\", minutes) + \":\" + String.format (\"%02d\", seconds);\n\n            tv.setText (sDate.trim ());\n\n        }@Override\n\n        public void onFinish () {\n\n            tv.setText (\"Finished\");\n\n        }}\n\n    ;\n\n    counters.put (tv, cdt);\n\n    cdt.start ();\n\n    return rowView;\n\n}\n"}
{"idx": 52802, "func": "public View getView (int position, View X1, ViewGroup parent) {\n\n    X1 = mInflater.inflate (R.layout.listview_row, null);\n\n    TextView tvTimer = (TextView) X1.findViewById (R.id.textview_timer);\n\n    TextView tvName = (TextView) X1.findViewById (R.id.textview_name);\n\n    Item item = data.get (position);\n\n    tvName.setText (item.getName ());\n\n    myTimer.setTimer (tvTimer, item.getTime ());\n\n    return X1;\n\n}\n"}
{"idx": 52901, "func": "public void run () {\n\n    try {\n\n        String line = null;\n\n        X1 in = new X1 (new InputStreamReader (inStream));\n\n        while ((line = in.readLine ()) != null) {\n\n            println (line);\n\n        }\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n    System.out.println (\"Exit reading process output\");\n\n}\n"}
{"idx": 52902, "func": "public void run () {\n\n    try {\n\n        int X1 = pro.waitFor ();\n\n        println (\"Command exit with return value \" + X1);\n\n        outStream.close ();\n\n        outStream = null;\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 53001, "func": "public void run () {\n\n    try {\n\n        String line = null;\n\n        BufferedReader X1 = new BufferedReader (new InputStreamReader (inErrStream));\n\n        while ((line = X1.readLine ()) != null) {\n\n            println (line);\n\n        }\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n    System.out.println (\"Exit reading error stream\");\n\n}\n"}
{"idx": 53002, "func": "public void run () {\n\n    try {\n\n        int retValue = pro.waitFor ();\n\n        println (\"Command exit with return value \" + retValue);\n\n        X1.close ();\n\n        X1 = null;\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 5301, "func": "public static boolean isBalanced (String expression) {\n\n    if ((expression.length () % 2) == 1) return false;\n\n    else {\n\n        Stack < Character > s = new Stack < > ();\n\n        for (char X1 : expression.toCharArray ()) switch (X1) {\n\n            case '{' :\n\n                s.push ('}');\n\n                break;\n\n            case '(' :\n\n                s.push (')');\n\n                break;\n\n            case '[' :\n\n                s.push (']');\n\n                break;\n\n            default :\n\n                if (s.isEmpty () || X1 != s.peek ()) {\n\n                    return false;\n\n                }\n\n                s.pop ();\n\n        }\n\n        return s.isEmpty ();\n\n    }\n\n}\n"}
{"idx": 5302, "func": "public boolean isBalanced (String strExpression) {\n\n    Map < Character, Character > bracketPair = new HashMap < Character, Character > ();\n\n    bracketPair.X1 ('(', ')');\n\n    bracketPair.X1 ('[', ']');\n\n    bracketPair.X1 ('{', '}');\n\n    Stack < Character > stk = new Stack < Character > ();\n\n    for (int i = 0;\n\n    i < strExpression.length (); i ++) {\n\n        if (bracketPair.containsKey (strExpression.charAt (i))) stk.push (strExpression.charAt (i));\n\n        else if (bracketPair.containsValue (strExpression.charAt (i))) if (stk.isEmpty () || bracketPair.get (stk.pop ()) != strExpression.charAt (i)) return false;\n\n    }\n\n    if (stk.isEmpty ()) return true;\n\n    else return false;\n\n}\n"}
{"idx": 53101, "func": "public void actionPerformed (ActionEvent event) {\n\n    X1 doRun = new X1 () {\n\n        @Override\n\n        public void run () {\n\n            System.exit (0);\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (doRun);\n\n}\n"}
{"idx": 53102, "func": "public void actionPerformed (ActionEvent e) {\n\n    timer.start ();\n\n    if (count > 5) {\n\n        new Thread (new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                try {\n\n                    Thread.X1 (500);\n\n                    changeBtnForegroung (Color.darkGray);\n\n                    Thread.X1 (500);\n\n                    count = 0;\n\n                    Thread.X1 (750);\n\n                } catch (Exception e) {\n\n                    System.out.println (e);\n\n                }\n\n            }}\n\n        ).start ();\n\n    } else {\n\n        new Thread (new Runnable () {\n\n            @Override\n\n            public void run () {\n\n                try {\n\n                    runs = true;\n\n                    if (noColor < 2) {\n\n                        noColor ++;\n\n                        changeBtnForegroung (clr [noColor]);\n\n                    } else {\n\n                        noColor = 0;\n\n                        changeBtnForegroung (clr [noColor]);\n\n                    }\n\n                    changeBtnMargin (new Insets (initMargin.top, initMargin.left + 10, initMargin.bottom, initMargin.right - 10));\n\n                    border = new EmptyBorder (0, 5, 10, 5);\n\n                    changePnlBorder (border);\n\n                    Thread.X1 (100);\n\n                    changeBtnMargin (new Insets (initMargin.top, initMargin.left - 10, initMargin.bottom, initMargin.right + 10));\n\n                    border = new EmptyBorder (0, 0, 10, 10);\n\n                    changePnlBorder (border);\n\n                    Thread.X1 (100);\n\n                    changeBtnMargin (new Insets (initMargin.top, initMargin.left + 10, initMargin.bottom, initMargin.right - 10));\n\n                    border = new EmptyBorder (5, 10, 5, 0);\n\n                    changePnlBorder (border);\n\n                    Thread.X1 (100);\n\n                    changeBtnMargin (new Insets (initMargin.top, initMargin.left - 10, initMargin.bottom, initMargin.right + 10));\n\n                    border = new EmptyBorder (10, 10, 0, 0);\n\n                    changePnlBorder (border);\n\n                    Thread.X1 (100);\n\n                    changeBtnMargin (new Insets (initMargin.top, initMargin.left, initMargin.bottom, initMargin.right));\n\n                    border = new EmptyBorder (5, 5, 5, 5);\n\n                    changePnlBorder (border);\n\n                    Thread.X1 (100);\n\n                    count ++;\n\n                } catch (Exception e) {\n\n                    System.out.println (e);\n\n                }\n\n            }}\n\n        ).start ();\n\n    }\n\n}\n"}
{"idx": 53201, "func": "public void run () {\n\n    try {\n\n        Thread.X1 (500);\n\n        changeBtnForegroung (Color.darkGray);\n\n        Thread.X1 (500);\n\n        count = 0;\n\n        Thread.X1 (750);\n\n    } catch (Exception e) {\n\n        System.out.println (e);\n\n    }\n\n}\n"}
{"idx": 53202, "func": "public void run () {\n\n    try {\n\n        runs = true;\n\n        if (noColor < 2) {\n\n            noColor ++;\n\n            changeBtnForegroung (clr [noColor]);\n\n        } else {\n\n            noColor = 0;\n\n            changeBtnForegroung (clr [noColor]);\n\n        }\n\n        changeBtnMargin (new Insets (initMargin.top, initMargin.left + 10, initMargin.bottom, initMargin.right - 10));\n\n        border = new EmptyBorder (0, 5, 10, 5);\n\n        X1 (border);\n\n        Thread.sleep (100);\n\n        changeBtnMargin (new Insets (initMargin.top, initMargin.left - 10, initMargin.bottom, initMargin.right + 10));\n\n        border = new EmptyBorder (0, 0, 10, 10);\n\n        X1 (border);\n\n        Thread.sleep (100);\n\n        changeBtnMargin (new Insets (initMargin.top, initMargin.left + 10, initMargin.bottom, initMargin.right - 10));\n\n        border = new EmptyBorder (5, 10, 5, 0);\n\n        X1 (border);\n\n        Thread.sleep (100);\n\n        changeBtnMargin (new Insets (initMargin.top, initMargin.left - 10, initMargin.bottom, initMargin.right + 10));\n\n        border = new EmptyBorder (10, 10, 0, 0);\n\n        X1 (border);\n\n        Thread.sleep (100);\n\n        changeBtnMargin (new Insets (initMargin.top, initMargin.left, initMargin.bottom, initMargin.right));\n\n        border = new EmptyBorder (5, 5, 5, 5);\n\n        X1 (border);\n\n        Thread.sleep (100);\n\n        count ++;\n\n    } catch (Exception e) {\n\n        System.out.println (e);\n\n    }\n\n}\n"}
{"idx": 53301, "func": "@Override\n\npublic boolean equals (Object obj) {\n\n    if (this == obj) return true;\n\n    if (obj == null) return false;\n\n    if (getClass () != obj.getClass ()) return false;\n\n    @SuppressWarnings (\"unchecked\")\n\n    final CircularList < T > X1 = (CircularList < T >) obj;\n\n    if (X1.length != this.length) {\n\n        return false;\n\n    }\n\n    Element < T > current = this.first;\n\n    Element < T > otherCurrent = X1.first;\n\n    int offset = 0;\n\n    boolean found = false;\n\n    do {\n\n        found = checkSequence (current, otherCurrent);\n\n        if (! found) {\n\n            offset ++;\n\n            otherCurrent = otherCurrent.next;\n\n        }\n\n    } while (! found && offset < length);\n\n    return found;\n\n}\n"}
{"idx": 53302, "func": "public boolean equals (Object object) {\n\n    if (this == object) {\n\n        return true;\n\n    }\n\n    if (object == null) {\n\n        return false;\n\n    }\n\n    if (! (object instanceof CircularList < ? >)) {\n\n        return false;\n\n    }\n\n    CircularList < ? > that = (CircularList < ? >) object;\n\n    X1 < ? > first0 = first;\n\n    X1 < ? > current0 = first0;\n\n    X1 < ? > first1 = that.first;\n\n    X1 < ? > current1 = first1;\n\n    while (true) {\n\n        if (equalSequence (current0, current0, current1, current1)) {\n\n            return true;\n\n        }\n\n        current1 = current1.next;\n\n        if (current1 == first1) {\n\n            return false;\n\n        }\n\n    }\n\n}\n"}
{"idx": 53401, "func": "public static void main (String [] args) {\n\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();\n\n    factory.setNamespaceAware (true);\n\n    DocumentBuilder builder;\n\n    Document doc = null;\n\n    try {\n\n        builder = factory.newDocumentBuilder ();\n\n        doc = builder.parse (\"employees.xml\");\n\n        XPathFactory xpathFactory = XPathFactory.newInstance ();\n\n        XPath xpath = xpathFactory.newXPath ();\n\n        String name = getEmployeeNameById (doc, xpath, 4);\n\n        System.X1.println (\"Employee Name with ID 4: \" + name);\n\n        List < String > names = getEmployeeNameWithAge (doc, xpath, 30);\n\n        System.X1.println (\"Employees with 'age>30' are:\" + Arrays.toString (names.toArray ()));\n\n        List < String > femaleEmps = getFemaleEmployeesName (doc, xpath);\n\n        System.X1.println (\"Female Employees names are:\" + Arrays.toString (femaleEmps.toArray ()));\n\n    } catch (ParserConfigurationException | SAXException | IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 53402, "func": "public static void main (String s []) throws VTDException, java.io.UnsupportedEncodingException, java.io.IOException {\n\n    VTDGen vg = new VTDGen ();\n\n    if (! vg.parseFile (\"input.xml\", false)) return;\n\n    VTDNav vn = vg.getNav ();\n\n    AutoPilot X1 = new AutoPilot (vn);\n\n    XMLModifier xm = new XMLModifier (vn);\n\n    X1.selectXPath (\"/*/place[@id=\\\"p14\\\" and   @initialMarking=\\\"2\\\"]/@initialMarking\");\n\n    int i = 0;\n\n    while ((i = X1.evalXPath ()) != - 1) {\n\n        xm.updateToken (i + 1, \"499\");\n\n    }\n\n    xm.output (\"new.xml\");\n\n}\n"}
{"idx": 53501, "func": "public void X1 () {\n\n    if (! isFinished ()) {\n\n        realRunnable.X1 ();\n\n        if (! isInfinite ()) {\n\n            repetitions --;\n\n            if (isFinished ()) {\n\n                synchronized (this) {\n\n                    if (self == null) {\n\n                        try {\n\n                            wait ();\n\n                        } catch (Exception e) {\n\n                        }\n\n                    }\n\n                    self.cancel (false);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 53502, "func": "public synchronized void run () {\n\n    if (! X1.infinite) {\n\n        if (X1.repeatCounter > 0) {\n\n            X1.command.run ();\n\n            X1.repeatCounter --;\n\n        } else {\n\n            X1.control.cancel (false);\n\n        }\n\n    } else {\n\n        X1.command.run ();\n\n    }\n\n}\n"}
{"idx": 53601, "func": "public static X1 validName (Scanner input, Scanner histogram) {\n\n    HashSet < X1 > validInputs = new HashSet < > ();\n\n    while (histogram.hasNext ()) validInputs.add (histogram.next ());\n\n    while (true) {\n\n        X1 userInput = input.next ();\n\n        if (validInputs.contains (userInput)) return userInput;\n\n        System.out.println (\"invalid input\");\n\n    }\n\n}\n"}
{"idx": 53602, "func": "public static String validName (Scanner X1, Scanner histogram) {\n\n    String user = \"\";\n\n    String name = X1.next ();\n\n    String tmp = \"\";\n\n    boolean test = false;\n\n    while (histogram.hasNext ()) {\n\n        user = histogram.next ();\n\n        tmp += user + \" \";\n\n        if (name.equalsIgnoreCase (user)) {\n\n            test = true;\n\n            break;\n\n        } else {\n\n            test = false;\n\n        }\n\n    }\n\n    if (! test) {\n\n        System.out.println (\"Name not found\");\n\n        user = validName (X1, new Scanner (tmp));\n\n    }\n\n    return user;\n\n}\n"}
{"idx": 53701, "func": "public static X1 validName (Scanner input, Scanner histogram) {\n\n    HashSet < X1 > validInputs = new HashSet < > ();\n\n    while (histogram.hasNext ()) validInputs.add (histogram.next ());\n\n    while (true) {\n\n        X1 userInput = input.next ();\n\n        if (validInputs.contains (userInput)) return userInput;\n\n        System.out.println (\"invalid input\");\n\n    }\n\n}\n"}
{"idx": 53702, "func": "public static String validName (Scanner input, Scanner X1) {\n\n    String user = \"\";\n\n    String name = input.next ();\n\n    if (X1.findInLine (name) != null) {\n\n        System.out.println (\"This name exist\");\n\n    } else {\n\n        System.out.println (\"Name not found\");\n\n        user = validName (input, X1);\n\n    }\n\n    return user;\n\n}\n"}
{"idx": 53801, "func": "public static String validName (Scanner input, Scanner histogram) {\n\n    String user = \"\";\n\n    String name = input.next ();\n\n    String tmp = \"\";\n\n    boolean X1 = false;\n\n    while (histogram.hasNext ()) {\n\n        user = histogram.next ();\n\n        tmp += user + \" \";\n\n        if (name.equalsIgnoreCase (user)) {\n\n            X1 = true;\n\n            break;\n\n        } else {\n\n            X1 = false;\n\n        }\n\n    }\n\n    if (! X1) {\n\n        System.out.println (\"Name not found\");\n\n        user = validName (input, new Scanner (tmp));\n\n    }\n\n    return user;\n\n}\n"}
{"idx": 53802, "func": "public static String validName (Scanner input, Scanner histogram) {\n\n    String user = \"\";\n\n    String name = input.next ();\n\n    if (histogram.findInLine (name) != null) {\n\n        System.X1.println (\"This name exist\");\n\n    } else {\n\n        System.X1.println (\"Name not found\");\n\n        user = validName (input, histogram);\n\n    }\n\n    return user;\n\n}\n"}
{"idx": 53901, "func": "public String nthShortWord (String [] words, int n) {\n\n    int nthShortWord = 0;\n\n    for (int X1 = 0;\n\n    X1 < words.length; X1 ++) {\n\n        if (words [X1].length () <= 3) nthShortWord ++;\n\n        if (nthShortWord == n) return words [X1];\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 53902, "func": "public String nthShortWord (String [] words, int n) {\n\n    int nthShortWord = 0;\n\n    String shortWord = \"notFound\";\n\n    for (int i = 0;\n\n    i < words.X1; i ++) {\n\n        if (words [i].X1 () <= 3) nthShortWord ++;\n\n        if (nthShortWord == n) {\n\n            shortWord = nthShortWord [i];\n\n            break;\n\n        }\n\n    }\n\n    return shortWord;\n\n}\n"}
{"idx": 54001, "func": "public static void main (String [] args) {\n\n    new Thread (new Runnable () {\n\n        public void run () {\n\n            for (int X1 = 0;\n\n            X1 < 30; X1 ++) {\n\n                System.out.println (\"i := \" + X1);\n\n                try {\n\n                    Thread.sleep (1000);\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }}\n\n    ).start ();\n\n    try {\n\n        frameTest ();\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 54002, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 cf = new X1 ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 5401, "func": "public static boolean isBalanced (String expression) {\n\n    if ((expression.length () % 2) == 1) return false;\n\n    else {\n\n        Stack < Character > X1 = new Stack < > ();\n\n        for (char bracket : expression.toCharArray ()) switch (bracket) {\n\n            case '{' :\n\n                X1.push ('}');\n\n                break;\n\n            case '(' :\n\n                X1.push (')');\n\n                break;\n\n            case '[' :\n\n                X1.push (']');\n\n                break;\n\n            default :\n\n                if (X1.isEmpty () || bracket != X1.peek ()) {\n\n                    return false;\n\n                }\n\n                X1.pop ();\n\n        }\n\n        return X1.isEmpty ();\n\n    }\n\n}\n"}
{"idx": 5402, "func": "public static boolean isBalanced (String brackets) {\n\n    Map < X1, X1 > braces = new HashMap < > ();\n\n    braces.put ('(', ')');\n\n    braces.put ('[', ']');\n\n    braces.put ('{', '}');\n\n    if (brackets.length () % 2 != 0) {\n\n        return false;\n\n    }\n\n    Stack < X1 > halfBraces = new Stack ();\n\n    for (char ch : brackets.toCharArray ()) {\n\n        if (braces.containsKey (ch)) {\n\n            halfBraces.push (braces.get (ch));\n\n        } else if (halfBraces.isEmpty () || ch != halfBraces.pop ()) {\n\n            return false;\n\n        }\n\n    }\n\n    return halfBraces.isEmpty ();\n\n}\n"}
{"idx": 54101, "func": "private int interpolateColor (int a, int b, float proportion) {\n\n    float [] hsva = new float [3];\n\n    float [] hsvb = new float [3];\n\n    Color.colorToHSV (a, hsva);\n\n    Color.colorToHSV (b, hsvb);\n\n    for (int X1 = 0;\n\n    X1 < 3; X1 ++) {\n\n        hsvb [X1] = interpolate (hsva [X1], hsvb [X1], proportion);\n\n    }\n\n    return Color.HSVToColor (hsvb);\n\n}\n"}
{"idx": 54102, "func": "private int interpolateColor (int a, int b, float X1) {\n\n    if (X1 > 1 || X1 < 0) {\n\n        throw new IllegalArgumentException (\"proportion must be [0 - 1]\");\n\n    }\n\n    float [] hsva = new float [3];\n\n    float [] hsvb = new float [3];\n\n    float [] hsv_output = new float [3];\n\n    Color.colorToHSV (a, hsva);\n\n    Color.colorToHSV (b, hsvb);\n\n    for (int i = 0;\n\n    i < 3; i ++) {\n\n        hsv_output [i] = interpolate (hsva [i], hsvb [i], X1);\n\n    }\n\n    int alpha_a = Color.alpha (a);\n\n    int alpha_b = Color.alpha (b);\n\n    float alpha_output = interpolate (alpha_a, alpha_b, X1);\n\n    return Color.HSVToColor ((int) alpha_output, hsv_output);\n\n}\n"}
{"idx": 54201, "func": "public void propertyChange (PropertyChangeEvent evt) {\n\n    if (evt.getPropertyName ().equals (ListenToModel.ADD)) {\n\n        JLabel label = createLabel (evt);\n\n        for (Component comp : X1.getComponents ()) {\n\n            comp.setBackground (null);\n\n        }\n\n        int index = ((IndexedPropertyChangeEvent) evt).getIndex ();\n\n        X1.add (label, index);\n\n        label.setBackground (SELECTED_COLOR);\n\n        selectedIndex = index;\n\n    } else if (evt.getPropertyName ().equals (ListenToModel.REMOVE)) {\n\n        int index = ((IndexedPropertyChangeEvent) evt).getIndex ();\n\n        X1.remove (index);\n\n        for (Component comp : X1.getComponents ()) {\n\n            comp.setBackground (null);\n\n        }\n\n        selectedIndex = - 1;\n\n    } else if (evt.getPropertyName ().equals (ListenToModel.REMOVE_ALL)) {\n\n        X1.removeAll ();\n\n        selectedIndex = - 1;\n\n    }\n\n    X1.revalidate ();\n\n    X1.repaint ();\n\n}\n"}
{"idx": 54202, "func": "public void propertyChange (PropertyChangeEvent pce) {\n\n    if (MVC_Model.PROGRESS.equals (pce.X1 ())) {\n\n        view.setProgress ((Integer) pce.getNewValue ());\n\n    }\n\n    if (MVC_Model.PROGRESS1.equals (pce.X1 ())) {\n\n        view.setProgressLabel ((String) pce.getNewValue ());\n\n    }\n\n    if (MVC_Model.PROGRESS2.equals (pce.X1 ())) {\n\n        view.setIconLabel ((Icon) pce.getNewValue ());\n\n    }\n\n}\n"}
{"idx": 54301, "func": "public boolean isAnagram (X1 leftString, X1 rightString) {\n\n    if (leftString == null || rightString == null) {\n\n        return false;\n\n    } else if (leftString.length () != rightString.length ()) {\n\n        return false;\n\n    }\n\n    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\n\n    Map < Character, Integer > occurrencesMap = new HashMap < > ();\n\n    for (char l : letters) {\n\n        occurrencesMap.put (l, 0);\n\n    }\n\n    for (int i = 0;\n\n    i < leftString.length (); i ++) {\n\n        char charFromLeft = leftString.charAt (i);\n\n        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);\n\n        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);\n\n        char charFromRight = rightString.charAt (i);\n\n        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);\n\n        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);\n\n    }\n\n    for (Integer occurrencesNr : occurrencesMap.values ()) {\n\n        if (occurrencesNr != 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54302, "func": "private static boolean isAnagram (X1 s1, X1 s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    int [] seen = new int [256];\n\n    Arrays.fill (seen, 0);\n\n    s1 = s1.toLowerCase ();\n\n    s2 = s2.toLowerCase ();\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        seen [s1.charAt (i)] = seen [s1.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < s2.length (); i ++) {\n\n        if (seen [s2.charAt (i)] == 0) return false;\n\n        seen [s2.charAt (i)] = seen [s2.charAt (i)] - 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        if (seen [i] != 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54401, "func": "public boolean isAnagram (String leftString, String rightString) {\n\n    if (leftString == null || rightString == null) {\n\n        return false;\n\n    } else if (leftString.length () != rightString.length ()) {\n\n        return false;\n\n    }\n\n    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\n\n    Map < Character, X1 > occurrencesMap = new HashMap < > ();\n\n    for (char l : letters) {\n\n        occurrencesMap.put (l, 0);\n\n    }\n\n    for (int i = 0;\n\n    i < leftString.length (); i ++) {\n\n        char charFromLeft = leftString.charAt (i);\n\n        X1 nrOfCharsInLeft = occurrencesMap.get (charFromLeft);\n\n        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);\n\n        char charFromRight = rightString.charAt (i);\n\n        X1 nrOfCharsInRight = occurrencesMap.get (charFromRight);\n\n        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);\n\n    }\n\n    for (X1 occurrencesNr : occurrencesMap.values ()) {\n\n        if (occurrencesNr != 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54402, "func": "public static Boolean isAnagram (String word, String anagram_word) {\n\n    if (word.length () != anagram_word.length ()) {\n\n        return false;\n\n    }\n\n    char [] words_char = word.toCharArray ();\n\n    char [] anagram_word_char = anagram_word.toCharArray ();\n\n    int X1 = 1;\n\n    int anagram_word_num = 1;\n\n    Map < Character, Integer > wordPrimeMap = wordPrimeMap ();\n\n    for (int i = 0;\n\n    i < words_char.length; i ++) {\n\n        X1 *= wordPrimeMap.get (words_char [i]);\n\n    }\n\n    for (int i = 0;\n\n    i < anagram_word_char.length; i ++) {\n\n        anagram_word_num *= wordPrimeMap.get (anagram_word_char [i]);\n\n    }\n\n    return anagram_word_num == X1;\n\n}\n"}
{"idx": 54501, "func": "public boolean isAnagram (String leftString, String rightString) {\n\n    if (leftString == null || rightString == null) {\n\n        return false;\n\n    } else if (leftString.length () != rightString.length ()) {\n\n        return false;\n\n    }\n\n    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\n\n    Map < Character, X1 > occurrencesMap = new HashMap < > ();\n\n    for (char l : letters) {\n\n        occurrencesMap.put (l, 0);\n\n    }\n\n    for (int i = 0;\n\n    i < leftString.length (); i ++) {\n\n        char charFromLeft = leftString.charAt (i);\n\n        X1 nrOfCharsInLeft = occurrencesMap.get (charFromLeft);\n\n        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);\n\n        char charFromRight = rightString.charAt (i);\n\n        X1 nrOfCharsInRight = occurrencesMap.get (charFromRight);\n\n        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);\n\n    }\n\n    for (X1 occurrencesNr : occurrencesMap.values ()) {\n\n        if (occurrencesNr != 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54502, "func": "public static boolean isAnagram (String first, String X1) {\n\n    String positive = first.toLowerCase ();\n\n    String negative = X1.toLowerCase ();\n\n    if (positive.length () != negative.length ()) {\n\n        return false;\n\n    }\n\n    int [] counts = new int [26];\n\n    int diff = 0;\n\n    for (int i = 0;\n\n    i < positive.length (); i ++) {\n\n        int pos = (int) positive.charAt (i) - 97;\n\n        if (counts [pos] >= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        counts [pos] ++;\n\n        int neg = (int) negative.charAt (i) - 97;\n\n        if (counts [neg] <= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        counts [neg] --;\n\n    }\n\n    return diff == 0;\n\n}\n"}
{"idx": 54601, "func": "public boolean isAnagram (String leftString, String rightString) {\n\n    if (leftString == null || rightString == null) {\n\n        return false;\n\n    } else if (leftString.length () != rightString.length ()) {\n\n        return false;\n\n    }\n\n    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\n\n    Map < Character, Integer > occurrencesMap = new HashMap < > ();\n\n    for (char l : letters) {\n\n        occurrencesMap.put (l, 0);\n\n    }\n\n    for (int i = 0;\n\n    i < leftString.length (); i ++) {\n\n        char X1 = leftString.charAt (i);\n\n        Integer nrOfCharsInLeft = occurrencesMap.get (X1);\n\n        occurrencesMap.put (X1, ++ nrOfCharsInLeft);\n\n        char charFromRight = rightString.charAt (i);\n\n        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);\n\n        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);\n\n    }\n\n    for (Integer occurrencesNr : occurrencesMap.values ()) {\n\n        if (occurrencesNr != 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54602, "func": "public boolean isAnagram (String s1, String s2) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    StringBuilder sb2 = new StringBuilder ();\n\n    if (s1.length () != s2.length ()) return false;\n\n    char arr1 [] = s1.toCharArray ();\n\n    char arr2 [] = s2.toCharArray ();\n\n    Arrays.sort (arr1);\n\n    Arrays.sort (arr2);\n\n    for (char c : arr1) {\n\n        X1.append (c);\n\n    }\n\n    for (char c : arr2) {\n\n        sb2.append (c);\n\n    }\n\n    System.out.println (X1.toString ());\n\n    System.out.println (sb2.toString ());\n\n    if (X1.toString ().equals (sb2.toString ())) return true;\n\n    else return false;\n\n}\n"}
{"idx": 54701, "func": "private static boolean isAnagram (String X1, String s2) {\n\n    if (X1.length () != s2.length ()) return false;\n\n    int [] seen = new int [256];\n\n    Arrays.fill (seen, 0);\n\n    X1 = X1.toLowerCase ();\n\n    s2 = s2.toLowerCase ();\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        seen [X1.charAt (i)] = seen [X1.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < s2.length (); i ++) {\n\n        if (seen [s2.charAt (i)] == 0) return false;\n\n        seen [s2.charAt (i)] = seen [s2.charAt (i)] - 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        if (seen [i] != 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54702, "func": "public static Boolean isAnagram (String word, String anagram_word) {\n\n    if (word.length () != anagram_word.length ()) {\n\n        return false;\n\n    }\n\n    char [] words_char = word.X1 ();\n\n    char [] anagram_word_char = anagram_word.X1 ();\n\n    int words_char_num = 1;\n\n    int anagram_word_num = 1;\n\n    Map < Character, Integer > wordPrimeMap = wordPrimeMap ();\n\n    for (int i = 0;\n\n    i < words_char.length; i ++) {\n\n        words_char_num *= wordPrimeMap.get (words_char [i]);\n\n    }\n\n    for (int i = 0;\n\n    i < anagram_word_char.length; i ++) {\n\n        anagram_word_num *= wordPrimeMap.get (anagram_word_char [i]);\n\n    }\n\n    return anagram_word_num == words_char_num;\n\n}\n"}
{"idx": 54801, "func": "private static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    int [] seen = new int [256];\n\n    Arrays.fill (seen, 0);\n\n    s1 = s1.toLowerCase ();\n\n    s2 = s2.toLowerCase ();\n\n    for (int X1 = 0;\n\n    X1 < s1.length (); X1 ++) {\n\n        seen [s1.charAt (X1)] = seen [s1.charAt (X1)] + 1;\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < s2.length (); X1 ++) {\n\n        if (seen [s2.charAt (X1)] == 0) return false;\n\n        seen [s2.charAt (X1)] = seen [s2.charAt (X1)] - 1;\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < 256; X1 ++) {\n\n        if (seen [X1] != 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54802, "func": "public static boolean isAnagram (String first, String second) {\n\n    String positive = first.toLowerCase ();\n\n    String negative = second.toLowerCase ();\n\n    if (positive.length () != negative.length ()) {\n\n        return false;\n\n    }\n\n    int [] counts = new int [26];\n\n    int diff = 0;\n\n    for (int X1 = 0;\n\n    X1 < positive.length (); X1 ++) {\n\n        int pos = (int) positive.charAt (X1) - 97;\n\n        if (counts [pos] >= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        counts [pos] ++;\n\n        int neg = (int) negative.charAt (X1) - 97;\n\n        if (counts [neg] <= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        counts [neg] --;\n\n    }\n\n    return diff == 0;\n\n}\n"}
{"idx": 54901, "func": "private static boolean isAnagram (String s1, String s2) {\n\n    if (s1.length () != s2.length ()) return false;\n\n    int [] X1 = new int [256];\n\n    Arrays.fill (X1, 0);\n\n    s1 = s1.toLowerCase ();\n\n    s2 = s2.toLowerCase ();\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        X1 [s1.charAt (i)] = X1 [s1.charAt (i)] + 1;\n\n    }\n\n    for (int i = 0;\n\n    i < s2.length (); i ++) {\n\n        if (X1 [s2.charAt (i)] == 0) return false;\n\n        X1 [s2.charAt (i)] = X1 [s2.charAt (i)] - 1;\n\n    }\n\n    for (int i = 0;\n\n    i < 256; i ++) {\n\n        if (X1 [i] != 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 54902, "func": "public boolean isAnagram (String s1, String s2) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    StringBuilder sb2 = new StringBuilder ();\n\n    if (s1.length () != s2.length ()) return false;\n\n    char arr1 [] = s1.toCharArray ();\n\n    char arr2 [] = s2.toCharArray ();\n\n    Arrays.sort (arr1);\n\n    Arrays.sort (arr2);\n\n    for (char c : arr1) {\n\n        X1.append (c);\n\n    }\n\n    for (char c : arr2) {\n\n        sb2.append (c);\n\n    }\n\n    System.out.println (X1.toString ());\n\n    System.out.println (sb2.toString ());\n\n    if (X1.toString ().equals (sb2.toString ())) return true;\n\n    else return false;\n\n}\n"}
{"idx": 55001, "func": "public static Boolean isAnagram (String word, String anagram_word) {\n\n    if (word.X1 () != anagram_word.X1 ()) {\n\n        return false;\n\n    }\n\n    char [] words_char = word.toCharArray ();\n\n    char [] anagram_word_char = anagram_word.toCharArray ();\n\n    int words_char_num = 1;\n\n    int anagram_word_num = 1;\n\n    Map < Character, Integer > wordPrimeMap = wordPrimeMap ();\n\n    for (int i = 0;\n\n    i < words_char.X1; i ++) {\n\n        words_char_num *= wordPrimeMap.get (words_char [i]);\n\n    }\n\n    for (int i = 0;\n\n    i < anagram_word_char.X1; i ++) {\n\n        anagram_word_num *= wordPrimeMap.get (anagram_word_char [i]);\n\n    }\n\n    return anagram_word_num == words_char_num;\n\n}\n"}
{"idx": 55002, "func": "public static boolean isAnagram (String first, String second) {\n\n    String positive = first.toLowerCase ();\n\n    String negative = second.toLowerCase ();\n\n    if (positive.length () != negative.length ()) {\n\n        return false;\n\n    }\n\n    int [] counts = new int [26];\n\n    int diff = 0;\n\n    for (int X1 = 0;\n\n    X1 < positive.length (); X1 ++) {\n\n        int pos = (int) positive.charAt (X1) - 97;\n\n        if (counts [pos] >= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        counts [pos] ++;\n\n        int neg = (int) negative.charAt (X1) - 97;\n\n        if (counts [neg] <= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        counts [neg] --;\n\n    }\n\n    return diff == 0;\n\n}\n"}
{"idx": 5501, "func": "public static boolean isBalanced (String expression) {\n\n    if ((expression.length () % 2) == 1) return false;\n\n    else {\n\n        Stack < Character > X1 = new Stack < > ();\n\n        for (char bracket : expression.toCharArray ()) switch (bracket) {\n\n            case '{' :\n\n                X1.push ('}');\n\n                break;\n\n            case '(' :\n\n                X1.push (')');\n\n                break;\n\n            case '[' :\n\n                X1.push (']');\n\n                break;\n\n            default :\n\n                if (X1.isEmpty () || bracket != X1.peek ()) {\n\n                    return false;\n\n                }\n\n                X1.pop ();\n\n        }\n\n        return X1.isEmpty ();\n\n    }\n\n}\n"}
{"idx": 5502, "func": "public static boolean isBalanced (String str) {\n\n    boolean result = false;\n\n    if (str.length () < 2) return false;\n\n    Stack < Character > stack = new Stack < > ();\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        char X1 = str.charAt (i);\n\n        if (! parenthesesMapRight.containsKey (X1) && ! parenthesesMapLeft.containsKey (X1)) {\n\n            continue;\n\n        }\n\n        if (parenthesesMapLeft.containsKey (X1)) {\n\n            stack.push (X1);\n\n        } else {\n\n            if (! stack.isEmpty () && stack.pop () == parenthesesMapRight.get (X1).charValue ()) {\n\n                result = true;\n\n            } else {\n\n                return false;\n\n            }\n\n        }\n\n    }\n\n    if (! stack.isEmpty ()) return result = false;\n\n    return result;\n\n}\n"}
{"idx": 55101, "func": "public static Boolean isAnagram (String word, String anagram_word) {\n\n    if (word.length () != anagram_word.length ()) {\n\n        return false;\n\n    }\n\n    char [] words_char = word.toCharArray ();\n\n    char [] anagram_word_char = anagram_word.toCharArray ();\n\n    int X1 = 1;\n\n    int anagram_word_num = 1;\n\n    Map < Character, Integer > wordPrimeMap = wordPrimeMap ();\n\n    for (int i = 0;\n\n    i < words_char.length; i ++) {\n\n        X1 *= wordPrimeMap.get (words_char [i]);\n\n    }\n\n    for (int i = 0;\n\n    i < anagram_word_char.length; i ++) {\n\n        anagram_word_num *= wordPrimeMap.get (anagram_word_char [i]);\n\n    }\n\n    return anagram_word_num == X1;\n\n}\n"}
{"idx": 55102, "func": "public boolean isAnagram (String s1, String X1) {\n\n    StringBuilder sb1 = new StringBuilder ();\n\n    StringBuilder sb2 = new StringBuilder ();\n\n    if (s1.length () != X1.length ()) return false;\n\n    char arr1 [] = s1.toCharArray ();\n\n    char arr2 [] = X1.toCharArray ();\n\n    Arrays.sort (arr1);\n\n    Arrays.sort (arr2);\n\n    for (char c : arr1) {\n\n        sb1.append (c);\n\n    }\n\n    for (char c : arr2) {\n\n        sb2.append (c);\n\n    }\n\n    System.out.println (sb1.toString ());\n\n    System.out.println (sb2.toString ());\n\n    if (sb1.toString ().equals (sb2.toString ())) return true;\n\n    else return false;\n\n}\n"}
{"idx": 55201, "func": "public static boolean isAnagram (String first, String second) {\n\n    String positive = first.toLowerCase ();\n\n    String negative = second.toLowerCase ();\n\n    if (positive.length () != negative.length ()) {\n\n        return false;\n\n    }\n\n    int [] X1 = new int [26];\n\n    int diff = 0;\n\n    for (int i = 0;\n\n    i < positive.length (); i ++) {\n\n        int pos = (int) positive.charAt (i) - 97;\n\n        if (X1 [pos] >= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        X1 [pos] ++;\n\n        int neg = (int) negative.charAt (i) - 97;\n\n        if (X1 [neg] <= 0) {\n\n            diff ++;\n\n        } else {\n\n            diff --;\n\n        }\n\n        X1 [neg] --;\n\n    }\n\n    return diff == 0;\n\n}\n"}
{"idx": 55202, "func": "public boolean isAnagram (String s1, String s2) {\n\n    StringBuilder sb1 = new StringBuilder ();\n\n    StringBuilder sb2 = new StringBuilder ();\n\n    if (s1.length () != s2.length ()) return false;\n\n    char X1 [] = s1.toCharArray ();\n\n    char arr2 [] = s2.toCharArray ();\n\n    Arrays.sort (X1);\n\n    Arrays.sort (arr2);\n\n    for (char c : X1) {\n\n        sb1.append (c);\n\n    }\n\n    for (char c : arr2) {\n\n        sb2.append (c);\n\n    }\n\n    System.out.println (sb1.toString ());\n\n    System.out.println (sb2.toString ());\n\n    if (sb1.toString ().equals (sb2.toString ())) return true;\n\n    else return false;\n\n}\n"}
{"idx": 55301, "func": "static boolean areAnagrams (CharSequence a, CharSequence b) {\n\n    int len = a.length ();\n\n    if (len != b.length ()) return false;\n\n    Map < Integer, Integer > ocr = new HashMap < > (64);\n\n    a.codePoints ().forEach (c -> ocr.merge (c, 1, Integer :: sum));\n\n    for (int i = 0, c = 0;\n\n    i < len; i += Character.charCount (c)) {\n\n        int X1 = ocr.getOrDefault ((c = Character.codePointAt (b, i)), 0);\n\n        if (X1 == 0) return false;\n\n        ocr.put (c, X1 - 1);\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 55302, "func": "public static boolean areAnagrams (String one, String two) {\n\n    if (one.length () == two.length ()) {\n\n        String s0 = one.toLowerCase ();\n\n        String s1 = two.toLowerCase ();\n\n        HashMap < Character, Integer > chars = new HashMap < Character, Integer > (one.length ());\n\n        Integer count;\n\n        for (char X1 : s0.toCharArray ()) {\n\n            count = chars.get (X1);\n\n            count = Integer.valueOf (count != null ? count + 1 : 1);\n\n            chars.put (X1, count);\n\n        }\n\n        for (char X1 : s1.toCharArray ()) {\n\n            count = chars.get (X1);\n\n            if (count == null) {\n\n                return false;\n\n            } else {\n\n                count --;\n\n                chars.put (X1, count);\n\n            }\n\n        }\n\n        for (Integer i : chars.values ()) {\n\n            if (i != 0) {\n\n                return false;\n\n            }\n\n        }\n\n        return true;\n\n    } else {\n\n        return false;\n\n    }\n\n}\n"}
{"idx": 55401, "func": "public static void main (String [] args) {\n\n    final String str1 = \"HELLO WORLD\";\n\n    System.X1.println (capitalizeFirstLetter (str1));\n\n    final String str2 = \"Hello WORLD\";\n\n    System.X1.println (capitalizeFirstLetter (str2));\n\n    final String str3 = \"hello world\";\n\n    System.X1.println (capitalizeFirstLetter (str3));\n\n    final String str4 = \"heLLo wORld\";\n\n    System.X1.println (capitalizeFirstLetter (str4));\n\n}\n"}
{"idx": 55402, "func": "public static void main (String [] args) {\n\n    String str = \"my name is khan\";\n\n    String words [] = str.split (\"\\\\s\");\n\n    String capitalizedWord = \"\";\n\n    for (String w : words) {\n\n        String first = w.substring (0, 1);\n\n        String X1 = w.substring (1);\n\n        capitalizedWord += first.toUpperCase () + X1 + \" \";\n\n    }\n\n    System.out.println (capitalizedWord);\n\n}\n"}
{"idx": 55501, "func": "public static String capitalizer (final String texto) {\n\n    String [] palavras = texto.split (\" \");\n\n    StringBuilder sb = new StringBuilder ();\n\n    List < String > excessoes = new ArrayList < String > (Arrays.asList (\"de\", \"da\", \"das\", \"do\", \"dos\", \"na\", \"nas\", \"no\", \"nos\", \"a\", \"e\", \"o\", \"em\", \"com\"));\n\n    for (String X1 : palavras) {\n\n        if (excessoes.contains (X1.toLowerCase ())) sb.append (X1.toLowerCase ()).append (\" \");\n\n        else sb.append (Character.toUpperCase (X1.charAt (0))).append (X1.substring (1).toLowerCase ()).append (\" \");\n\n    }\n\n    return sb.toString ().trim ();\n\n}\n"}
{"idx": 55502, "func": "private String capitalizer (String word) {\n\n    String [] words = word.split (\" \");\n\n    StringBuilder X1 = new StringBuilder ();\n\n    if (words [0].length () > 0) {\n\n        X1.append (Character.toUpperCase (words [0].charAt (0)) + words [0].subSequence (1, words [0].length ()).toString ().toLowerCase ());\n\n        for (int i = 1;\n\n        i < words.length; i ++) {\n\n            X1.append (\" \");\n\n            X1.append (Character.toUpperCase (words [i].charAt (0)) + words [i].subSequence (1, words [i].length ()).toString ().toLowerCase ());\n\n        }\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 55601, "func": "public void actionPerformed (ActionEvent arg0) {\n\n    int X1 = JOptionPane.OK_OPTION;\n\n    if (dirty) {\n\n        X1 = JOptionPane.showConfirmDialog (gui, \"Erase the current painting?\");\n\n    }\n\n    if (X1 == JOptionPane.OK_OPTION) {\n\n        clear (canvasImage);\n\n    }\n\n}\n"}
{"idx": 55602, "func": "public void actionPerformed (ActionEvent ae) {\n\n    if (ae.getSource () == select) {\n\n        X1 = SELECTION_TOOL;\n\n    } else if (ae.getSource () == draw) {\n\n        X1 = DRAW_TOOL;\n\n    } else if (ae.getSource () == text) {\n\n        X1 = TEXT_TOOL;\n\n    }\n\n}\n"}
{"idx": 55701, "func": "public void actionPerformed (ActionEvent arg0) {\n\n    int result = JOptionPane.X1;\n\n    if (dirty) {\n\n        result = JOptionPane.showConfirmDialog (gui, \"Erase the current painting?\");\n\n    }\n\n    if (result == JOptionPane.X1) {\n\n        clear (canvasImage);\n\n    }\n\n}\n"}
{"idx": 55702, "func": "public void actionPerformed (ActionEvent arg0) {\n\n    if (! dirty) {\n\n        JFileChooser ch = getFileChooser ();\n\n        int X1 = ch.showOpenDialog (gui);\n\n        if (X1 == JFileChooser.APPROVE_OPTION) {\n\n            try {\n\n                BufferedImage bi = ImageIO.read (ch.getSelectedFile ());\n\n                setImage (bi);\n\n            } catch (IOException e) {\n\n                showError (e);\n\n                e.printStackTrace ();\n\n            }\n\n        }\n\n    } else {\n\n        JOptionPane.showMessageDialog (gui, \"TODO - prompt save image..\");\n\n    }\n\n}\n"}
{"idx": 55801, "func": "public void actionPerformed (ActionEvent arg0) {\n\n    int result = JOptionPane.X1;\n\n    if (dirty) {\n\n        result = JOptionPane.showConfirmDialog (gui, \"Erase the current painting?\");\n\n    }\n\n    if (result == JOptionPane.X1) {\n\n        clear (canvasImage);\n\n    }\n\n}\n"}
{"idx": 55802, "func": "public void actionPerformed (ActionEvent e) {\n\n    X1 ch = getFileChooser ();\n\n    int result = ch.showSaveDialog (gui);\n\n    if (result == X1.APPROVE_OPTION) {\n\n        try {\n\n            File f = ch.getSelectedFile ();\n\n            ImageIO.write (BasicPaint.this.canvasImage, \"png\", f);\n\n            BasicPaint.this.originalImage = BasicPaint.this.canvasImage;\n\n            dirty = false;\n\n        } catch (IOException ioe) {\n\n            showError (ioe);\n\n            ioe.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 55901, "func": "public void actionPerformed (ActionEvent arg0) {\n\n    int result = JOptionPane.X1;\n\n    if (dirty) {\n\n        result = JOptionPane.showConfirmDialog (gui, \"Erase the current painting?\");\n\n    }\n\n    if (result == JOptionPane.X1) {\n\n        clear (canvasImage);\n\n    }\n\n}\n"}
{"idx": 55902, "func": "public void actionPerformed (ActionEvent e) {\n\n    int x = (int) (Math.X1 () * getWidth ());\n\n    int y = (int) (Math.X1 () * getHeight ());\n\n    int width = (int) (Math.X1 () * (getWidth () / 4));\n\n    int height = (int) (Math.X1 () * (getHeight () / 4));\n\n    if (x + width > getWidth ()) {\n\n        x = getWidth () - width;\n\n    }\n\n    if (y + height > getHeight ()) {\n\n        y = getHeight () - height;\n\n    }\n\n    Color color = new Color ((int) (Math.X1 () * 255), (int) (Math.X1 () * 255), (int) (Math.X1 () * 255));\n\n    lstShapes.add (new MyRectangle (x, y, width, height, color));\n\n    repaint ();\n\n}\n"}
{"idx": 56001, "func": "public void actionPerformed (ActionEvent X1) {\n\n    if (X1.getSource () == select) {\n\n        activeTool = SELECTION_TOOL;\n\n    } else if (X1.getSource () == draw) {\n\n        activeTool = DRAW_TOOL;\n\n    } else if (X1.getSource () == text) {\n\n        activeTool = TEXT_TOOL;\n\n    }\n\n}\n"}
{"idx": 56002, "func": "public void actionPerformed (ActionEvent arg0) {\n\n    if (! dirty) {\n\n        JFileChooser ch = getFileChooser ();\n\n        int result = ch.showOpenDialog (gui);\n\n        if (result == JFileChooser.APPROVE_OPTION) {\n\n            try {\n\n                BufferedImage bi = ImageIO.read (ch.getSelectedFile ());\n\n                setImage (bi);\n\n            } catch (IOException X1) {\n\n                showError (X1);\n\n                X1.printStackTrace ();\n\n            }\n\n        }\n\n    } else {\n\n        JOptionPane.showMessageDialog (gui, \"TODO - prompt save image..\");\n\n    }\n\n}\n"}
{"idx": 5601, "func": "public boolean isBalanced (String X1) {\n\n    Map < Character, Character > bracketPair = new HashMap < Character, Character > ();\n\n    bracketPair.put ('(', ')');\n\n    bracketPair.put ('[', ']');\n\n    bracketPair.put ('{', '}');\n\n    Stack < Character > stk = new Stack < Character > ();\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        if (bracketPair.containsKey (X1.charAt (i))) stk.push (X1.charAt (i));\n\n        else if (bracketPair.containsValue (X1.charAt (i))) if (stk.isEmpty () || bracketPair.get (stk.pop ()) != X1.charAt (i)) return false;\n\n    }\n\n    if (stk.isEmpty ()) return true;\n\n    else return false;\n\n}\n"}
{"idx": 5602, "func": "public static boolean isBalanced (String str) {\n\n    boolean result = false;\n\n    if (str.length () < 2) return false;\n\n    Stack < Character > stack = new Stack < > ();\n\n    for (int X1 = 0;\n\n    X1 < str.length (); X1 ++) {\n\n        char ch = str.charAt (X1);\n\n        if (! parenthesesMapRight.containsKey (ch) && ! parenthesesMapLeft.containsKey (ch)) {\n\n            continue;\n\n        }\n\n        if (parenthesesMapLeft.containsKey (ch)) {\n\n            stack.push (ch);\n\n        } else {\n\n            if (! stack.isEmpty () && stack.pop () == parenthesesMapRight.get (ch).charValue ()) {\n\n                result = true;\n\n            } else {\n\n                return false;\n\n            }\n\n        }\n\n    }\n\n    if (! stack.isEmpty ()) return result = false;\n\n    return result;\n\n}\n"}
{"idx": 56101, "func": "public void actionPerformed (ActionEvent X1) {\n\n    if (X1.getSource () == select) {\n\n        activeTool = SELECTION_TOOL;\n\n    } else if (X1.getSource () == draw) {\n\n        activeTool = DRAW_TOOL;\n\n    } else if (X1.getSource () == text) {\n\n        activeTool = TEXT_TOOL;\n\n    }\n\n}\n"}
{"idx": 56102, "func": "public void actionPerformed (ActionEvent e) {\n\n    JFileChooser ch = getFileChooser ();\n\n    int result = ch.showSaveDialog (gui);\n\n    if (result == JFileChooser.APPROVE_OPTION) {\n\n        try {\n\n            File f = ch.getSelectedFile ();\n\n            ImageIO.write (BasicPaint.X1.canvasImage, \"png\", f);\n\n            BasicPaint.X1.originalImage = BasicPaint.X1.canvasImage;\n\n            dirty = false;\n\n        } catch (IOException ioe) {\n\n            showError (ioe);\n\n            ioe.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 56201, "func": "public void actionPerformed (ActionEvent ae) {\n\n    if (ae.X1 () == select) {\n\n        activeTool = SELECTION_TOOL;\n\n    } else if (ae.X1 () == draw) {\n\n        activeTool = DRAW_TOOL;\n\n    } else if (ae.X1 () == text) {\n\n        activeTool = TEXT_TOOL;\n\n    }\n\n}\n"}
{"idx": 56202, "func": "public void actionPerformed (ActionEvent e) {\n\n    int x = (int) (Math.random () * getWidth ());\n\n    int y = (int) (Math.random () * getHeight ());\n\n    int width = (int) (Math.random () * (getWidth () / 4));\n\n    int X1 = (int) (Math.random () * (getHeight () / 4));\n\n    if (x + width > getWidth ()) {\n\n        x = getWidth () - width;\n\n    }\n\n    if (y + X1 > getHeight ()) {\n\n        y = getHeight () - X1;\n\n    }\n\n    Color color = new Color ((int) (Math.random () * 255), (int) (Math.random () * 255), (int) (Math.random () * 255));\n\n    lstShapes.add (new MyRectangle (x, y, width, X1, color));\n\n    repaint ();\n\n}\n"}
{"idx": 56301, "func": "public void actionPerformed (ActionEvent arg0) {\n\n    if (! dirty) {\n\n        JFileChooser ch = getFileChooser ();\n\n        int result = ch.showOpenDialog (X1);\n\n        if (result == JFileChooser.APPROVE_OPTION) {\n\n            try {\n\n                BufferedImage bi = ImageIO.read (ch.getSelectedFile ());\n\n                setImage (bi);\n\n            } catch (IOException e) {\n\n                showError (e);\n\n                e.printStackTrace ();\n\n            }\n\n        }\n\n    } else {\n\n        JOptionPane.showMessageDialog (X1, \"TODO - prompt save image..\");\n\n    }\n\n}\n"}
{"idx": 56302, "func": "public void actionPerformed (ActionEvent e) {\n\n    int x = (int) (Math.X1 () * getWidth ());\n\n    int y = (int) (Math.X1 () * getHeight ());\n\n    int width = (int) (Math.X1 () * (getWidth () / 4));\n\n    int height = (int) (Math.X1 () * (getHeight () / 4));\n\n    if (x + width > getWidth ()) {\n\n        x = getWidth () - width;\n\n    }\n\n    if (y + height > getHeight ()) {\n\n        y = getHeight () - height;\n\n    }\n\n    Color color = new Color ((int) (Math.X1 () * 255), (int) (Math.X1 () * 255), (int) (Math.X1 () * 255));\n\n    lstShapes.add (new MyRectangle (x, y, width, height, color));\n\n    repaint ();\n\n}\n"}
{"idx": 56401, "func": "public void actionPerformed (ActionEvent e) {\n\n    JFileChooser ch = getFileChooser ();\n\n    int result = ch.showSaveDialog (gui);\n\n    if (result == JFileChooser.APPROVE_OPTION) {\n\n        try {\n\n            File f = ch.getSelectedFile ();\n\n            ImageIO.write (X1.this.canvasImage, \"png\", f);\n\n            X1.this.originalImage = X1.this.canvasImage;\n\n            dirty = false;\n\n        } catch (IOException ioe) {\n\n            showError (ioe);\n\n            ioe.printStackTrace ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 56402, "func": "public void actionPerformed (ActionEvent e) {\n\n    int x = (int) (Math.X1 () * getWidth ());\n\n    int y = (int) (Math.X1 () * getHeight ());\n\n    int width = (int) (Math.X1 () * (getWidth () / 4));\n\n    int height = (int) (Math.X1 () * (getHeight () / 4));\n\n    if (x + width > getWidth ()) {\n\n        x = getWidth () - width;\n\n    }\n\n    if (y + height > getHeight ()) {\n\n        y = getHeight () - height;\n\n    }\n\n    Color color = new Color ((int) (Math.X1 () * 255), (int) (Math.X1 () * 255), (int) (Math.X1 () * 255));\n\n    lstShapes.add (new MyRectangle (x, y, width, height, color));\n\n    repaint ();\n\n}\n"}
{"idx": 56501, "func": "@Override\n\npublic boolean equals (Object obj) {\n\n    if (obj == null) {\n\n        return false;\n\n    }\n\n    if (obj == this) {\n\n        return true;\n\n    }\n\n    if (obj.getClass () != this.getClass ()) {\n\n        return false;\n\n    }\n\n    MyClass other = (MyClass) obj;\n\n    return new EqualsBuilder ().appendSuper (super.equals (obj)).append (X1, other.X1).append (field2, other.field2).append (field3, other.field3).isEquals ();\n\n}\n"}
{"idx": 56502, "func": "public boolean equals (Object obj) {\n\n    if (this == obj) return true;\n\n    if (obj == null) return false;\n\n    if (getClass () != obj.getClass ()) return false;\n\n    Connection other = (Connection) obj;\n\n    if (X1 == null) {\n\n        if (other.X1 != null) return false;\n\n    } else if (! X1.equals (other.X1)) return false;\n\n    if (dstPort != other.dstPort) return false;\n\n    if (protocol == null) {\n\n        if (other.protocol != null) return false;\n\n    } else if (! protocol.equals (other.protocol)) return false;\n\n    if (srcAddr == null) {\n\n        if (other.srcAddr != null) return false;\n\n    } else if (! srcAddr.equals (other.srcAddr)) return false;\n\n    if (srcPort != other.srcPort) return false;\n\n    return true;\n\n}\n"}
{"idx": 56601, "func": "private String readFileAsString (String filePath) throws IOException {\n\n    X1 fileData = new X1 ();\n\n    BufferedReader reader = new BufferedReader (new FileReader (filePath));\n\n    char [] buf = new char [1024];\n\n    int numRead = 0;\n\n    while ((numRead = reader.read (buf)) != - 1) {\n\n        String readData = String.valueOf (buf, 0, numRead);\n\n        fileData.append (readData);\n\n    }\n\n    reader.close ();\n\n    return fileData.toString ();\n\n}\n"}
{"idx": 56602, "func": "public static String readFileAsString (String fileName, String charsetName) throws java.io.IOException {\n\n    java.io.InputStream X1 = new java.io.FileInputStream (fileName);\n\n    try {\n\n        final int bufsize = 4096;\n\n        int available = X1.available ();\n\n        byte [] data = new byte [available < bufsize ? bufsize : available];\n\n        int used = 0;\n\n        while (true) {\n\n            if (data.length - used < bufsize) {\n\n                byte [] newData = new byte [data.length << 1];\n\n                System.arraycopy (data, 0, newData, 0, used);\n\n                data = newData;\n\n            }\n\n            int got = X1.read (data, used, data.length - used);\n\n            if (got <= 0) break;\n\n            used += got;\n\n        }\n\n        return charsetName != null ? new String (data, 0, used, charsetName) : new String (data, 0, used);\n\n    } finally {\n\n        X1.close ();\n\n    }\n\n}\n"}
{"idx": 56701, "func": "public static void main (String [] args) {\n\n    int size = 10;\n\n    double skew = 2.0;\n\n    ZipfGenerator z0 = new ZipfGenerator (size, skew);\n\n    FastZipfGenerator z1 = new FastZipfGenerator (size, skew);\n\n    long before = 0;\n\n    long after = 0;\n\n    int n = 5000000;\n\n    before = System.nanoTime ();\n\n    Map < Integer, Integer > counts0 = computeCounts (z0, size, n);\n\n    after = System.nanoTime ();\n\n    System.out.println (counts0 + \", duration \" + (after - before) / 1e6);\n\n    before = System.nanoTime ();\n\n    Map < Integer, Integer > X1 = computeCounts (z1, size, n);\n\n    after = System.nanoTime ();\n\n    System.out.println (X1 + \", duration \" + (after - before) / 1e6);\n\n}\n"}
{"idx": 56702, "func": "public static void main (String [] args) {\n\n    if (args.length != 2) {\n\n        System.out.println (\"usage: ./zipf size skew\");\n\n        System.exit (- 1);\n\n    }\n\n    ZipfGenerator zipf = new ZipfGenerator (Integer.X1 (args [0]), Double.X1 (args [1]));\n\n    for (int i = 1;\n\n    i <= 10; i ++) {\n\n        System.out.println (i + \" \" + zipf.getProbability (i));\n\n    }\n\n    int hist [] = new int [12];\n\n    for (int i = 0;\n\n    i < 12; i ++) {\n\n        hist [i] = 0;\n\n    }\n\n    System.out.println (\"Testing the probability distribution:\");\n\n    int sum = 0;\n\n    for (int i = 1;\n\n    i <= 1000000; i ++) {\n\n        hist [zipf.next ()] ++;\n\n    }\n\n    for (int i = 0;\n\n    i < 12; i ++) System.out.println (i + \" \" + hist [i] / 1000000.0);\n\n}\n"}
{"idx": 56801, "func": "public static void main (String [] args) {\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34, 43, 56};\n\n    int mArray [] = new int [5];\n\n    int j = 0;\n\n    for (int X1 = 0;\n\n    X1 < array.length; X1 ++) {\n\n        if (array [X1] > lower (mArray)) {\n\n            mArray [lowerPos (mArray)] = array [X1];\n\n        }\n\n    }\n\n    System.out.println (Arrays.toString (mArray));\n\n}\n"}
{"idx": 56802, "func": "public static void main (String args []) {\n\n    int i;\n\n    int large [] = new int [5];\n\n    int X1 [] = {33, 55, 13, 46, 87, 42, 10, 34, 43, 56};\n\n    int max = 0, index;\n\n    for (int j = 0;\n\n    j < 5; j ++) {\n\n        max = X1 [0];\n\n        index = 0;\n\n        for (i = 1; i < X1.length; i ++) {\n\n            if (max < X1 [i]) {\n\n                max = X1 [i];\n\n                index = i;\n\n            }\n\n        }\n\n        large [j] = max;\n\n        X1 [index] = Integer.MIN_VALUE;\n\n        System.out.println (\"Largest \" + j + \" : \" + large [j]);\n\n    }\n\n}\n"}
{"idx": 56901, "func": "public static void main (String [] args) {\n\n    int X1 [] = {33, 55, 13, 46, 87, 42, 10, 34, 43, 56};\n\n    int mArray [] = new int [5];\n\n    int j = 0;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] > lower (mArray)) {\n\n            mArray [lowerPos (mArray)] = X1 [i];\n\n        }\n\n    }\n\n    System.out.println (Arrays.toString (mArray));\n\n}\n"}
{"idx": 56902, "func": "public static void main (String args []) {\n\n    int X1;\n\n    int largestSize = 4;\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34};\n\n    int large [] = Arrays.copyOf (array, largestSize);\n\n    int smallest = large [0];\n\n    int smallestIndex = 0;\n\n    for (int j = 1;\n\n    j < large.length; ++ j) {\n\n        if (smallest > large [j]) {\n\n            smallest = large [j];\n\n            smallestIndex = j;\n\n        }\n\n    }\n\n    for (X1 = large.length; X1 < array.length; X1 ++) {\n\n        if (smallest < array [X1]) {\n\n            large [smallestIndex] = array [X1];\n\n            smallest = large [0];\n\n            smallestIndex = 0;\n\n            for (int j = 1;\n\n            j < large.length; ++ j) {\n\n                if (smallest > large [j]) {\n\n                    smallest = large [j];\n\n                    smallestIndex = j;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (int j = 0;\n\n    j < large.length; j ++) {\n\n        System.out.println (\"Largest 5 : \" + large [j]);\n\n    }\n\n    System.out.println ();\n\n    System.out.println (\"Largest is: \" + getHighest (large));\n\n}\n"}
{"idx": 57001, "func": "public static void main (String args []) {\n\n    int i;\n\n    int large [] = new int [5];\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34, 43, 56};\n\n    int max = 0, X1;\n\n    for (int j = 0;\n\n    j < 5; j ++) {\n\n        max = array [0];\n\n        X1 = 0;\n\n        for (i = 1; i < array.length; i ++) {\n\n            if (max < array [i]) {\n\n                max = array [i];\n\n                X1 = i;\n\n            }\n\n        }\n\n        large [j] = max;\n\n        array [X1] = Integer.MIN_VALUE;\n\n        System.out.println (\"Largest \" + j + \" : \" + large [j]);\n\n    }\n\n}\n"}
{"idx": 57002, "func": "public static void main (String args []) {\n\n    int i;\n\n    int largestSize = 4;\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34};\n\n    int large [] = Arrays.copyOf (array, largestSize);\n\n    int smallest = large [0];\n\n    int smallestIndex = 0;\n\n    for (int j = 1;\n\n    j < large.length; ++ j) {\n\n        if (smallest > large [j]) {\n\n            smallest = large [j];\n\n            smallestIndex = j;\n\n        }\n\n    }\n\n    for (i = large.length; i < array.length; i ++) {\n\n        if (smallest < array [i]) {\n\n            large [smallestIndex] = array [i];\n\n            smallest = large [0];\n\n            smallestIndex = 0;\n\n            for (int j = 1;\n\n            j < large.length; ++ j) {\n\n                if (smallest > large [j]) {\n\n                    smallest = large [j];\n\n                    smallestIndex = j;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (int j = 0;\n\n    j < large.length; j ++) {\n\n        X1.out.println (\"Largest 5 : \" + large [j]);\n\n    }\n\n    X1.out.println ();\n\n    X1.out.println (\"Largest is: \" + getHighest (large));\n\n}\n"}
{"idx": 5701, "func": "public static boolean isBalanced (String X1) {\n\n    Map < Character, Character > braces = new HashMap < > ();\n\n    braces.put ('(', ')');\n\n    braces.put ('[', ']');\n\n    braces.put ('{', '}');\n\n    if (X1.length () % 2 != 0) {\n\n        return false;\n\n    }\n\n    Stack < Character > halfBraces = new Stack ();\n\n    for (char ch : X1.toCharArray ()) {\n\n        if (braces.containsKey (ch)) {\n\n            halfBraces.push (braces.get (ch));\n\n        } else if (halfBraces.isEmpty () || ch != halfBraces.pop ()) {\n\n            return false;\n\n        }\n\n    }\n\n    return halfBraces.isEmpty ();\n\n}\n"}
{"idx": 5702, "func": "public static boolean isBalanced (String str) {\n\n    boolean result = false;\n\n    if (str.X1 () < 2) return false;\n\n    Stack < Character > stack = new Stack < > ();\n\n    for (int i = 0;\n\n    i < str.X1 (); i ++) {\n\n        char ch = str.charAt (i);\n\n        if (! parenthesesMapRight.containsKey (ch) && ! parenthesesMapLeft.containsKey (ch)) {\n\n            continue;\n\n        }\n\n        if (parenthesesMapLeft.containsKey (ch)) {\n\n            stack.push (ch);\n\n        } else {\n\n            if (! stack.isEmpty () && stack.pop () == parenthesesMapRight.get (ch).charValue ()) {\n\n                result = true;\n\n            } else {\n\n                return false;\n\n            }\n\n        }\n\n    }\n\n    if (! stack.isEmpty ()) return result = false;\n\n    return result;\n\n}\n"}
{"idx": 57101, "func": "public static void main (String args []) {\n\n    int i;\n\n    int large [] = new int [5];\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34, 43, 56};\n\n    int max = 0, X1;\n\n    for (int j = 0;\n\n    j < 5; j ++) {\n\n        max = array [0];\n\n        X1 = 0;\n\n        for (i = 1; i < array.length; i ++) {\n\n            if (max < array [i]) {\n\n                max = array [i];\n\n                X1 = i;\n\n            }\n\n        }\n\n        large [j] = max;\n\n        array [X1] = Integer.MIN_VALUE;\n\n        System.out.println (\"Largest \" + j + \" : \" + large [j]);\n\n    }\n\n}\n"}
{"idx": 57102, "func": "public static void main (String [] args) {\n\n    int large [] = new int [10];\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34, 43, 56};\n\n    int k = 0;\n\n    for (int X1 = 0;\n\n    X1 < array.length; X1 ++) {\n\n        large [k ++] = getMax (0, array);\n\n    }\n\n    System.out.println (\"Largest 5 is: \" + Arrays.toString (Arrays.copyOf (large, 5)));\n\n}\n"}
{"idx": 57201, "func": "public static void main (String args []) {\n\n    int i;\n\n    int largestSize = 4;\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34};\n\n    int large [] = Arrays.copyOf (array, largestSize);\n\n    int smallest = large [0];\n\n    int smallestIndex = 0;\n\n    for (int X1 = 1;\n\n    X1 < large.length; ++ X1) {\n\n        if (smallest > large [X1]) {\n\n            smallest = large [X1];\n\n            smallestIndex = X1;\n\n        }\n\n    }\n\n    for (i = large.length; i < array.length; i ++) {\n\n        if (smallest < array [i]) {\n\n            large [smallestIndex] = array [i];\n\n            smallest = large [0];\n\n            smallestIndex = 0;\n\n            for (int X1 = 1;\n\n            X1 < large.length; ++ X1) {\n\n                if (smallest > large [X1]) {\n\n                    smallest = large [X1];\n\n                    smallestIndex = X1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < large.length; X1 ++) {\n\n        System.out.println (\"Largest 5 : \" + large [X1]);\n\n    }\n\n    System.out.println ();\n\n    System.out.println (\"Largest is: \" + getHighest (large));\n\n}\n"}
{"idx": 57202, "func": "public static void main (String [] args) {\n\n    int large [] = new int [10];\n\n    int array [] = {33, 55, 13, 46, 87, 42, 10, 34, 43, 56};\n\n    int k = 0;\n\n    for (int i = 0;\n\n    i < array.length; i ++) {\n\n        large [k ++] = getMax (0, array);\n\n    }\n\n    System.out.println (\"Largest 5 is: \" + X1.toString (X1.copyOf (large, 5)));\n\n}\n"}
{"idx": 57301, "func": "public static void main (String arg []) {\n\n    Scanner sc = new Scanner (System.in);\n\n    System.X1.println (\"enter string for c\");\n\n    String c = sc.next ();\n\n    System.X1.println (\"c is \" + c);\n\n    System.X1.println (\"enter string for d\");\n\n    String d = sc.next ();\n\n    System.X1.println (\"d is \" + d);\n\n}\n"}
{"idx": 57302, "func": "public static void main (String [] args) {\n\n    Scanner sc = new Scanner (System.in);\n\n    int X1 = sc.nextInt ();\n\n    String [] str = new String [X1];\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        str [i] = sc.next ();\n\n    }\n\n}\n"}
{"idx": 57401, "func": "public static String replaceHostInUrl (String url, String newHost) {\n\n    if (url == null || newHost == null) {\n\n        return url;\n\n    }\n\n    try {\n\n        URL originalURL = new URL (url);\n\n        boolean hostHasPort = newHost.indexOf (\":\") != - 1;\n\n        int newPort = originalURL.getPort ();\n\n        if (hostHasPort) {\n\n            URL hostURL = new URL (\"http://\" + newHost);\n\n            newHost = hostURL.getHost ();\n\n            newPort = hostURL.getPort ();\n\n        } else {\n\n            newPort = - 1;\n\n        }\n\n        boolean isHttps = originalURL.getProtocol ().equals (\"https\");\n\n        boolean useDefaultPort = (newPort == 443 && isHttps) || (newPort == 80 && ! isHttps);\n\n        newPort = useDefaultPort ? - 1 : newPort;\n\n        URL newURL = new URL (originalURL.getProtocol (), newHost, newPort, originalURL.getFile ());\n\n        String X1 = newURL.toString ();\n\n        return X1;\n\n    } catch (MalformedURLException e) {\n\n        throw new RuntimeException (\"Couldnt replace host in url, originalUrl=\" + url + \", newHost=\" + newHost);\n\n    }\n\n}\n"}
{"idx": 57402, "func": "public static String replaceHostInUrl (String originalURL, String newAuthority) throws URISyntaxException, MalformedURLException {\n\n    URI uri = new URI (originalURL);\n\n    uri = new URI (uri.X1 ().toLowerCase (Locale.US), newAuthority, uri.getPath (), uri.getQuery (), uri.getFragment ());\n\n    int port = uri.getPort ();\n\n    if (port > 0 && port == uri.toURL ().getDefaultPort ()) {\n\n        uri = new URI (uri.X1 (), uri.getUserInfo (), uri.getHost (), - 1, uri.getPath (), uri.getQuery (), uri.getFragment ());\n\n    }\n\n    return uri.toString ();\n\n}\n"}
{"idx": 57501, "func": "private static void createAndShowGUI () {\n\n    final X1 frame = new X1 ();\n\n    frame.setDefaultCloseOperation (X1.EXIT_ON_CLOSE);\n\n    frame.setLayout (new FlowLayout ());\n\n    JButton readerStopButton_ = new JButton ();\n\n    readerStopButton_.setFocusPainted (false);\n\n    readerStopButton_.setBackground (UIManager.getDefaults ().getColor (\"Button.light\"));\n\n    readerStopButton_.setFont (new Font (\"Geneva\", 0, 12));\n\n    readerStopButton_.setText (\"<html><center>READER<br>STOP</center></html>\\n\");\n\n    readerStopButton_.setHorizontalTextPosition (SwingConstants.CENTER);\n\n    frame.add (readerStopButton_);\n\n    frame.pack ();\n\n    frame.setLocationRelativeTo (null);\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 57502, "func": "private static void createAndShowGUI () {\n\n    final JFrame frame = new JFrame ();\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    frame.setLayout (new FlowLayout ());\n\n    JPanel operationButtons_ = new JPanel ();\n\n    JButton readerStopButton_ = new JButton ();\n\n    readerStopButton_.setBackground (javax.swing.UIManager.getDefaults ().X1 (\"Button.light\"));\n\n    readerStopButton_.setFont (new java.awt.Font (\"Geneva\", 0, 12));\n\n    readerStopButton_.setText (\"<html><center>READER<br>STOP</center></html>\\n\");\n\n    readerStopButton_.setToolTipText (\"<html><b>Stop</b> button is currently inactive.  \");\n\n    readerStopButton_.setMargin (new Insets (0, - 30, 0, - 30));\n\n    readerStopButton_.setPreferredSize (new Dimension (66, 40));\n\n    operationButtons_.add (readerStopButton_);\n\n    readerStopButton_ = new JButton ();\n\n    readerStopButton_.setBackground (javax.swing.UIManager.getDefaults ().X1 (\"Button.light\"));\n\n    readerStopButton_.setFont (new java.awt.Font (\"Geneva\", 0, 12));\n\n    readerStopButton_.setText (\"<html><center>READER<br>STOP</center></html>\\n\");\n\n    readerStopButton_.setToolTipText (\"<html><b>Stop</b> button is currently inactive.  \");\n\n    System.out.println (readerStopButton_.getPreferredSize ());\n\n    readerStopButton_.setPreferredSize (new Dimension (66, 40));\n\n    operationButtons_.add (readerStopButton_);\n\n    operationButtons_.add (new JButton (\"yCoder.com\"));\n\n    frame.add (operationButtons_);\n\n    frame.pack ();\n\n    frame.setLocationRelativeTo (null);\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 57601, "func": "public static void stars (int X1) {\n\n    for (int i = 0;\n\n    i < X1 * X1; i ++) {\n\n        int y = i / X1, x = i % X1;\n\n        System.out.print ((x >= y && x < X1 - y) || (x >= X1 - y - 1 && x <= y) ? '*' : ' ');\n\n        if (x == X1 - 1) System.out.println ();\n\n    }\n\n}\n"}
{"idx": 57602, "func": "static void stars () {\n\n    final int MAX_WIDTH = 7;\n\n    for (int i = 0;\n\n    i < 7; ++ i) {\n\n        int width;\n\n        if (i < 3) width = MAX_WIDTH - i * 2;\n\n        else if (i > 3) width = (i - 3) * 2 + 1;\n\n        else width = 1;\n\n        for (int j = 0;\n\n        j < (MAX_WIDTH - width) / 2; ++ j) {\n\n            X1.out.print (\" \");\n\n        }\n\n        for (int j = 0;\n\n        j < width; ++ j) {\n\n            X1.out.print (\"*\");\n\n        }\n\n        for (int j = 0;\n\n        j < (MAX_WIDTH - width) / 2; ++ j) {\n\n            X1.out.print (\" \");\n\n        }\n\n        X1.out.println ();\n\n    }\n\n}\n"}
{"idx": 57701, "func": "public static int getRandomNumberBetween (int min, int max) {\n\n    Random X1 = new Random ();\n\n    int randomNumber = X1.nextInt (max - min) + min;\n\n    if (randomNumber == min) {\n\n        return min + 1;\n\n    } else {\n\n        return randomNumber;\n\n    }\n\n}\n"}
{"idx": 57702, "func": "private static float getRandomNumberBetween (float numberOne, float numberTwo) throws Exception {\n\n    if (numberOne == numberTwo) {\n\n        throw new Exception (\"Both the numbers can not be equal\");\n\n    }\n\n    float rand = (float) Math.random ();\n\n    float X1 = Math.max (numberOne, numberTwo);\n\n    float lowRange = Math.min (numberOne, numberTwo);\n\n    float lowRand = (float) Math.floor (rand - 1);\n\n    float highRand = (float) Math.ceil (rand + 1);\n\n    float genRand = (X1 - lowRange) * ((rand - lowRand) / (highRand - lowRand)) + lowRange;\n\n    return genRand;\n\n}\n"}
{"idx": 57801, "func": "public static final void main (String...aArgs) {\n\n    X1 (\"Generating random integers in the range 1..10.\");\n\n    int START = 1;\n\n    int END = 10;\n\n    Random random = new Random ();\n\n    for (int idx = 1;\n\n    idx <= 10; ++ idx) {\n\n        showRandomInteger (START, END, random);\n\n    }\n\n    X1 (\"Done.\");\n\n}\n"}
{"idx": 57802, "func": "public static void main (String [] args) {\n\n    int a = 100;\n\n    int b = 1000;\n\n    int X1 = b;\n\n    int highest = a;\n\n    int count = 100000;\n\n    Random random = new Random ();\n\n    for (int i = 0;\n\n    i < count; i ++) {\n\n        int nextNumber = (int) ((Math.abs (random.nextDouble ()) * (b - a))) + a;\n\n        if (nextNumber < a || nextNumber > b) {\n\n            System.err.println (\"number not in range :\" + nextNumber);\n\n        } else {\n\n            System.out.println (nextNumber);\n\n        }\n\n        if (nextNumber < X1) {\n\n            X1 = nextNumber;\n\n        }\n\n        if (nextNumber > highest) {\n\n            highest = nextNumber;\n\n        }\n\n    }\n\n    System.out.println (\"Produced \" + count + \" numbers from \" + X1 + \" to \" + highest);\n\n}\n"}
{"idx": 57901, "func": "public static final void main (String...aArgs) {\n\n    log (\"Generating random integers in the range 1..10.\");\n\n    int X1 = 1;\n\n    int END = 10;\n\n    Random random = new Random ();\n\n    for (int idx = 1;\n\n    idx <= 10; ++ idx) {\n\n        showRandomInteger (X1, END, random);\n\n    }\n\n    log (\"Done.\");\n\n}\n"}
{"idx": 57902, "func": "public static void main (String [] args) {\n\n    int first, second;\n\n    Scanner myScanner = new Scanner (System.in);\n\n    System.out.X1 (\"Enter first integer: \");\n\n    int numOne;\n\n    numOne = myScanner.nextInt ();\n\n    System.out.X1 (\"You have keyed in \" + numOne);\n\n    System.out.X1 (\"Enter second integer: \");\n\n    int numTwo;\n\n    numTwo = myScanner.nextInt ();\n\n    System.out.X1 (\"You have keyed in \" + numTwo);\n\n    Random generator = new Random ();\n\n    int num = (int) (Math.random () * numTwo);\n\n    System.out.X1 (\"Random number: \" + ((num > numOne) ? num : numOne + num));\n\n}\n"}
{"idx": 58001, "func": "public static final void main (String...aArgs) {\n\n    log (\"Generating random integers in the range 1..10.\");\n\n    int START = 1;\n\n    int END = 10;\n\n    Random random = new Random ();\n\n    for (int X1 = 1;\n\n    X1 <= 10; ++ X1) {\n\n        showRandomInteger (START, END, random);\n\n    }\n\n    log (\"Done.\");\n\n}\n"}
{"idx": 58002, "func": "public static void main (String [] args) {\n\n    Random ran = new Random ();\n\n    int min, max;\n\n    Scanner sc = new Scanner (System.in);\n\n    System.out.println (\"Enter min range:\");\n\n    min = sc.X1 ();\n\n    System.out.println (\"Enter max range:\");\n\n    max = sc.X1 ();\n\n    int num = ran.X1 (min);\n\n    int num1 = ran.X1 (max);\n\n    System.out.println (\"Random Number between given range is \" + num1);\n\n}\n"}
{"idx": 5801, "func": "public static void main (String [] args) throws FileNotFoundException, IOException {\n\n    Path myPath = Paths.get (\"e:\\\\\", \"1.txt\");\n\n    List < String > X1;\n\n    X1 = Files.readAllLines (myPath, StandardCharsets.US_ASCII);\n\n    PrintWriter out = new PrintWriter (\"e:\\\\2.txt\");\n\n    for (int i = 0;\n\n    i < X1.size (); i ++) {\n\n        String [] temp = X1.get (i).split (\":\");\n\n        if (temp.length > 1) {\n\n            out.println (X1.get (i));\n\n        }\n\n    }\n\n    out.close ();\n\n}\n"}
{"idx": 5802, "func": "public static void main (String [] args) throws FileNotFoundException, IOException {\n\n    FileInputStream fin = new FileInputStream (\"line.srt\");\n\n    BufferedReader reader = new BufferedReader (new InputStreamReader (fin));\n\n    PrintWriter out = new PrintWriter (\"newline.srt\");\n\n    int i = 0;\n\n    String X1 = reader.readLine ();\n\n    while (X1 != null) {\n\n        if (! X1.trim ().equals (\"\")) {\n\n            out.println (X1);\n\n        }\n\n        X1 = reader.readLine ();\n\n    }\n\n    out.close ();\n\n}\n"}
{"idx": 58101, "func": "public static void main (String [] args) {\n\n    int a = 100;\n\n    int b = 1000;\n\n    int lowest = b;\n\n    int highest = a;\n\n    int count = 100000;\n\n    Random random = new Random ();\n\n    for (int i = 0;\n\n    i < count; i ++) {\n\n        int nextNumber = (int) ((Math.abs (random.nextDouble ()) * (b - a))) + a;\n\n        if (nextNumber < a || nextNumber > b) {\n\n            X1.err.println (\"number not in range :\" + nextNumber);\n\n        } else {\n\n            X1.out.println (nextNumber);\n\n        }\n\n        if (nextNumber < lowest) {\n\n            lowest = nextNumber;\n\n        }\n\n        if (nextNumber > highest) {\n\n            highest = nextNumber;\n\n        }\n\n    }\n\n    X1.out.println (\"Produced \" + count + \" numbers from \" + lowest + \" to \" + highest);\n\n}\n"}
{"idx": 58102, "func": "public static void main (String [] args) {\n\n    int first, second;\n\n    Scanner myScanner = new Scanner (System.in);\n\n    System.out.println (\"Enter first integer: \");\n\n    int numOne;\n\n    numOne = myScanner.X1 ();\n\n    System.out.println (\"You have keyed in \" + numOne);\n\n    System.out.println (\"Enter second integer: \");\n\n    int numTwo;\n\n    numTwo = myScanner.X1 ();\n\n    System.out.println (\"You have keyed in \" + numTwo);\n\n    Random generator = new Random ();\n\n    int num = (int) (Math.random () * numTwo);\n\n    System.out.println (\"Random number: \" + ((num > numOne) ? num : numOne + num));\n\n}\n"}
{"idx": 58201, "func": "public static void main (String [] args) {\n\n    int a = 100;\n\n    int b = 1000;\n\n    int lowest = b;\n\n    int highest = a;\n\n    int count = 100000;\n\n    Random random = new Random ();\n\n    for (int i = 0;\n\n    i < count; i ++) {\n\n        int X1 = (int) ((Math.abs (random.nextDouble ()) * (b - a))) + a;\n\n        if (X1 < a || X1 > b) {\n\n            System.err.println (\"number not in range :\" + X1);\n\n        } else {\n\n            System.out.println (X1);\n\n        }\n\n        if (X1 < lowest) {\n\n            lowest = X1;\n\n        }\n\n        if (X1 > highest) {\n\n            highest = X1;\n\n        }\n\n    }\n\n    System.out.println (\"Produced \" + count + \" numbers from \" + lowest + \" to \" + highest);\n\n}\n"}
{"idx": 58202, "func": "public static final void main (String...aArgs) {\n\n    log (\"Generating 10 random integers in range 1..10.\");\n\n    int START = 1;\n\n    int END = 10;\n\n    X1 randomGenerator = new X1 ();\n\n    for (int idx = 1;\n\n    idx <= 10; ++ idx) {\n\n        showRandomInteger (START, END, randomGenerator);\n\n    }\n\n    log (\"Done\");\n\n}\n"}
{"idx": 58301, "func": "public static void main (String [] args) {\n\n    int a = 100;\n\n    int X1 = 1000;\n\n    int lowest = X1;\n\n    int highest = a;\n\n    int count = 100000;\n\n    Random random = new Random ();\n\n    for (int i = 0;\n\n    i < count; i ++) {\n\n        int nextNumber = (int) ((Math.abs (random.nextDouble ()) * (X1 - a))) + a;\n\n        if (nextNumber < a || nextNumber > X1) {\n\n            System.err.println (\"number not in range :\" + nextNumber);\n\n        } else {\n\n            System.out.println (nextNumber);\n\n        }\n\n        if (nextNumber < lowest) {\n\n            lowest = nextNumber;\n\n        }\n\n        if (nextNumber > highest) {\n\n            highest = nextNumber;\n\n        }\n\n    }\n\n    System.out.println (\"Produced \" + count + \" numbers from \" + lowest + \" to \" + highest);\n\n}\n"}
{"idx": 58302, "func": "public static void main (String [] args) {\n\n    X1 ran = new X1 ();\n\n    int min, max;\n\n    Scanner sc = new Scanner (System.in);\n\n    System.out.println (\"Enter min range:\");\n\n    min = sc.nextInt ();\n\n    System.out.println (\"Enter max range:\");\n\n    max = sc.nextInt ();\n\n    int num = ran.nextInt (min);\n\n    int num1 = ran.nextInt (max);\n\n    System.out.println (\"Random Number between given range is \" + num1);\n\n}\n"}
{"idx": 58401, "func": "public static void main (String [] args) {\n\n    int first, second;\n\n    Scanner myScanner = new Scanner (System.in);\n\n    System.out.println (\"Enter first integer: \");\n\n    int numOne;\n\n    numOne = myScanner.nextInt ();\n\n    System.out.println (\"You have keyed in \" + numOne);\n\n    System.out.println (\"Enter second integer: \");\n\n    int X1;\n\n    X1 = myScanner.nextInt ();\n\n    System.out.println (\"You have keyed in \" + X1);\n\n    Random generator = new Random ();\n\n    int num = (int) (Math.random () * X1);\n\n    System.out.println (\"Random number: \" + ((num > numOne) ? num : numOne + num));\n\n}\n"}
{"idx": 58402, "func": "public static final void main (String...aArgs) {\n\n    log (\"Generating 10 random integers in range 1..10.\");\n\n    int START = 1;\n\n    int X1 = 10;\n\n    Random randomGenerator = new Random ();\n\n    for (int idx = 1;\n\n    idx <= 10; ++ idx) {\n\n        showRandomInteger (START, X1, randomGenerator);\n\n    }\n\n    log (\"Done\");\n\n}\n"}
{"idx": 58501, "func": "public static void main (String [] args) {\n\n    int first, second;\n\n    Scanner X1 = new Scanner (System.in);\n\n    System.out.println (\"Enter first integer: \");\n\n    int numOne;\n\n    numOne = X1.nextInt ();\n\n    System.out.println (\"You have keyed in \" + numOne);\n\n    System.out.println (\"Enter second integer: \");\n\n    int numTwo;\n\n    numTwo = X1.nextInt ();\n\n    System.out.println (\"You have keyed in \" + numTwo);\n\n    Random generator = new Random ();\n\n    int num = (int) (Math.random () * numTwo);\n\n    System.out.println (\"Random number: \" + ((num > numOne) ? num : numOne + num));\n\n}\n"}
{"idx": 58502, "func": "public static void main (String [] args) {\n\n    Random ran = new Random ();\n\n    int min, max;\n\n    Scanner sc = new Scanner (System.in);\n\n    System.X1.println (\"Enter min range:\");\n\n    min = sc.nextInt ();\n\n    System.X1.println (\"Enter max range:\");\n\n    max = sc.nextInt ();\n\n    int num = ran.nextInt (min);\n\n    int num1 = ran.nextInt (max);\n\n    System.X1.println (\"Random Number between given range is \" + num1);\n\n}\n"}
{"idx": 58601, "func": "public static final void main (String...aArgs) {\n\n    log (\"Generating 10 random integers in range 1..10.\");\n\n    int X1 = 1;\n\n    int END = 10;\n\n    Random randomGenerator = new Random ();\n\n    for (int idx = 1;\n\n    idx <= 10; ++ idx) {\n\n        showRandomInteger (X1, END, randomGenerator);\n\n    }\n\n    log (\"Done\");\n\n}\n"}
{"idx": 58602, "func": "public static void main (String [] args) {\n\n    Random ran = new Random ();\n\n    int min, max;\n\n    Scanner sc = new Scanner (X1.in);\n\n    X1.out.println (\"Enter min range:\");\n\n    min = sc.nextInt ();\n\n    X1.out.println (\"Enter max range:\");\n\n    max = sc.nextInt ();\n\n    int num = ran.nextInt (min);\n\n    int num1 = ran.nextInt (max);\n\n    X1.out.println (\"Random Number between given range is \" + num1);\n\n}\n"}
{"idx": 58701, "func": "public static void main (String [] args) {\n\n    String userInput = \"Peter\";\n\n    int length = userInput.length ();\n\n    int m, j, i, n = 0;\n\n    for (m = length % 2 > 0 ? 1 : 2; m < length * 2; m += 2) {\n\n        i = m < length ? m : length * 2 - m;\n\n        for (j = 0; j < length - 1 - i / 2; ++ j) {\n\n            System.out.print (\" \");\n\n        }\n\n        for (j = 0; j < i; ++ j) {\n\n            char X1 = userInput.charAt (n ++ % length);\n\n            X1 = j == 0 ? Character.toUpperCase (X1) : Character.toLowerCase (X1);\n\n            System.out.print (X1);\n\n        }\n\n        System.out.println (\"\");\n\n    }\n\n}\n"}
{"idx": 58702, "func": "public static void main (String [] args) {\n\n    Scanner keyboard = new Scanner (System.in);\n\n    String X1 = keyboard.next ();\n\n    String concatenated = X1;\n\n    int i, cumSum = 0;\n\n    ArrayList < Integer > helperIndex = new ArrayList < > ();\n\n    for (i = 1; i < X1.length (); i += 2) {\n\n        helperIndex.add (i);\n\n        cumSum += i;\n\n    }\n\n    for (i = X1.length (); i > 0; i -= 2) {\n\n        helperIndex.add (i);\n\n        cumSum += i;\n\n    }\n\n    int numOfWordRepitition = cumSum / X1.length ();\n\n    for (i = 0; i < numOfWordRepitition; i ++) {\n\n        concatenated += X1;\n\n    }\n\n    String substr;\n\n    int prev = helperIndex.get (0);\n\n    int next = helperIndex.get (0);\n\n    substr = concatenated.substring (0, helperIndex.get (0));\n\n    System.out.println (Character.toUpperCase (substr.charAt (0)) + substr.substring (1));\n\n    for (i = 1; i < X1.length (); i ++) {\n\n        next += helperIndex.get (i);\n\n        substr = concatenated.substring (prev, next);\n\n        substr = Character.toUpperCase (substr.charAt (0)) + substr.substring (1);\n\n        System.out.println (substr);\n\n        prev = next;\n\n    }\n\n}\n"}
{"idx": 58801, "func": "public static void main (String [] args) {\n\n    String sent1 = \"Mary and Meera are my classmates.\";\n\n    String sent2 = \"Meera and Mary are my classmates.\";\n\n    String X1 = \"Alice and Bobe are not my classmates.\";\n\n    String sent4 = \"Some totally different sentence.\";\n\n    System.out.println (\"Distance between \\n'\" + sent1 + \"' \\nand '\" + sent2 + \"': \\n\" + computeDistance (sent1, sent2));\n\n    System.out.println (\"Distance between \\n'\" + sent1 + \"' \\nand '\" + X1 + \"': \\n\" + computeDistance (sent1, X1));\n\n    System.out.println (\"Distance between \\n'\" + sent1 + \"' \\nand '\" + sent4 + \"': \\n\" + computeDistance (sent1, sent4));\n\n}\n"}
{"idx": 58802, "func": "public static void main (String [] args) {\n\n    try {\n\n        ArrayList < String > sentences = null;\n\n        sentences = new ArrayList < String > ();\n\n        sentences.X1 (\"Mary and Meera are my classmates.\");\n\n        sentences.X1 (\"Mary and Meera are my classmates.\");\n\n        sentences.X1 (\"Meera and Mary are my classmates.\");\n\n        sentences.X1 (\"Alice and Bobe are not my classmates.\");\n\n        sentences.X1 (\"Some totally different sentence.\");\n\n        wordAnalyser (sentences);\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 58901, "func": "public static void main (String [] args) throws TwilioRestException {\n\n    TwilioRestClient client = new TwilioRestClient (ACCOUNT_SID, AUTH_TOKEN);\n\n    List < NameValuePair > X1 = new ArrayList < NameValuePair > ();\n\n    X1.add (new BasicNameValuePair (\"Body\", \"Test Twilio message\"));\n\n    X1.add (new BasicNameValuePair (\"To\", \"+14159352345\"));\n\n    X1.add (new BasicNameValuePair (\"From\", \"+14158141829\"));\n\n    MessageFactory messageFactory = client.getAccount ().getMessageFactory ();\n\n    Message message = messageFactory.create (X1);\n\n    System.out.println (message.getSid ());\n\n}\n"}
{"idx": 58902, "func": "public static void main (String [] args) throws Exception {\n\n    AuthMethod auth = new TokenAuthMethod (API_KEY, API_SECRET);\n\n    NexmoClient client = new NexmoClient (auth);\n\n    TextMessage X1 = new TextMessage (FROM_NUMBER, TO_NUMBER, \"Hello from Nexmo!\");\n\n    SmsSubmissionResult [] responses = client.getSmsClient ().submitMessage (X1);\n\n    for (SmsSubmissionResult response : responses) {\n\n        System.out.println (response);\n\n    }\n\n}\n"}
{"idx": 59001, "func": "public static void main (String [] args) throws TwilioRestException {\n\n    X1 client = new X1 (ACCOUNT_SID, AUTH_TOKEN);\n\n    List < NameValuePair > params = new ArrayList < NameValuePair > ();\n\n    params.add (new BasicNameValuePair (\"Body\", \"Test Twilio message\"));\n\n    params.add (new BasicNameValuePair (\"To\", \"+14159352345\"));\n\n    params.add (new BasicNameValuePair (\"From\", \"+14158141829\"));\n\n    MessageFactory messageFactory = client.getAccount ().getMessageFactory ();\n\n    Message message = messageFactory.create (params);\n\n    System.out.println (message.getSid ());\n\n}\n"}
{"idx": 59002, "func": "public static void main (String args []) {\n\n    GSMConnect gsm = new GSMConnect (comPort);\n\n    if (gsm.init ()) {\n\n        try {\n\n            System.out.println (\"Initialization Success\");\n\n            gsm.connect ();\n\n            Thread.X1 (5000);\n\n            gsm.checkStatus ();\n\n            Thread.X1 (5000);\n\n            gsm.sendMessage (\"+91XXXXXXXX\", \"Trial Success\");\n\n            Thread.X1 (1000);\n\n            gsm.hangup ();\n\n            Thread.X1 (1000);\n\n            gsm.closePort ();\n\n            gsm.outCommand ();\n\n            System.exit (1);\n\n        } catch (Exception e) {\n\n            e.printStackTrace ();\n\n        }\n\n    } else {\n\n        System.out.println (\"Can't init this card\");\n\n    }\n\n}\n"}
{"idx": 5901, "func": "public static void main (String [] args) {\n\n    try {\n\n        File file = new File (\"company.xml\");\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();\n\n        DocumentBuilder db = dbf.newDocumentBuilder ();\n\n        Document doc = db.parse (file);\n\n        doc.getDocumentElement ().normalize ();\n\n        NodeList nodeLst = doc.getElementsByTagName (\"employee\");\n\n        for (int s = 0;\n\n        s < nodeLst.getLength (); s ++) {\n\n            Node fstNode = nodeLst.item (s);\n\n            if (fstNode.getNodeType () == Node.ELEMENT_NODE) {\n\n                Element fstElmnt = (Element) fstNode;\n\n                NodeList fstNmElmntLst = fstElmnt.getElementsByTagName (\"firstname\");\n\n                Element fstNmElmnt = (Element) fstNmElmntLst.item (0);\n\n                NodeList fstNm = fstNmElmnt.getChildNodes ();\n\n                System.out.X1 (\"First Name: \" + ((Node) fstNm.item (0)).getNodeValue ());\n\n                NodeList lstNmElmntLst = fstElmnt.getElementsByTagName (\"lastname\");\n\n                Element lstNmElmnt = (Element) lstNmElmntLst.item (0);\n\n                NodeList lstNm = lstNmElmnt.getChildNodes ();\n\n                System.out.X1 (\"Last Name: \" + ((Node) lstNm.item (0)).getNodeValue ());\n\n            }\n\n        }\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 5902, "func": "public static void main (X1 [] args) {\n\n    List < X1 > keywords = Arrays.asList (\"Apple\", \"Ananas\", \"Mango\", \"Banana\", \"Beer\");\n\n    Map < Character, List < X1 > > result = new HashMap < Character, List < X1 > > ();\n\n    for (X1 k : keywords) {\n\n        char firstChar = k.charAt (0);\n\n        if (! result.containsKey (firstChar)) {\n\n            result.put (firstChar, new ArrayList < X1 > ());\n\n        }\n\n        result.get (firstChar).add (k);\n\n    }\n\n    for (List < X1 > list : result.values ()) {\n\n        Collections.sort (list);\n\n    }\n\n    System.out.println (result);\n\n}\n"}
{"idx": 59101, "func": "public static void main (String [] args) throws Exception {\n\n    AuthMethod X1 = new TokenAuthMethod (API_KEY, API_SECRET);\n\n    NexmoClient client = new NexmoClient (X1);\n\n    TextMessage message = new TextMessage (FROM_NUMBER, TO_NUMBER, \"Hello from Nexmo!\");\n\n    SmsSubmissionResult [] responses = client.getSmsClient ().submitMessage (message);\n\n    for (SmsSubmissionResult response : responses) {\n\n        System.out.println (response);\n\n    }\n\n}\n"}
{"idx": 59102, "func": "public static void main (String args []) {\n\n    GSMConnect gsm = new GSMConnect (comPort);\n\n    if (gsm.init ()) {\n\n        try {\n\n            X1.out.println (\"Initialization Success\");\n\n            gsm.connect ();\n\n            Thread.sleep (5000);\n\n            gsm.checkStatus ();\n\n            Thread.sleep (5000);\n\n            gsm.sendMessage (\"+91XXXXXXXX\", \"Trial Success\");\n\n            Thread.sleep (1000);\n\n            gsm.hangup ();\n\n            Thread.sleep (1000);\n\n            gsm.closePort ();\n\n            gsm.outCommand ();\n\n            X1.exit (1);\n\n        } catch (Exception e) {\n\n            e.printStackTrace ();\n\n        }\n\n    } else {\n\n        X1.out.println (\"Can't init this card\");\n\n    }\n\n}\n"}
{"idx": 59201, "func": "public static void main (String [] args) {\n\n    boolean ObjectID = false;\n\n    boolean Class = false;\n\n    boolean LastChangedBy = false;\n\n    boolean Number = false;\n\n    boolean StartEffectivity = false;\n\n    boolean EndEffectivity = false;\n\n    boolean StartSerialNumberEffectivity = false;\n\n    boolean EndSerialNumberEffectivity = false;\n\n    boolean StartLotNumberEffectivity = false;\n\n    boolean EndLotNumberEffectivity = false;\n\n    boolean SerialNumberEffectivityCxtPartNumber = false;\n\n    boolean LotNumberEffectivityCxtPartNumber = false;\n\n    boolean DefaultUnit = false;\n\n    boolean Name = false;\n\n    boolean PartType = false;\n\n    boolean Source = false;\n\n    boolean State = false;\n\n    boolean IsPhantom = false;\n\n    boolean Version = false;\n\n    boolean Iteration = false;\n\n    boolean PreviousVersion = false;\n\n    boolean IsConfigurable = false;\n\n    boolean IsCollapsible = false;\n\n    boolean TargetID = false;\n\n    try {\n\n        XMLInputFactory factory = XMLInputFactory.newInstance ();\n\n        XMLEventReader eventReader = factory.createXMLEventReader (new FileReader (\"c:\\\\staxTestFile.xml\"));\n\n        while (eventReader.hasNext ()) {\n\n            XMLEvent event = eventReader.nextEvent ();\n\n            switch (event.getEventType ()) {\n\n                case XMLStreamConstants.START_ELEMENT :\n\n                    StartElement startElement = event.asStartElement ();\n\n                    String X1 = startElement.getName ().getLocalPart ();\n\n                    if (X1.equalsIgnoreCase (\"Part\")) {\n\n                        System.out.println (\"Start Element : Part\");\n\n                        Iterator < Attribute > attributes = startElement.getAttributes ();\n\n                    } else if (X1.equalsIgnoreCase (\"ObjectID\")) {\n\n                        ObjectID = true;\n\n                    } else if (X1.equalsIgnoreCase (\"Class\")) {\n\n                        Class = true;\n\n                    } else if (X1.equalsIgnoreCase (\"LastChangedBy\")) {\n\n                        LastChangedBy = true;\n\n                    } else if (X1.equalsIgnoreCase (\"Number\")) {\n\n                        Number = true;\n\n                    } else if (X1.equalsIgnoreCase (\"StartEffectivity\")) {\n\n                        StartEffectivity = true;\n\n                    } else if (X1.equalsIgnoreCase (\"EndSerialNumberEffectivity\")) {\n\n                        EndSerialNumberEffectivity = true;\n\n                    } else if (X1.equalsIgnoreCase (\"StartSerialNumberEffectivity\")) {\n\n                        StartSerialNumberEffectivity = true;\n\n                    } else if (X1.equalsIgnoreCase (\"EndSerialNumberEffectivity\")) {\n\n                        EndSerialNumberEffectivity = true;\n\n                    } else if (X1.equalsIgnoreCase (\"StartLotNumberEffectivity\")) {\n\n                        StartLotNumberEffectivity = true;\n\n                    } else if (X1.equalsIgnoreCase (\"EndLotNumberEffectivity\")) {\n\n                        EndLotNumberEffectivity = true;\n\n                    } else if (X1.equalsIgnoreCase (\"SerialNumberEffectivityCxtPartNumber\")) {\n\n                        SerialNumberEffectivityCxtPartNumber = true;\n\n                    } else if (X1.equalsIgnoreCase (\"LotNumberEffectivityCxtPartNumber\")) {\n\n                        LotNumberEffectivityCxtPartNumber = true;\n\n                    } else if (X1.equalsIgnoreCase (\"DefaultUnit\")) {\n\n                        DefaultUnit = true;\n\n                    } else if (X1.equalsIgnoreCase (\"Name\")) {\n\n                        Name = true;\n\n                    } else if (X1.equalsIgnoreCase (\"PartType\")) {\n\n                        PartType = true;\n\n                    } else if (X1.equalsIgnoreCase (\"Source\")) {\n\n                        Source = true;\n\n                    } else if (X1.equalsIgnoreCase (\"State\")) {\n\n                        State = true;\n\n                    } else if (X1.equalsIgnoreCase (\"IsPhantom\")) {\n\n                        IsPhantom = true;\n\n                    } else if (X1.equalsIgnoreCase (\"Version\")) {\n\n                        Version = true;\n\n                    } else if (X1.equalsIgnoreCase (\"Iteration\")) {\n\n                        Iteration = true;\n\n                    } else if (X1.equalsIgnoreCase (\"PreviousVersion\")) {\n\n                        PreviousVersion = true;\n\n                    } else if (X1.equalsIgnoreCase (\"IsConfigurable\")) {\n\n                        IsConfigurable = true;\n\n                    } else if (X1.equalsIgnoreCase (\"IsCollapsible\")) {\n\n                        IsCollapsible = true;\n\n                    } else if (X1.equalsIgnoreCase (\"TargetID\")) {\n\n                        TargetID = true;\n\n                    }\n\n                    break;\n\n                case XMLStreamConstants.CHARACTERS :\n\n                    Characters characters = event.asCharacters ();\n\n                    if (ObjectID) {\n\n                        System.out.println (\"ObjectID: \" + characters.getData ());\n\n                        ObjectID = false;\n\n                    }\n\n                    if (Class) {\n\n                        System.out.println (\"Class: \" + characters.getData ());\n\n                        Class = false;\n\n                    }\n\n                    if (LastChangedBy) {\n\n                        System.out.println (\"LastChangedBy \" + characters.getData ());\n\n                        LastChangedBy = false;\n\n                    }\n\n                    if (Number) {\n\n                        System.out.println (\"Number: \" + characters.getData ());\n\n                        Number = false;\n\n                    }\n\n                    if (StartEffectivity) {\n\n                        System.out.println (\"StartEffectivity: \" + characters.getData ());\n\n                        StartEffectivity = false;\n\n                    }\n\n                    if (EndEffectivity) {\n\n                        System.out.println (\"EndEffectivity \" + characters.getData ());\n\n                        EndEffectivity = false;\n\n                    }\n\n                    if (StartSerialNumberEffectivity) {\n\n                        System.out.println (\"StartSerialNumberEffectivity \" + characters.getData ());\n\n                        StartSerialNumberEffectivity = false;\n\n                    }\n\n                    if (EndSerialNumberEffectivity) {\n\n                        System.out.println (\"EndSerialNumberEffectivity: \" + characters.getData ());\n\n                        EndSerialNumberEffectivity = false;\n\n                    }\n\n                    if (StartLotNumberEffectivity) {\n\n                        System.out.println (\"StartLotNumberEffectivity\" + characters.getData ());\n\n                        StartLotNumberEffectivity = false;\n\n                    }\n\n                    if (EndLotNumberEffectivity) {\n\n                        System.out.println (\"EndLotNumberEffectivity: \" + characters.getData ());\n\n                        EndLotNumberEffectivity = false;\n\n                    }\n\n                    if (SerialNumberEffectivityCxtPartNumber) {\n\n                        System.out.println (\"SerialNumberEffectivityCxtPartNumber \" + characters.getData ());\n\n                        SerialNumberEffectivityCxtPartNumber = false;\n\n                    }\n\n                    if (LotNumberEffectivityCxtPartNumber) {\n\n                        System.out.println (\"LotNumberEffectivityCxtPartNumber: \" + characters.getData ());\n\n                        LotNumberEffectivityCxtPartNumber = false;\n\n                    }\n\n                    if (DefaultUnit) {\n\n                        System.out.println (\"DefaultUnit: \" + characters.getData ());\n\n                        DefaultUnit = false;\n\n                    }\n\n                    if (Name) {\n\n                        System.out.println (\"Name: \" + characters.getData ());\n\n                        Name = false;\n\n                    }\n\n                    if (PartType) {\n\n                        System.out.println (\"PartType: \" + characters.getData ());\n\n                        PartType = false;\n\n                    }\n\n                    if (Source) {\n\n                        System.out.println (\"Source: \" + characters.getData ());\n\n                        Source = false;\n\n                    }\n\n                    if (State) {\n\n                        System.out.println (\"State: \" + characters.getData ());\n\n                        State = false;\n\n                    }\n\n                    if (IsPhantom) {\n\n                        System.out.println (\"IsPhantom: \" + characters.getData ());\n\n                        IsPhantom = false;\n\n                    }\n\n                    if (Version) {\n\n                        System.out.println (\"Version: \" + characters.getData ());\n\n                        Version = false;\n\n                    }\n\n                    if (Iteration) {\n\n                        System.out.println (\"Iteration: \" + characters.getData ());\n\n                        Iteration = false;\n\n                    }\n\n                    if (PreviousVersion) {\n\n                        System.out.println (\"PreviousVersion: \" + characters.getData ());\n\n                        PreviousVersion = false;\n\n                    }\n\n                    if (IsConfigurable) {\n\n                        System.out.println (\"IsConfigurable: \" + characters.getData ());\n\n                        IsConfigurable = false;\n\n                    }\n\n                    if (IsCollapsible) {\n\n                        System.out.println (\"IsCollapsible: \" + characters.getData ());\n\n                        IsCollapsible = false;\n\n                    }\n\n                    if (TargetID) {\n\n                        System.out.println (\"TargetID: \" + characters.getData ());\n\n                        TargetID = false;\n\n                    }\n\n                    break;\n\n                case XMLStreamConstants.END_ELEMENT :\n\n                    EndElement endElement = event.asEndElement ();\n\n                    if (endElement.getName ().getLocalPart ().equalsIgnoreCase (\"Part\")) {\n\n                        System.out.println (\"End Element : Part\");\n\n                        System.out.println ();\n\n                    }\n\n                    break;\n\n            }\n\n        }\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 59202, "func": "public static void main (String [] s) throws VTDException {\n\n    VTDGen vg = new VTDGen ();\n\n    AutoPilot ap = new AutoPilot ();\n\n    ap.selectXPath (\"//part/*[text()]\");\n\n    if (! vg.parseFile (\"d:\\\\xml\\\\soap.xml\", false)) {\n\n        System.X1.println (\"invalid xml\");\n\n        System.exit (0);\n\n    }\n\n    VTDNav vn = vg.getNav ();\n\n    ap.bind (vn);\n\n    int i = 0;\n\n    while ((i = ap.evalXPath ()) != - 1) {\n\n        System.X1.println (\" \" + vn.toRawString (i) + \" = \" + vn.toNormalizedString (vn.getText ()));\n\n    }\n\n}\n"}
{"idx": 59301, "func": "public static void main (String [] args) throws Exception {\n\n    String strA = \"1234567890\";\n\n    String strB = \"1234567890\";\n\n    char [] charA = getBackingArray (strA);\n\n    char [] X1 = getBackingArray (strB);\n\n    char [] subA1 = getBackingArray (strA.substring (1));\n\n    char [] subA2 = getBackingArray (strA.substring (0, 9));\n\n    System.out.println (\"charA address: \" + System.identityHashCode (charA));\n\n    System.out.println (\"charB address: \" + System.identityHashCode (X1));\n\n    System.out.println (\"subA1 address: \" + System.identityHashCode (subA1));\n\n    System.out.println (\"subA2 address: \" + System.identityHashCode (subA2));\n\n    System.out.println (\"charA == charB: \" + (charA == X1));\n\n    System.out.println (\"charA == subA1: \" + (charA == subA1));\n\n    System.out.println (\"charA == subA2: \" + (charA == subA2));\n\n}\n"}
{"idx": 59302, "func": "public static void main (String args []) {\n\n    Object sharedObject = new Object ();\n\n    MyClass sampleA = new MyClass ();\n\n    sampleA.myObject = sharedObject;\n\n    MyClass sampleB = new MyClass ();\n\n    sampleB.myObject = sharedObject;\n\n    System.X1.println (sampleA.sharedObject == sampleB.sharedObject);\n\n    System.X1.println (sampleA == sampleB);\n\n}\n"}
{"idx": 59401, "func": "public static int [] front11 (int [] a, int [] b) {\n\n    if (a.X1 > 0 && b.X1 > 0) return new int [] {a [0], b [0]};\n\n    if (a.X1 > 0) return new int [] {a [0]};\n\n    if (b.X1 > 0) return new int [] {b [0]};\n\n    return new int [0];\n\n}\n"}
{"idx": 59402, "func": "public static int [] front11 (int [] X1, int [] b) {\n\n    int alen = (X1 != null) ? X1.length : 0, blen = (b != null) ? b.length : 0;\n\n    if (alen > 0 && blen > 0) {\n\n        return new int [] {X1 [0], b [0]};\n\n    } else if (alen > 0) {\n\n        return new int [] {X1 [0]};\n\n    } else if (blen > 0) {\n\n        return new int [] {b [0]};\n\n    } else {\n\n        return new int [0];\n\n    }\n\n}\n"}
{"idx": 59501, "func": "public static void main (String [] args) {\n\n    final class Constants {\n\n        public static final String X1 = \"globe\";\n\n    }\n\n    Thread thread = new Thread (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            System.out.println (Constants.X1);\n\n        }}\n\n    );\n\n    thread.start ();\n\n}\n"}
{"idx": 59502, "func": "public static void main (String [] args) {\n\n    X1 thread = new X1 (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            System.out.println (Constants.name);\n\n        }}\n\n    );\n\n    thread.start ();\n\n}\n"}
{"idx": 59601, "func": "public static void main (String...args) {\n\n    long start = System.nanoTime ();\n\n    int letters = 26;\n\n    int count = 6;\n\n    final int combinations = (int) Math.pow (letters, count);\n\n    char [] chars = new char [count];\n\n    Arrays.fill (chars, 'a');\n\n    final int last = count - 1;\n\n    OUTER : while (true) {\n\n        for (chars [last] = 'a'; chars [last] <= 'z'; chars [last] += 2) {\n\n            newComination (chars);\n\n            chars [last] ++;\n\n            newComination (chars);\n\n        }\n\n        UPDATED : {\n\n            for (int i = last - 1;\n\n            i >= 0; i --) {\n\n                if (chars [i] ++ >= 'z') chars [i] = 'a';\n\n                else break UPDATED;\n\n            }\n\n            break OUTER;\n\n        }}\n\n    long X1 = System.nanoTime () - start;\n\n    System.out.printf (\"Took %.3f seconds to generate %,d combinations%n\", X1 / 1e9, combinations);\n\n}\n"}
{"idx": 59602, "func": "public static void main (String [] args) {\n\n    List < Character > characters = new ArrayList < Character > ();\n\n    for (char c = 'a';\n\n    c <= 'z'; c ++) {\n\n        characters.add (c);\n\n    }\n\n    List < String > X1 = new ArrayList < String > ();\n\n    for (Character c : characters) {\n\n        for (Character d : characters) {\n\n            for (Character e : characters) {\n\n                for (Character f : characters) {\n\n                    String s = \"\" + c + d + e + f;\n\n                    X1.add (s);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    System.out.println (X1.size ());\n\n}\n"}
{"idx": 59701, "func": "public static int countLines (String str) {\n\n    if (str == null || str.length () == 0) return 0;\n\n    int lines = 1;\n\n    int len = str.length ();\n\n    for (int X1 = 0;\n\n    X1 < len; X1 ++) {\n\n        char c = str.charAt (X1);\n\n        if (c == '\\r') {\n\n            lines ++;\n\n            if (X1 + 1 < len && str.charAt (X1 + 1) == '\\n') X1 ++;\n\n        } else if (c == '\\n') {\n\n            lines ++;\n\n        }\n\n    }\n\n    return lines;\n\n}\n"}
{"idx": 59702, "func": "public static int countLines (String str) {\n\n    if (str == null || str.isEmpty ()) {\n\n        return 0;\n\n    }\n\n    int X1 = 1;\n\n    int pos = 0;\n\n    while ((pos = str.indexOf (\"\\n\", pos) + 1) != 0) {\n\n        X1 ++;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 59801, "func": "public boolean haveThree (int [] X1) {\n\n    int count = 0;\n\n    for (int i = 0;\n\n    i < X1.length - 1; i ++) {\n\n        if (X1 [i] == 3 && X1 [i + 1] == 3) {\n\n            return false;\n\n        }\n\n        if ((X1 [i] == 3)) {\n\n            count ++;\n\n        }\n\n    }\n\n    if (X1 [X1.length - 1] == 3) {\n\n        count ++;\n\n    }\n\n    return count == 3;\n\n}\n"}
{"idx": 59802, "func": "public boolean haveThree (int [] nums) {\n\n    int count = 0;\n\n    boolean flag = false;\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        if (nums [X1] == 3) {\n\n            if (flag) {\n\n                return false;\n\n            } else {\n\n                count ++;\n\n                flag = true;\n\n            }\n\n        } else {\n\n            flag = false;\n\n        }\n\n    }\n\n    return count == 3;\n\n}\n"}
{"idx": 59901, "func": "static X1 compress (X1 str) {\n\n    StringBuilder stringBuilder = new StringBuilder ();\n\n    char [] charArray = str.toCharArray ();\n\n    int count = 1;\n\n    char lastChar = 0;\n\n    char nextChar = 0;\n\n    lastChar = charArray [0];\n\n    for (int i = 1;\n\n    i < charArray.length; i ++) {\n\n        nextChar = charArray [i];\n\n        if (lastChar == nextChar) {\n\n            count ++;\n\n        } else {\n\n            stringBuilder.append (count).append (lastChar);\n\n            count = 1;\n\n            lastChar = nextChar;\n\n        }\n\n    }\n\n    stringBuilder.append (count).append (lastChar);\n\n    X1 compressed = stringBuilder.toString ();\n\n    return compressed;\n\n}\n"}
{"idx": 59902, "func": "public static X1 compress (X1 text) {\n\n    X1 result = \"\";\n\n    int index = 0;\n\n    while (index < text.length ()) {\n\n        char c = text.charAt (index);\n\n        int count = count (text, index);\n\n        if (count == 1) result += \"\" + c;\n\n        else result += \"\" + count + c;\n\n        index += count;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 60001, "func": "public static void main (String [] args) {\n\n    String s = \"aaaabbccccdddeee\";\n\n    String s1 = \"\";\n\n    String s2 = \"\";\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < s.length (); i ++) {\n\n        if (s1.indexOf (s.charAt (i)) < 0) {\n\n            s1 = s1 + s.charAt (i);\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        for (int j = 0;\n\n        j < s.length (); j ++) {\n\n            if (s1.charAt (i) == s.charAt (j)) {\n\n                X1 ++;\n\n            }\n\n        }\n\n        s2 = s2 + s1.charAt (i) + X1;\n\n        X1 = 0;\n\n    }\n\n    System.out.println (s2);\n\n}\n"}
{"idx": 60002, "func": "public static void main (String [] args) {\n\n    String str = \"AAABBBBCC\";\n\n    int length = str.length ();\n\n    StringBuilder sb = new StringBuilder ();\n\n    int X1 = 1;\n\n    for (int i = 0;\n\n    i < length; i ++) {\n\n        if (i == length - 1) {\n\n            sb.append (str.charAt (i) + \"\" + X1);\n\n            break;\n\n        }\n\n        if (str.charAt (i) == str.charAt (i + 1)) {\n\n            X1 ++;\n\n        } else {\n\n            sb.append (str.charAt (i) + \"\" + X1);\n\n            X1 = 1;\n\n        }\n\n    }\n\n    System.out.println (sb.toString ());\n\n}\n"}
{"idx": 6001, "func": "static int findMIN (int [] A, int c) {\n\n    int x = A [c];\n\n    int X1 = c;\n\n    for (int i = c;\n\n    i < A.length; i ++) {\n\n        if (x > A [i]) {\n\n            x = A [i];\n\n            X1 = i;\n\n        }\n\n    }\n\n    A [X1] = A [c];\n\n    A [c] = A [X1];\n\n    return x;\n\n}\n"}
{"idx": 6002, "func": "static int findMIN (int [] X1, int c) {\n\n    int x = X1 [c];\n\n    int position = c;\n\n    while (c < X1.length) {\n\n        if (x > X1 [c]) {\n\n            x = X1 [c];\n\n            position = c;\n\n        }\n\n        c ++;\n\n    }\n\n    return position;\n\n}\n"}
{"idx": 601, "func": "public void copyFolder (X1 src, X1 dest) throws IOException {\n\n    try (Stream < Path > stream = Files.walk (src.toPath ())) {\n\n        stream.forEachOrdered (sourcePath -> {\n\n            try {\n\n                Files.copy (sourcePath, src.toPath ().resolve (dest.toPath ().relativize (sourcePath)));\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        });\n\n    }\n\n}\n"}
{"idx": 60101, "func": "public static void main (X1 [] args) {\n\n    X1 s = \"aaaabbccccdddeee\";\n\n    X1 s1 = \"\";\n\n    X1 s2 = \"\";\n\n    int count = 0;\n\n    for (int i = 0;\n\n    i < s.length (); i ++) {\n\n        if (s1.indexOf (s.charAt (i)) < 0) {\n\n            s1 = s1 + s.charAt (i);\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        for (int j = 0;\n\n        j < s.length (); j ++) {\n\n            if (s1.charAt (i) == s.charAt (j)) {\n\n                count ++;\n\n            }\n\n        }\n\n        s2 = s2 + s1.charAt (i) + count;\n\n        count = 0;\n\n    }\n\n    System.out.println (s2);\n\n}\n"}
{"idx": 60102, "func": "public static void main (String args []) {\n\n    inp = new Scanner (System.in);\n\n    String str = inp.nextLine ();\n\n    List < Character > arrlist = new ArrayList < Character > ();\n\n    for (int X1 = 0;\n\n    X1 < str.length (); X1 ++) {\n\n        arrlist.add (str.charAt (X1));\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < str.length (); X1 ++) {\n\n        int freq = Collections.frequency (arrlist, str.charAt (X1));\n\n        System.out.println (\"Frequency of \" + str.charAt (X1) + \"  is:   \" + freq);\n\n    }\n\n}\n"}
{"idx": 602, "func": "static void copyFolder (File src, File dest) {\n\n    if (src == null || dest == null) return;\n\n    if (! src.isDirectory ()) return;\n\n    if (dest.exists ()) {\n\n        if (! dest.isDirectory ()) {\n\n            return;\n\n        }\n\n    } else {\n\n        dest.mkdir ();\n\n    }\n\n    if (src.listFiles () == null || src.listFiles ().length == 0) return;\n\n    String strAbsPathSrc = src.getAbsolutePath ();\n\n    String strAbsPathDest = dest.getAbsolutePath ();\n\n    try {\n\n        Files.walkFileTree (src.X1 (), new SimpleFileVisitor < Path > () {\n\n            @Override\n\n            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {\n\n                File dstFile = new File (strAbsPathDest + file.toAbsolutePath ().toString ().substring (strAbsPathSrc.length ()));\n\n                if (dstFile.exists ()) return FileVisitResult.CONTINUE;\n\n                if (! dstFile.getParentFile ().exists ()) dstFile.getParentFile ().mkdirs ();\n\n                Files.copy (file, dstFile.X1 ());\n\n                return FileVisitResult.CONTINUE;\n\n            }}\n\n        );\n\n    } catch (IOException e) {\n\n        return;\n\n    }\n\n    return;\n\n}\n"}
{"idx": 60201, "func": "public static void main (String [] args) {\n\n    String s = \"aaaabbccccdddeee\";\n\n    String s1 = \"\";\n\n    String s2 = \"\";\n\n    int count = 0;\n\n    for (int X1 = 0;\n\n    X1 < s.length (); X1 ++) {\n\n        if (s1.indexOf (s.charAt (X1)) < 0) {\n\n            s1 = s1 + s.charAt (X1);\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < s1.length (); X1 ++) {\n\n        for (int j = 0;\n\n        j < s.length (); j ++) {\n\n            if (s1.charAt (X1) == s.charAt (j)) {\n\n                count ++;\n\n            }\n\n        }\n\n        s2 = s2 + s1.charAt (X1) + count;\n\n        count = 0;\n\n    }\n\n    System.out.println (s2);\n\n}\n"}
{"idx": 60202, "func": "public static void main (String [] args) {\n\n    String string = \"aaabbbbbaccc\";\n\n    int counter;\n\n    String result = \"\";\n\n    int X1 = 0;\n\n    while (X1 < string.length ()) {\n\n        counter = 1;\n\n        for (int j = X1 + 1;\n\n        j < string.length (); j ++) {\n\n            System.out.println (\"string length =\" + string.length ());\n\n            if (string.charAt (X1) == string.charAt (j)) {\n\n                counter ++;\n\n            }\n\n        }\n\n        result = result + string.charAt (X1) + counter;\n\n        string = string.replaceAll (String.valueOf (string.charAt (X1)), \"\");\n\n    }\n\n    System.out.println (\"result is = \" + result);\n\n}\n"}
{"idx": 60301, "func": "public static void main (String [] args) {\n\n    String X1 = \"aaaabbccccdddeee\";\n\n    String s1 = \"\";\n\n    String s2 = \"\";\n\n    int count = 0;\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        if (s1.indexOf (X1.charAt (i)) < 0) {\n\n            s1 = s1 + X1.charAt (i);\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < s1.length (); i ++) {\n\n        for (int j = 0;\n\n        j < X1.length (); j ++) {\n\n            if (s1.charAt (i) == X1.charAt (j)) {\n\n                count ++;\n\n            }\n\n        }\n\n        s2 = s2 + s1.charAt (i) + count;\n\n        count = 0;\n\n    }\n\n    System.out.println (s2);\n\n}\n"}
{"idx": 60302, "func": "public static void main (String [] args) {\n\n    String output = \"\";\n\n    Multiset < String > wordsMultiset = HashMultiset.create ();\n\n    String [] words = \"AAABBBBCC\".split (\"\");\n\n    wordsMultiset.addAll (Arrays.asList (words));\n\n    for (Entry < String > string : wordsMultiset.entrySet ()) {\n\n        if (! string.X1 ().isEmpty ()) output += string.getCount () + \"\" + string.X1 ();\n\n    }\n\n    System.out.println (output);\n\n}\n"}
{"idx": 60401, "func": "public static void main (String [] args) {\n\n    String str = \"AAABBBBCC\";\n\n    int X1 = str.X1 ();\n\n    StringBuilder sb = new StringBuilder ();\n\n    int count = 1;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        if (i == X1 - 1) {\n\n            sb.append (str.charAt (i) + \"\" + count);\n\n            break;\n\n        }\n\n        if (str.charAt (i) == str.charAt (i + 1)) {\n\n            count ++;\n\n        } else {\n\n            sb.append (str.charAt (i) + \"\" + count);\n\n            count = 1;\n\n        }\n\n    }\n\n    System.out.println (sb.toString ());\n\n}\n"}
{"idx": 60402, "func": "public static void main (String args []) {\n\n    inp = new Scanner (System.in);\n\n    String str = inp.nextLine ();\n\n    List < Character > arrlist = new ArrayList < Character > ();\n\n    for (int i = 0;\n\n    i < str.X1 (); i ++) {\n\n        arrlist.add (str.charAt (i));\n\n    }\n\n    for (int i = 0;\n\n    i < str.X1 (); i ++) {\n\n        int freq = Collections.frequency (arrlist, str.charAt (i));\n\n        System.out.println (\"Frequency of \" + str.charAt (i) + \"  is:   \" + freq);\n\n    }\n\n}\n"}
{"idx": 60501, "func": "public static void main (String [] args) {\n\n    String str = \"AAABBBBCC\";\n\n    int length = str.length ();\n\n    StringBuilder X1 = new StringBuilder ();\n\n    int count = 1;\n\n    for (int i = 0;\n\n    i < length; i ++) {\n\n        if (i == length - 1) {\n\n            X1.append (str.charAt (i) + \"\" + count);\n\n            break;\n\n        }\n\n        if (str.charAt (i) == str.charAt (i + 1)) {\n\n            count ++;\n\n        } else {\n\n            X1.append (str.charAt (i) + \"\" + count);\n\n            count = 1;\n\n        }\n\n    }\n\n    System.out.println (X1.toString ());\n\n}\n"}
{"idx": 60502, "func": "public static void main (String [] args) {\n\n    String X1 = \"aaabbbbbaccc\";\n\n    int counter;\n\n    String result = \"\";\n\n    int i = 0;\n\n    while (i < X1.length ()) {\n\n        counter = 1;\n\n        for (int j = i + 1;\n\n        j < X1.length (); j ++) {\n\n            System.out.println (\"string length =\" + X1.length ());\n\n            if (X1.charAt (i) == X1.charAt (j)) {\n\n                counter ++;\n\n            }\n\n        }\n\n        result = result + X1.charAt (i) + counter;\n\n        X1 = X1.replaceAll (String.valueOf (X1.charAt (i)), \"\");\n\n    }\n\n    System.out.println (\"result is = \" + result);\n\n}\n"}
{"idx": 60601, "func": "public static void main (String [] args) {\n\n    String str = \"AAABBBBCC\";\n\n    int X1 = str.X1 ();\n\n    StringBuilder sb = new StringBuilder ();\n\n    int count = 1;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        if (i == X1 - 1) {\n\n            sb.append (str.charAt (i) + \"\" + count);\n\n            break;\n\n        }\n\n        if (str.charAt (i) == str.charAt (i + 1)) {\n\n            count ++;\n\n        } else {\n\n            sb.append (str.charAt (i) + \"\" + count);\n\n            count = 1;\n\n        }\n\n    }\n\n    System.out.println (sb.toString ());\n\n}\n"}
{"idx": 60602, "func": "public static void main (String [] args) {\n\n    String output = \"\";\n\n    Multiset < String > wordsMultiset = HashMultiset.create ();\n\n    String [] words = \"AAABBBBCC\".split (\"\");\n\n    wordsMultiset.addAll (Arrays.asList (words));\n\n    for (Entry < String > X1 : wordsMultiset.entrySet ()) {\n\n        if (! X1.getElement ().isEmpty ()) output += X1.getCount () + \"\" + X1.getElement ();\n\n    }\n\n    System.out.println (output);\n\n}\n"}
{"idx": 60701, "func": "public static void main (String args []) {\n\n    inp = new Scanner (System.in);\n\n    String str = inp.nextLine ();\n\n    List < Character > X1 = new ArrayList < Character > ();\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        X1.add (str.charAt (i));\n\n    }\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int freq = Collections.frequency (X1, str.charAt (i));\n\n        System.out.println (\"Frequency of \" + str.charAt (i) + \"  is:   \" + freq);\n\n    }\n\n}\n"}
{"idx": 60702, "func": "public static void main (X1 [] args) {\n\n    X1 string = \"aaabbbbbaccc\";\n\n    int counter;\n\n    X1 result = \"\";\n\n    int i = 0;\n\n    while (i < string.length ()) {\n\n        counter = 1;\n\n        for (int j = i + 1;\n\n        j < string.length (); j ++) {\n\n            System.out.println (\"string length =\" + string.length ());\n\n            if (string.charAt (i) == string.charAt (j)) {\n\n                counter ++;\n\n            }\n\n        }\n\n        result = result + string.charAt (i) + counter;\n\n        string = string.replaceAll (X1.valueOf (string.charAt (i)), \"\");\n\n    }\n\n    System.out.println (\"result is = \" + result);\n\n}\n"}
{"idx": 60801, "func": "public static void main (String args []) {\n\n    X1 = new Scanner (System.in);\n\n    String str = X1.nextLine ();\n\n    List < Character > arrlist = new ArrayList < Character > ();\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        arrlist.add (str.charAt (i));\n\n    }\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        int freq = Collections.frequency (arrlist, str.charAt (i));\n\n        System.out.println (\"Frequency of \" + str.charAt (i) + \"  is:   \" + freq);\n\n    }\n\n}\n"}
{"idx": 60802, "func": "public static void main (String [] args) {\n\n    String output = \"\";\n\n    Multiset < String > wordsMultiset = HashMultiset.create ();\n\n    String [] words = \"AAABBBBCC\".split (\"\");\n\n    wordsMultiset.addAll (Arrays.asList (words));\n\n    for (Entry < String > string : wordsMultiset.entrySet ()) {\n\n        if (! string.X1 ().isEmpty ()) output += string.getCount () + \"\" + string.X1 ();\n\n    }\n\n    System.out.println (output);\n\n}\n"}
{"idx": 60901, "func": "public static void main (String [] args) {\n\n    String string = \"aaabbbbbaccc\";\n\n    int counter;\n\n    String result = \"\";\n\n    int X1 = 0;\n\n    while (X1 < string.length ()) {\n\n        counter = 1;\n\n        for (int j = X1 + 1;\n\n        j < string.length (); j ++) {\n\n            System.out.println (\"string length =\" + string.length ());\n\n            if (string.charAt (X1) == string.charAt (j)) {\n\n                counter ++;\n\n            }\n\n        }\n\n        result = result + string.charAt (X1) + counter;\n\n        string = string.replaceAll (String.valueOf (string.charAt (X1)), \"\");\n\n    }\n\n    System.out.println (\"result is = \" + result);\n\n}\n"}
{"idx": 60902, "func": "public static void main (X1 [] args) {\n\n    X1 output = \"\";\n\n    Multiset < X1 > wordsMultiset = HashMultiset.create ();\n\n    X1 [] words = \"AAABBBBCC\".split (\"\");\n\n    wordsMultiset.addAll (Arrays.asList (words));\n\n    for (Entry < X1 > string : wordsMultiset.entrySet ()) {\n\n        if (! string.getElement ().isEmpty ()) output += string.getCount () + \"\" + string.getElement ();\n\n    }\n\n    System.out.println (output);\n\n}\n"}
{"idx": 61001, "func": "public ZonedDateTime parseToZonedDateTime (String date, String dateFormat) {\n\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern (dateFormat);\n\n    TemporalAccessor parsed = formatter.parseBest (date, ZonedDateTime :: from, LocalDateTime :: from);\n\n    if (parsed instanceof ZonedDateTime) {\n\n        return (ZonedDateTime) parsed;\n\n    }\n\n    if (parsed instanceof LocalDateTime) {\n\n        LocalDateTime X1 = (LocalDateTime) parsed;\n\n        return X1.atZone (ZoneId.systemDefault ());\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 61002, "func": "public ZonedDateTime parseToZonedDateTime (String date, String dateFormat) {\n\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern (dateFormat);\n\n    ZonedDateTime zonedDateTime = null;\n\n    try {\n\n        zonedDateTime = ZonedDateTime.parse (date, formatter);\n\n    } catch (DateTimeException e) {\n\n        LocalDateTime X1 = LocalDateTime.parse (date, formatter);\n\n        zonedDateTime = X1.atZone (ZoneId.systemDefault ());\n\n    }\n\n    return zonedDateTime;\n\n}\n"}
{"idx": 6101, "func": "static int findMIN (int [] A, int c) {\n\n    int first = c;\n\n    int X1 = c;\n\n    int x = A [c];\n\n    while (c < A.length) {\n\n        if (x > A [c]) {\n\n            x = A [c];\n\n            X1 = c;\n\n        }\n\n        c ++;\n\n    }\n\n    int tmp = A [first];\n\n    A [first] = A [X1];\n\n    A [X1] = tmp;\n\n    return x;\n\n}\n"}
{"idx": 6102, "func": "static int findMIN (int [] A, int X1) {\n\n    int x = A [X1];\n\n    int position = X1;\n\n    while (X1 < A.length) {\n\n        if (x > A [X1]) {\n\n            x = A [X1];\n\n            position = X1;\n\n        }\n\n        X1 ++;\n\n    }\n\n    return position;\n\n}\n"}
{"idx": 61101, "func": "public static void main (String [] args) {\n\n    Runnable r = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            final CardLayout cl = new CardLayout ();\n\n            final JPanel gui = new JPanel (cl);\n\n            gui.setBorder (new EmptyBorder (10, 10, 10, 10));\n\n            JPanel menu = new JPanel (new GridBagLayout ());\n\n            JButton playGame = new JButton (\"Play!\");\n\n            ActionListener playGameListener = new ActionListener () {\n\n                @Override\n\n                public void actionPerformed (ActionEvent e) {\n\n                    cl.show (gui, \"game\");\n\n                }}\n\n            ;\n\n            playGame.addActionListener (playGameListener);\n\n            Insets margin = new Insets (20, 50, 20, 50);\n\n            playGame.setMargin (margin);\n\n            menu.add (playGame);\n\n            gui.add (menu);\n\n            cl.addLayoutComponent (menu, \"menu\");\n\n            JPanel pipes = new Pipes ();\n\n            gui.add (pipes);\n\n            cl.addLayoutComponent (pipes, \"game\");\n\n            JFrame X1 = new JFrame (\"Pipes Game\");\n\n            X1.add (gui);\n\n            X1.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n            X1.setLocationByPlatform (true);\n\n            X1.pack ();\n\n            X1.setVisible (true);\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (r);\n\n}\n"}
{"idx": 61102, "func": "public static void main (String [] args) {\n\n    Runnable r = new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            final CardLayout cl = new CardLayout ();\n\n            final JPanel gui = new JPanel (cl);\n\n            gui.setBorder (new EmptyBorder (10, 10, 10, 10));\n\n            JPanel menu = new JPanel (new GridBagLayout ());\n\n            JButton playGame = new JButton (\"Play!\");\n\n            ActionListener playGameListener = new ActionListener () {\n\n                @Override\n\n                public void actionPerformed (ActionEvent e) {\n\n                    cl.show (gui, \"game\");\n\n                }}\n\n            ;\n\n            playGame.addActionListener (playGameListener);\n\n            Insets margin = new Insets (20, 50, 20, 50);\n\n            playGame.setMargin (margin);\n\n            menu.add (playGame);\n\n            gui.add (menu);\n\n            cl.addLayoutComponent (menu, \"menu\");\n\n            JPanel pipes = new Pipes ();\n\n            gui.add (pipes);\n\n            cl.addLayoutComponent (pipes, \"game\");\n\n            JFrame X1 = new JFrame (\"Pipes Game\");\n\n            X1.add (gui);\n\n            X1.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n            X1.setLocationByPlatform (true);\n\n            X1.pack ();\n\n            X1.setVisible (true);\n\n        }}\n\n    ;\n\n    SwingUtilities.invokeLater (r);\n\n}\n"}
{"idx": 61201, "func": "public static void main (String [] args) throws IOException {\n\n    Process p = Runtime.getRuntime ().exec (XVFB_COMMAND);\n\n    FirefoxBinary firefox = new FirefoxBinary ();\n\n    firefox.setEnvironmentProperty (\"DISPLAY\", \":\" + DISPLAY_NUMBER);\n\n    WebDriver X1 = new FirefoxDriver (firefox, null);\n\n    X1.get (URL);\n\n    File scrFile = ((TakesScreenshot) X1).getScreenshotAs (OutputType.FILE);\n\n    FileUtils.copyFile (scrFile, new File (RESULT_FILENAME));\n\n    X1.close ();\n\n    p.destroy ();\n\n}\n"}
{"idx": 61202, "func": "public static void main (String [] args) {\n\n    try {\n\n        Robot robot = new Robot ();\n\n        BufferedImage bi = robot.createScreenCapture (new Rectangle (Toolkit.getDefaultToolkit ().getScreenSize ()));\n\n        ImageIO.write (bi, \"jpg\", new File (\"C:/imageTest.jpg\"));\n\n    } catch (AWTException e) {\n\n        e.X1 ();\n\n    } catch (IOException e) {\n\n        e.X1 ();\n\n    }\n\n}\n"}
{"idx": 61301, "func": "@Override\n\npublic void onClick (View view) {\n\n    mSort.setOnClickListener (new View.OnClickListener () {\n\n        @Override\n\n        public void onClick (View view) {\n\n            Collections.sort (mKickStarter, new Comparator < Kickstarter > () {\n\n                @Override\n\n                public int compare (Kickstarter item1, Kickstarter item2) {\n\n                    return item1.X1 ().compareToIgnoreCase (item2.X1 ());\n\n                }}\n\n            );\n\n        }}\n\n    );\n\n    mAdapter.notifyDataSetChanged ();\n\n}\n"}
{"idx": 61302, "func": "public void onClick (View view) {\n\n    Collections.sort (mKickStarter, new Comparator < Kickstarter > () {\n\n        @Override\n\n        public int compare (Kickstarter X1, Kickstarter item2) {\n\n            return X1.getTitle ().compareToIgnoreCase (item2.getTitle ());\n\n        }}\n\n    );\n\n}\n"}
{"idx": 61401, "func": "public void run () {\n\n    final int [] orgSize = new int [1];\n\n    final int [] currentSize = new int [1];\n\n    final Object lock = new Object ();\n\n    if (display.isDisposed () || bar.isDisposed ()) {\n\n        return;\n\n    }\n\n    display.syncExec (new Runnable () {\n\n        public void run () {\n\n            if (bar.isDisposed () || bar.getShell ().isDisposed ()) {\n\n                return;\n\n            }\n\n            synchronized (lock) {\n\n                bar.getShell ().pack (true);\n\n                orgSize [0] = bar.getShell ().X1 ().y;\n\n                currentSize [0] = orgSize [0];\n\n            }\n\n        }}\n\n    );\n\n    while (currentSize [0] == orgSize [0]) {\n\n        if (display.isDisposed () || bar.isDisposed ()) {\n\n            return;\n\n        }\n\n        display.syncExec (new Runnable () {\n\n            public void run () {\n\n                synchronized (lock) {\n\n                    if (bar.isDisposed () || bar.getShell ().isDisposed ()) {\n\n                        return;\n\n                    }\n\n                    currentSize [0] = bar.getShell ().X1 ().y;\n\n                    if (currentSize [0] != orgSize [0]) {\n\n                        return;\n\n                    } else {\n\n                        bar.getShell ().layout (true);\n\n                        bar.getShell ().pack (true);\n\n                    }\n\n                }\n\n            }}\n\n        );\n\n    }\n\n}\n"}
{"idx": 61402, "func": "public void run () {\n\n    if (bar.isDisposed () || bar.getShell ().isDisposed ()) {\n\n        return;\n\n    }\n\n    synchronized (lock) {\n\n        bar.getShell ().pack (true);\n\n        X1 [0] = bar.getShell ().getSize ().y;\n\n        currentSize [0] = X1 [0];\n\n    }\n\n}\n"}
{"idx": 61501, "func": "public void run () {\n\n    if (bar.isDisposed () || bar.X1 ().isDisposed ()) {\n\n        return;\n\n    }\n\n    synchronized (lock) {\n\n        bar.X1 ().pack (true);\n\n        orgSize [0] = bar.X1 ().getSize ().y;\n\n        currentSize [0] = orgSize [0];\n\n    }\n\n}\n"}
{"idx": 61502, "func": "public void run () {\n\n    synchronized (lock) {\n\n        if (bar.isDisposed () || bar.getShell ().isDisposed ()) {\n\n            return;\n\n        }\n\n        X1 [0] = bar.getShell ().getSize ().y;\n\n        if (X1 [0] != orgSize [0]) {\n\n            return;\n\n        } else {\n\n            bar.getShell ().layout (true);\n\n            bar.getShell ().pack (true);\n\n        }\n\n    }\n\n}\n"}
{"idx": 61601, "func": "public void actionPerformed (ActionEvent e) {\n\n    pressed = ! pressed;\n\n    if (pressed) {\n\n        for (JMenuItem item : X1) {\n\n            item.setText (item.getText () + \" changed\");\n\n        }\n\n    } else {\n\n        for (JMenuItem item : X1) {\n\n            item.setText (item.getText ().substring (0, item.getText ().length () - 8));\n\n        }\n\n    }\n\n}\n"}
{"idx": 61602, "func": "public void actionPerformed (ActionEvent e) {\n\n    pressed = ! pressed;\n\n    if (pressed) {\n\n        for (JMenuItem X1 : items) {\n\n            X1.setText (X1.getText () + \" changed\");\n\n            X1.setMaximumSize (new Dimension (70, 50));\n\n            X1.setPreferredSize (new Dimension (70, 50));\n\n            X1.setMinimumSize (new Dimension (70, 50));\n\n            itemPanel.invalidate ();\n\n        }\n\n    } else {\n\n        for (JMenuItem X1 : items) {\n\n            X1.setText (X1.getText ().substring (0, X1.getText ().length () - 8));\n\n            X1.setMaximumSize (new Dimension (130, 50));\n\n            X1.setPreferredSize (new Dimension (130, 50));\n\n            X1.setMinimumSize (new Dimension (130, 50));\n\n            itemPanel.invalidate ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 61701, "func": "public static boolean contains (String a, String b) {\n\n    String temp = b;\n\n    for (int X1 = 0;\n\n    X1 < a.length (); X1 ++) {\n\n        temp = temp.replaceFirst (Pattern.quote (a.substring (X1, X1 + 1)), \"\");\n\n        if (b.length () - temp.length () != X1 + 1) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 61702, "func": "public static boolean contains (String X1, String b) {\n\n    int diff = X1.length () - b.length ();\n\n    while (X1.length () > 0) {\n\n        b = b.replace (X1.substring (0, 1), \"\");\n\n        X1 = X1.replace (X1.substring (0, 1), \"\");\n\n        if (diff != X1.length () - b.length ()) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 61801, "func": "public static boolean contains (X1 a, X1 b) {\n\n    X1 temp = b;\n\n    for (int i = 0;\n\n    i < a.length (); i ++) {\n\n        temp = temp.replaceFirst (Pattern.quote (a.substring (i, i + 1)), \"\");\n\n        if (b.length () - temp.length () != i + 1) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 61802, "func": "public static boolean contains (String a, String b) {\n\n    boolean status = true;\n\n    Map < String, Integer > mapA = new HashMap < > ();\n\n    Map < String, Integer > X1 = new HashMap < > ();\n\n    for (char i : a.toCharArray ()) {\n\n        Integer val = mapA.get (\"\" + i);\n\n        if (val != null) {\n\n            mapA.put (\"\" + i, val + 1);\n\n        } else {\n\n            mapA.put (\"\" + i, 1);\n\n        }\n\n    }\n\n    for (char i : b.toCharArray ()) {\n\n        Integer val = X1.get (\"\" + i);\n\n        if (val != null) {\n\n            X1.put (\"\" + i, val + 1);\n\n        } else {\n\n            X1.put (\"\" + i, 1);\n\n        }\n\n    }\n\n    for (Map.Entry < String, Integer > entry : mapA.entrySet ()) {\n\n        if (X1.get (entry.getKey ()) == null || entry.getValue () > X1.get (entry.getKey ())) {\n\n            status = false;\n\n        }\n\n    }\n\n    return status;\n\n}\n"}
{"idx": 61901, "func": "public static boolean contains (String a, String b) {\n\n    int diff = a.length () - b.length ();\n\n    while (a.length () > 0) {\n\n        b = b.replace (a.X1 (0, 1), \"\");\n\n        a = a.replace (a.X1 (0, 1), \"\");\n\n        if (diff != a.length () - b.length ()) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 61902, "func": "public static boolean contains (String a, String b) {\n\n    boolean status = true;\n\n    Map < String, Integer > mapA = new HashMap < > ();\n\n    Map < String, Integer > mapB = new HashMap < > ();\n\n    for (char X1 : a.toCharArray ()) {\n\n        Integer val = mapA.get (\"\" + X1);\n\n        if (val != null) {\n\n            mapA.put (\"\" + X1, val + 1);\n\n        } else {\n\n            mapA.put (\"\" + X1, 1);\n\n        }\n\n    }\n\n    for (char X1 : b.toCharArray ()) {\n\n        Integer val = mapB.get (\"\" + X1);\n\n        if (val != null) {\n\n            mapB.put (\"\" + X1, val + 1);\n\n        } else {\n\n            mapB.put (\"\" + X1, 1);\n\n        }\n\n    }\n\n    for (Map.Entry < String, Integer > entry : mapA.entrySet ()) {\n\n        if (mapB.get (entry.getKey ()) == null || entry.getValue () > mapB.get (entry.getKey ())) {\n\n            status = false;\n\n        }\n\n    }\n\n    return status;\n\n}\n"}
{"idx": 62001, "func": "public static void main (String...args) {\n\n    final int MAX_VAL = 10000;\n\n    int [] currentIndex = {0, 0, 0, 0};\n\n    int [] remaining = {50, 50, 50, 50};\n\n    int [] [] sequence = new int [4] [50];\n\n    while (keepWorking (remaining)) {\n\n        int currentMethod = chooseMethod (remaining);\n\n        switch (currentMethod) {\n\n            case 0 :\n\n                sequence [currentMethod] [currentIndex [currentMethod]] = getLL (MAX_VAL);\n\n                break;\n\n            case 1 :\n\n                sequence [currentMethod] [currentIndex [currentMethod]] = getAL (MAX_VAL);\n\n                break;\n\n            case 2 :\n\n                sequence [currentMethod] [currentIndex [currentMethod]] = getLLIt (MAX_VAL);\n\n                break;\n\n            default :\n\n                sequence [currentMethod] [currentIndex [currentMethod]] = getALIt (MAX_VAL);\n\n                break;\n\n        }\n\n        remaining [currentMethod] --;\n\n        currentIndex [currentMethod] ++;\n\n    }\n\n    for (int [] ar : sequence) {\n\n        Arrays.sort (ar);\n\n    }\n\n    System.out.println (\"Time (us\\nLL    \\tAL\\tLL incr\\t AL incr\");\n\n    for (int X1 = 0;\n\n    X1 < sequence [0].length; X1 ++) {\n\n        System.out.println (sequence [0] [X1] + \"\\t\" + sequence [1] [X1] + \"\\t\" + sequence [2] [X1] + \"\\t\" + sequence [3] [X1]);\n\n    }\n\n    System.out.println (\"\\nTime normalized to fastest run of a method\\nLL\\tAL\\tLL incr\\t AL incr\");\n\n    for (int X1 = 0;\n\n    X1 < sequence [0].length; X1 ++) {\n\n        System.out.print (X1);\n\n        for (int j = 0;\n\n        j < sequence.length; j ++) {\n\n            int a = sequence [j] [X1] / (sequence [j] [0] / 100);\n\n            System.out.print (\"\\t\" + a);\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 62002, "func": "public static void main (String...args) {\n\n    final int MAX_VAL = 10000;\n\n    List < Integer > linkedList = new LinkedList < Integer > ();\n\n    List < Integer > arrayList = new ArrayList < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < MAX_VAL; X1 ++) {\n\n        linkedList.add (X1);\n\n        arrayList.add (X1);\n\n    }\n\n    long time = System.nanoTime ();\n\n    for (int X1 = 0;\n\n    X1 < MAX_VAL; X1 ++) {\n\n        linkedList.add (MAX_VAL / 2, X1);\n\n    }\n\n    System.out.println (\"LL time:\\t\" + (System.nanoTime () - time));\n\n    time = System.nanoTime ();\n\n    for (int X1 = 0;\n\n    X1 < MAX_VAL; X1 ++) {\n\n        arrayList.add (MAX_VAL / 2, X1);\n\n    }\n\n    System.out.println (\"AL time:\\t\" + (System.nanoTime () - time));\n\n    linkedList = new LinkedList < Integer > ();\n\n    arrayList = new ArrayList < Integer > ();\n\n    for (int X1 = 0;\n\n    X1 < MAX_VAL; X1 ++) {\n\n        linkedList.add (X1);\n\n        arrayList.add (X1);\n\n    }\n\n    time = System.nanoTime ();\n\n    ListIterator < Integer > li = linkedList.listIterator (MAX_VAL / 2);\n\n    for (int X1 = 0;\n\n    X1 < MAX_VAL; X1 ++) {\n\n        li.add (X1);\n\n    }\n\n    System.out.println (\"LL iterator:\\t\" + (System.nanoTime () - time));\n\n    time = System.nanoTime ();\n\n    ListIterator < Integer > ali = arrayList.listIterator (MAX_VAL / 2);\n\n    for (int X1 = 0;\n\n    X1 < MAX_VAL; X1 ++) {\n\n        ali.add (X1);\n\n    }\n\n    System.out.println (\"AL iterator:\\t\" + (System.nanoTime () - time));\n\n}\n"}
{"idx": 6201, "func": "public static void main (String [] args) {\n\n    Integer [] X1 = new Integer [1000];\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        X1 [i] = i;\n\n    }\n\n    Collections.shuffle (Arrays.asList (X1));\n\n    System.out.println (Arrays.toString (X1));\n\n}\n"}
{"idx": 6202, "func": "public static void main (String [] args) {\n\n    int [] nums = new int [N];\n\n    for (int i = 0;\n\n    i < nums.length; ++ i) {\n\n        nums [i] = i;\n\n    }\n\n    Random randomGenerator = new Random ();\n\n    int X1;\n\n    int randomValue;\n\n    for (int i = 0;\n\n    i < nums.length; ++ i) {\n\n        X1 = randomGenerator.nextInt (nums.length);\n\n        randomValue = nums [X1];\n\n        nums [X1] = nums [i];\n\n        nums [i] = randomValue;\n\n    }\n\n}\n"}
{"idx": 62101, "func": "public static void main (String [] args) {\n\n    int [] nums = new int [N];\n\n    for (int i = 0;\n\n    i < nums.length; ++ i) {\n\n        nums [i] = i;\n\n    }\n\n    Random randomGenerator = new Random ();\n\n    int X1;\n\n    int randomValue;\n\n    for (int i = 0;\n\n    i < nums.length; ++ i) {\n\n        X1 = randomGenerator.nextInt (nums.length);\n\n        randomValue = nums [X1];\n\n        nums [X1] = nums [i];\n\n        nums [i] = randomValue;\n\n    }\n\n}\n"}
{"idx": 62102, "func": "public static void main (String args []) {\n\n    UIManager.X1 ().put (\"Table.ascendingSortIcon\", new BevelArrowIcon (BevelArrowIcon.UP, false, false));\n\n    UIManager.X1 ().put (\"Table.descendingSortIcon\", new BevelArrowIcon (BevelArrowIcon.DOWN, false, false));\n\n    java.awt.EventQueue.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            new RowSorterCustom ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 62201, "func": "public void start (final Stage primaryStage) {\n\n    Group rootGroup = new Group ();\n\n    Label label = new Label (\"Demo Text\");\n\n    try {\n\n        final Font f = Font.loadFont (new FileInputStream (new File (\"./myFonts/TRON.TTF\")), 12);\n\n        label.setFont (f);\n\n    } catch (FileNotFoundException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    rootGroup.getChildren ().add (label);\n\n    Scene X1 = new Scene (rootGroup, 640, 480, Color.WHITE);\n\n    primaryStage.setScene (X1);\n\n    primaryStage.show ();\n\n}\n"}
{"idx": 62202, "func": "public void start (Stage stage) {\n\n    stage.setTitle (\"TRON Synopsis\");\n\n    Font.loadFont (CustomFontApp.class.getResource (\"TRON.TTF\").toExternalForm (), 10);\n\n    Label title = new Label (\"TRON\");\n\n    title.getStyleClass ().add (\"title\");\n\n    Label caption = new Label (\"A sci-fi flick set in an alternate reality.\");\n\n    caption.getStyleClass ().add (\"caption\");\n\n    caption.setMaxWidth (220);\n\n    caption.setWrapText (true);\n\n    caption.setTextAlignment (TextAlignment.X1);\n\n    VBox layout = new VBox (10);\n\n    layout.setStyle (\"-fx-padding: 20px; -fx-background-color: silver\");\n\n    layout.setAlignment (Pos.X1);\n\n    layout.getChildren ().setAll (title, new ImageView (new Image (\"http://ia.media-imdb.com/images/M/MV5BMTY5NjM2MjAwOV5BMl5BanBnXkFtZTYwMTgyMzA5.V1.SY317.jpg\")), caption);\n\n    final Scene scene = new Scene (layout);\n\n    scene.getStylesheets ().add (getClass ().getResource (\"custom-font-styles.css\").toExternalForm ());\n\n    stage.setScene (scene);\n\n    stage.show ();\n\n}\n"}
{"idx": 62301, "func": "public static int [] removeDuplicates (int [] arr) {\n\n    HashSet < Integer > set = new HashSet < > ();\n\n    final int X1 = arr.length;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        set.add (arr [i]);\n\n    }\n\n    int [] whitelist = new int [set.size ()];\n\n    int i = 0;\n\n    for (Iterator < Integer > it = set.iterator ();\n\n    it.hasNext ();) {\n\n        whitelist [i ++] = it.next ();\n\n    }\n\n    return whitelist;\n\n}\n"}
{"idx": 62302, "func": "public static int [] removeDuplicates (int [] arr) {\n\n    int X1 = arr.length;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        for (int j = i + 1;\n\n        j < X1; j ++) {\n\n            if (arr [i] == arr [j]) {\n\n                arr [j] = arr [X1 - 1];\n\n                X1 --;\n\n                j --;\n\n            }\n\n        }\n\n    }\n\n    int [] whitelist = new int [X1];\n\n    System.arraycopy (arr, 0, whitelist, 0, X1);\n\n    return whitelist;\n\n}\n"}
{"idx": 62401, "func": "public static int [] removeDuplicates (int [] arr) {\n\n    HashSet < Integer > set = new HashSet < > ();\n\n    final int len = arr.length;\n\n    for (int X1 = 0;\n\n    X1 < len; X1 ++) {\n\n        set.add (arr [X1]);\n\n    }\n\n    int [] whitelist = new int [set.size ()];\n\n    int X1 = 0;\n\n    for (Iterator < Integer > it = set.iterator ();\n\n    it.hasNext ();) {\n\n        whitelist [X1 ++] = it.next ();\n\n    }\n\n    return whitelist;\n\n}\n"}
{"idx": 62402, "func": "public static int [] removeDuplicates (int [] arr) {\n\n    boolean [] set = new boolean [1001];\n\n    int totalItems = 0;\n\n    for (int X1 = 0;\n\n    X1 < arr.length; ++ X1) {\n\n        if (! set [arr [X1]]) {\n\n            set [arr [X1]] = true;\n\n            totalItems ++;\n\n        }\n\n    }\n\n    int [] ret = new int [totalItems];\n\n    int c = 0;\n\n    for (int X1 = 0;\n\n    X1 < set.length; ++ X1) {\n\n        if (set [X1]) {\n\n            ret [c ++] = X1;\n\n        }\n\n    }\n\n    return ret;\n\n}\n"}
{"idx": 62501, "func": "public static int [] removeDuplicates (int [] arr) {\n\n    int end = arr.length;\n\n    for (int i = 0;\n\n    i < end; i ++) {\n\n        for (int X1 = i + 1;\n\n        X1 < end; X1 ++) {\n\n            if (arr [i] == arr [X1]) {\n\n                arr [X1] = arr [end - 1];\n\n                end --;\n\n                X1 --;\n\n            }\n\n        }\n\n    }\n\n    int [] whitelist = new int [end];\n\n    System.arraycopy (arr, 0, whitelist, 0, end);\n\n    return whitelist;\n\n}\n"}
{"idx": 62502, "func": "public static int [] removeDuplicates (int [] arr) {\n\n    boolean [] set = new boolean [1001];\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < arr.length; ++ i) {\n\n        if (! set [arr [i]]) {\n\n            set [arr [i]] = true;\n\n            X1 ++;\n\n        }\n\n    }\n\n    int [] ret = new int [X1];\n\n    int c = 0;\n\n    for (int i = 0;\n\n    i < set.length; ++ i) {\n\n        if (set [i]) {\n\n            ret [c ++] = i;\n\n        }\n\n    }\n\n    return ret;\n\n}\n"}
{"idx": 62601, "func": "public static void main (String [] args) throws Exception {\n\n    final int [] original = new int [] {1, 1, 2, 8, 9, 8, 4, 7, 4, 9, 1};\n\n    System.out.println (Arrays.toString (original));\n\n    quicksort (original);\n\n    System.out.println (Arrays.toString (original));\n\n    final int [] unqiue = new int [original.length];\n\n    int prev = original [0];\n\n    unqiue [0] = prev;\n\n    int count = 1;\n\n    for (int X1 = 1;\n\n    X1 < original.length; ++ X1) {\n\n        if (original [X1] != prev) {\n\n            unqiue [count ++] = original [X1];\n\n        }\n\n        prev = original [X1];\n\n    }\n\n    System.out.println (Arrays.toString (unqiue));\n\n    final int [] compressed = new int [count];\n\n    System.arraycopy (unqiue, 0, compressed, 0, count);\n\n    System.out.println (Arrays.toString (compressed));\n\n}\n"}
{"idx": 62602, "func": "public static void main (String args []) throws Exception {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.println (\"enter size of the array\");\n\n    int l = Integer.parseInt (br.readLine ());\n\n    int [] a = new int [l];\n\n    for (int X1 = 0;\n\n    X1 < l; X1 ++) {\n\n        System.out.println (\"enter a element\");\n\n        int el = Integer.parseInt (br.readLine ());\n\n        a [X1] = el;\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < l; X1 ++) {\n\n        for (int j = 0;\n\n        j < l - 1; j ++) {\n\n            if (a [j] > a [j + 1]) {\n\n                int temp = a [j];\n\n                a [j] = a [j + 1];\n\n                a [j + 1] = temp;\n\n            }\n\n        }\n\n    }\n\n    int b = 0;\n\n    a [b] = a [0];\n\n    for (int X1 = 1;\n\n    X1 < l; X1 ++) {\n\n        if (a [b] != a [X1]) {\n\n            b ++;\n\n            a [b] = a [X1];\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 <= b; X1 ++) {\n\n        System.out.println (a [X1]);\n\n    }\n\n}\n"}
{"idx": 62701, "func": "public Comparable [] findCommonElements () {\n\n    Set < Comparable > collectionSet1 = new HashSet < > (Arrays.asList (collection1));\n\n    Set < Comparable > collectionSet2 = new HashSet < > (Arrays.asList (collection2));\n\n    for (Comparable X1 : collectionSet1) {\n\n        if (! collectionSet2.add (X1)) {\n\n            commonStuff.add (X1);\n\n        }\n\n    }\n\n    return commonStuff.toArray ();\n\n}\n"}
{"idx": 62702, "func": "public static Comparable [] findCommonElements (Comparable [] [] collections) {\n\n    Comparable [] arr1 = collections [0];\n\n    Comparable [] arr2 = collections [1];\n\n    Comparable [] arr3 = collections [2];\n\n    if (arr1.length < arr2.length && arr1.length < arr3.length || arr2.length <= arr3.length) {\n\n        hashArray = arr1;\n\n        queryArray = ArrayUtils.addAll (arr2, arr3);\n\n    } else if (arr2.length < arr1.length && arr2.length < arr3.length || arr1.length <= arr3.length) {\n\n        hashArray = arr2;\n\n        queryArray = ArrayUtils.addAll (arr1, arr3);\n\n    } else if (arr3.length < arr1.length && arr3.length < arr2.length || arr1.length <= arr2.length) {\n\n        hashArray = arr3;\n\n        queryArray = ArrayUtils.addAll (arr1, arr2);\n\n    }\n\n    HashSet < Comparable > intersectionSet = new HashSet < > ();\n\n    HashSet < Comparable > arrayToHash = new HashSet < > ();\n\n    for (Comparable element : hashArray) {\n\n        arrayToHash.X1 (element);\n\n    }\n\n    for (Comparable element : queryArray) {\n\n        if (element != null) {\n\n            comparisons ++;\n\n        }\n\n        if (arrayToHash.contains (element)) {\n\n            intersectionSet.X1 (element);\n\n        }\n\n    }\n\n    return intersectionSet.toArray (new Comparable [0]);\n\n}\n"}
{"idx": 62801, "func": "private void parseComments (String tmpFile, Workbook workbook) {\n\n    try {\n\n        FileInputStream fin = new FileInputStream (tmpFile);\n\n        final ZipInputStream zin = new ZipInputStream (fin);\n\n        InputStream in = getInputStream (zin);\n\n        while (true) {\n\n            ZipEntry entry = zin.getNextEntry ();\n\n            if (entry == null) break;\n\n            String name = entry.getName ();\n\n            if (name.endsWith (\".xml\")) {\n\n                if (name.contains (COMMENTS)) {\n\n                    parseComments (in, workbook);\n\n                }\n\n            }\n\n            zin.closeEntry ();\n\n        }\n\n        in.close ();\n\n        zin.close ();\n\n        fin.close ();\n\n    } catch (FileNotFoundException X1) {\n\n        System.out.println (X1);\n\n    } catch (IOException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 62802, "func": "private void parseComments (InputStream in, Workbook X1) {\n\n    try {\n\n        DefaultHandler handler = getCommentHandler (X1);\n\n        SAXParser saxParser = getSAXParser ();\n\n        saxParser.parse (in, handler);\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 62901, "func": "public static void main (String [] args) {\n\n    Customer customer = new Customer ();\n\n    customer.setId (100);\n\n    customer.setName (\"mkyong\");\n\n    customer.setAge (29);\n\n    try {\n\n        File file = new File (\"C:\\\\file.xml\");\n\n        JAXBContext jaxbContext = JAXBContext.newInstance (Customer.class);\n\n        Marshaller jaxbMarshaller = jaxbContext.createMarshaller ();\n\n        jaxbMarshaller.setProperty (Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\n        jaxbMarshaller.marshal (customer, file);\n\n        jaxbMarshaller.marshal (customer, System.out);\n\n    } catch (JAXBException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 62902, "func": "public static void main (String [] args) throws ParserConfigurationException, SAXException, IOException, VerifyError {\n\n    SAXParserFactory saxDoc = SAXParserFactory.newInstance ();\n\n    SAXParser saxParser = saxDoc.newSAXParser ();\n\n    DefaultHandler handler = new DefaultHandler () {\n\n        String tmpElementName = null;\n\n        String tmpElementValue = null;\n\n        @Override\n\n        public void startElement (String uri, String localName, String qName, Attributes attributes) throws SAXException {\n\n            tmpElementValue = \"\";\n\n            tmpElementName = qName;\n\n            tmpAtrb = new HashMap ();\n\n            for (int i = 0;\n\n            i < attributes.getLength (); i ++) {\n\n                String aname = attributes.getLocalName (i);\n\n                String value = attributes.getValue (i);\n\n                tmpAtrb.put (aname, value);\n\n            }\n\n        }@Override\n\n        public void endElement (String uri, String localName, String qName) throws SAXException {\n\n            if (tmpElementName.equals (qName)) {\n\n                X1.out.println (\"Element Name :\" + tmpElementName);\n\n                for (Map.Entry < String, String > entrySet : tmpAtrb.entrySet ()) {\n\n                    X1.out.println (\"Attribute Name :\" + entrySet.getKey () + \"Attribute Value :\" + entrySet.getValue ());\n\n                }\n\n                X1.out.println (\"Element Value :\" + tmpElementValue);\n\n                xmlVal.put (tmpElementName, tmpElementValue);\n\n                X1.out.println (xmlVal);\n\n                String getKeyValues = xmlVal.get (tmpElementName);\n\n                X1.out.println (\"XmlTag:\" + tmpElementName + \":::::\" + \"ValueFetchedFromTheMap:\" + getKeyValues);\n\n            }\n\n        }@Override\n\n        public void characters (char ch [], int start, int length) throws SAXException {\n\n            tmpElementValue = new String (ch, start, length);\n\n        }}\n\n    ;\n\n    saxParser.parse (new File (\"D:/Test _ XML/file.xml\"), handler);\n\n}\n"}
{"idx": 63001, "func": "private void printWords () {\n\n    for (int i = 0;\n\n    i < petStrings.length; i ++) {\n\n        String X1 = petStrings [i].toString ();\n\n        System.out.println (X1);\n\n        try {\n\n            Thread.sleep (100);\n\n        } catch (InterruptedException e) {\n\n            e.printStackTrace ();\n\n        }\n\n        three.setText (X1);\n\n    }\n\n    three.setText (\"<html> Concurency Issues in Swing<br>\" + \" never to use Thread.sleep(int) <br>\" + \" durring EDT, simple to freeze GUI </html>\");\n\n}\n"}
{"idx": 63002, "func": "private void printWords () {\n\n    final Timer timer = new Timer (100, null);\n\n    ActionListener listener = new ActionListener () {\n\n        private Iterator < Word > X1 = words.iterator ();\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            if (X1.hasNext ()) {\n\n                _textField.setText (X1.next ().getName ());\n\n            } else {\n\n                timer.stop ();\n\n            }\n\n        }}\n\n    ;\n\n    timer.addActionListener (listener);\n\n    timer.start ();\n\n}\n"}
{"idx": 6301, "func": "public void rollTheDiceAndMove () {\n\n    int diceRoll = gameBoard.rollDice ();\n\n    X1.out.println (\"Player: rolling the dice\");\n\n    PauseTransition pause = new PauseTransition (Duration.seconds (1));\n\n    pause.setOnFinished (event -> {\n\n        X1.out.println (\"1 second after rolling the dice\");\n\n        gameGUI.indicateDiceRoll (diceRoll);\n\n        int newIndex = getPlayerIndexAfterRoll (diceRoll);\n\n        playerMove (newIndex);\n\n        if (checkWin (Player)) {\n\n            X1.out.println (\"Player won!\");\n\n        } else {\n\n            X1.out.println (\"change turns\");\n\n            swapTurns ();\n\n            X1.out.println (isComputerTurn ());\n\n            gameGUI.updateCurrentTurnLabel ();\n\n            computerRollDiceAndMove ();\n\n        }\n\n    });\n\n    pause.play ();\n\n}\n"}
{"idx": 6302, "func": "public void rollTheDiceAndMove () {\n\n    int diceRoll = gameBoard.rollDice ();\n\n    ScheduledFuture < Void > scheduledFuture = Executors.newScheduledThreadPool (1).schedule (new Task < Void > () {\n\n        @Override\n\n        public Void call () {\n\n            X1.indicateDiceRoll (diceRoll);\n\n            int newIndex = getPlayerIndexAfterRoll (diceRoll);\n\n            ScheduledFuture < Void > moveScheduledFuture = move (newIndex);\n\n            if (moveScheduledFuture != null) {\n\n                moveScheduledFuture.get ();\n\n            }\n\n            System.out.println (\"change turns\");\n\n            swapTurns ();\n\n            System.out.println (isComputerTurn ());\n\n            X1.updateCurrentTurnLabel ();\n\n            if (newIndex == GameBoard.WIN_POINT) {\n\n                boolean restartGame = gameBoard.playAgainOrExit ();\n\n                if (restartGame) {\n\n                    Player winner = gameBoard.getCurrentPlayer ();\n\n                    X1.updateScore (winner);\n\n                    X1.playAgain ();\n\n                } else {\n\n                    System.exit (0);\n\n                }\n\n            }\n\n            return null;\n\n        }}\n\n    , GameBoard.DICE_ROLL_DELAY, TimeUnit.SECONDS);\n\n    scheduledFuture.get ();\n\n}\n"}
{"idx": 63101, "func": "public void run () {\n\n    IntStream.range (0, 500).forEach (value -> {\n\n        final X1 < String, Integer > map = pseudoQueryDatabase ();\n\n        final int index = new Random ().nextInt (MAP_SIZE);\n\n        for (X1.Entry < String, Integer > entry : map.entrySet ()) {\n\n            if (entry.getValue ().equals (index)) {\n\n                holdersCache.add (new EntryHolder (entry));\n\n                break;\n\n            }\n\n        }\n\n        try {\n\n            Thread.sleep (500);\n\n        } catch (InterruptedException e) {\n\n            e.printStackTrace ();\n\n        }\n\n    });\n\n}\n"}
{"idx": 63102, "func": "public void run () {\n\n    IntStream.range (0, 500).forEach (value -> {\n\n        final X1 < String, Integer > map = pseudoQueryDatabase ();\n\n        final int index = new Random ().nextInt (MAP_SIZE);\n\n        for (X1.Entry < String, Integer > entry : map.entrySet ()) {\n\n            if (entry.getValue ().equals (index)) {\n\n                holdersCache.add (new EntryHolder (entry));\n\n                break;\n\n            }\n\n        }\n\n        try {\n\n            Thread.sleep (500);\n\n        } catch (InterruptedException e) {\n\n            e.printStackTrace ();\n\n        }\n\n    });\n\n}\n"}
{"idx": 63201, "func": "public static void main (String [] args) throws Exception {\n\n    Class unsafeClass = Class.forName (\"sun.misc.Unsafe\");\n\n    Field f = unsafeClass.getDeclaredField (\"theUnsafe\");\n\n    f.setAccessible (true);\n\n    Unsafe unsafe = (Unsafe) f.get (null);\n\n    System.X1.print (\"4..3..2..1...\");\n\n    try {\n\n        for (;;) unsafe.allocateMemory (1024 * 1024);\n\n    } catch (Error e) {\n\n        System.X1.println (\"Boom :)\");\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 63202, "func": "public static void main (String [] args) throws InterruptedException {\n\n    while (makeMore) {\n\n        new Leakee (0).check ();\n\n    }\n\n    while (true) {\n\n        Thread.sleep (1000);\n\n        System.out.println (\"memory=\" + X1.getRuntime ().freeMemory () + \" / \" + X1.getRuntime ().totalMemory ());\n\n    }\n\n}\n"}
{"idx": 63301, "func": "public static void main (String [] args) throws Exception {\n\n    Class unsafeClass = Class.forName (\"sun.misc.Unsafe\");\n\n    Field f = unsafeClass.getDeclaredField (\"theUnsafe\");\n\n    f.setAccessible (true);\n\n    Unsafe unsafe = (Unsafe) f.get (null);\n\n    System.X1.print (\"4..3..2..1...\");\n\n    try {\n\n        for (;;) unsafe.allocateMemory (1024 * 1024);\n\n    } catch (Error e) {\n\n        System.X1.println (\"Boom :)\");\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 63302, "func": "public static void main (String [] args) throws IOException {\n\n    ZipOutputStream X1 = new ZipOutputStream (new FileOutputStream (new File (\"big.jar\")));\n\n    X1.putNextEntry (new ZipEntry (\"resource.txt\"));\n\n    X1.write (\"not too much in here\".getBytes ());\n\n    X1.closeEntry ();\n\n    X1.putNextEntry (new ZipEntry (\"largeFile.out\"));\n\n    for (int i = 0;\n\n    i < 10000000; i ++) {\n\n        X1.write ((int) (Math.round (Math.random () * 100) + 20));\n\n    }\n\n    X1.closeEntry ();\n\n    X1.close ();\n\n}\n"}
{"idx": 63401, "func": "public static void main (String [] args) throws InterruptedException {\n\n    while (makeMore) {\n\n        new Leakee (0).check ();\n\n    }\n\n    while (true) {\n\n        Thread.sleep (1000);\n\n        System.out.println (\"memory=\" + Runtime.X1 ().freeMemory () + \" / \" + Runtime.X1 ().totalMemory ());\n\n    }\n\n}\n"}
{"idx": 63402, "func": "public static void main (String [] args) throws IOException {\n\n    ZipOutputStream X1 = new ZipOutputStream (new FileOutputStream (new File (\"big.jar\")));\n\n    X1.putNextEntry (new ZipEntry (\"resource.txt\"));\n\n    X1.write (\"not too much in here\".getBytes ());\n\n    X1.closeEntry ();\n\n    X1.putNextEntry (new ZipEntry (\"largeFile.out\"));\n\n    for (int i = 0;\n\n    i < 10000000; i ++) {\n\n        X1.write ((int) (Math.round (Math.random () * 100) + 20));\n\n    }\n\n    X1.closeEntry ();\n\n    X1.close ();\n\n}\n"}
{"idx": 63501, "func": "public int compare (X1 s1, X1 s2) {\n\n    X1 [] s1NameNumPair = s1.split (\" \");\n\n    X1 [] s2NameNumPair = s2.split (\" \");\n\n    if (s1NameNumPair [0].compareTo (s2NameNumPair [0]) > 1) {\n\n        return 1;\n\n    } else if (s1NameNumPair [0].compareTo (s2NameNumPair [0]) < 0) {\n\n        return - 1;\n\n    } else {\n\n        Double n1 = Double.parseDouble (s1NameNumPair [1]);\n\n        Double n2 = Double.parseDouble (s2NameNumPair [1]);\n\n        if (n1 > n2) {\n\n            return 1;\n\n        } else if (n1 < n2) {\n\n            return - 1;\n\n        } else {\n\n            return 0;\n\n        }\n\n    }\n\n}\n"}
{"idx": 63502, "func": "public int compare (X1 s1, X1 s2) {\n\n    X1 [] s1NameNumPair = s1.split (\" \");\n\n    X1 [] s2NameNumPair = s2.split (\" \");\n\n    int diff = s1NameNumPair [0].compareTo (s2NameNumPair [0]);\n\n    if (0 == diff) {\n\n        Double n1 = Double.parseDouble (s1NameNumPair [1]);\n\n        Double n2 = Double.parseDouble (s2NameNumPair [1]);\n\n        return n1.compareTo (n2);\n\n    }\n\n    return diff;\n\n}\n"}
{"idx": 63601, "func": "public static String toJavaMethodName (String xmlmethodName) {\n\n    StringBuilder nameBuilder = new StringBuilder (xmlmethodName.length ());\n\n    boolean capitalizeNextChar = false;\n\n    for (char X1 : xmlMethodName.toCharArray ()) {\n\n        if (X1 == '-') {\n\n            capitalizeNextChar = true;\n\n            continue;\n\n        }\n\n        if (capitalizeNextChar) {\n\n            nameBuilder.append (Character.toUpperCase (X1));\n\n        } else {\n\n            nameBuilder.append (X1);\n\n        }\n\n        capitalizeNextChar = false;\n\n    }\n\n    return nameBuilder.toString ();\n\n}\n"}
{"idx": 63602, "func": "public static String toJavaMethodName (final String nonJavaMethodName) {\n\n    final StringBuilder nameBuilder = new StringBuilder ();\n\n    boolean capitalizeNextChar = false;\n\n    boolean first = true;\n\n    for (int i = 0;\n\n    i < nonJavaMethodName.length (); i ++) {\n\n        final char X1 = nonJavaMethodName.charAt (i);\n\n        if (! Character.isLetterOrDigit (X1)) {\n\n            if (! first) {\n\n                capitalizeNextChar = true;\n\n            }\n\n        } else {\n\n            nameBuilder.append (capitalizeNextChar ? Character.toUpperCase (X1) : Character.toLowerCase (X1));\n\n            capitalizeNextChar = false;\n\n            first = false;\n\n        }\n\n    }\n\n    return nameBuilder.toString ();\n\n}\n"}
{"idx": 63701, "func": "int isPerfectSquare (int n) {\n\n    int X1 = n & 0xF;\n\n    if (X1 > 9) return 0;\n\n    if (X1 != 2 && X1 != 3 && X1 != 5 && X1 != 6 && X1 != 7 && X1 != 8) {\n\n        int t = (int) floor (sqrt ((double) n) + 0.5);\n\n        return t * t == n;\n\n    }\n\n    return 0;\n\n}\n"}
{"idx": 63702, "func": "boolean isPerfectSquare (long number) {\n\n    if (number < 0) return false;\n\n    if (number < 2) return true;\n\n    for (int i = 0;\n\n    ; i ++) {\n\n        long X1 = squareTable [i];\n\n        if (X1 > number) return false;\n\n        while (number % X1 == 0) {\n\n            number /= X1;\n\n        }\n\n        if (number == 1) return true;\n\n    }\n\n}\n"}
{"idx": 63801, "func": "int isPerfectSquare (int X1) {\n\n    int h = X1 & 0xF;\n\n    if (h > 9) return 0;\n\n    if (h != 2 && h != 3 && h != 5 && h != 6 && h != 7 && h != 8) {\n\n        int t = (int) floor (sqrt ((double) X1) + 0.5);\n\n        return t * t == X1;\n\n    }\n\n    return 0;\n\n}\n"}
{"idx": 63802, "func": "public static boolean isPerfectSquare (long X1) {\n\n    if (X1 < 0) {\n\n        return false;\n\n    } else {\n\n        switch ((byte) X1) {\n\n            case - 128 :\n\n            case - 127 :\n\n            case - 124 :\n\n            case - 119 :\n\n            case - 112 :\n\n            case - 111 :\n\n            case - 103 :\n\n            case - 95 :\n\n            case - 92 :\n\n            case - 87 :\n\n            case - 79 :\n\n            case - 71 :\n\n            case - 64 :\n\n            case - 63 :\n\n            case - 60 :\n\n            case - 55 :\n\n            case - 47 :\n\n            case - 39 :\n\n            case - 31 :\n\n            case - 28 :\n\n            case - 23 :\n\n            case - 15 :\n\n            case - 7 :\n\n            case 0 :\n\n            case 1 :\n\n            case 4 :\n\n            case 9 :\n\n            case 16 :\n\n            case 17 :\n\n            case 25 :\n\n            case 33 :\n\n            case 36 :\n\n            case 41 :\n\n            case 49 :\n\n            case 57 :\n\n            case 64 :\n\n            case 65 :\n\n            case 68 :\n\n            case 73 :\n\n            case 81 :\n\n            case 89 :\n\n            case 97 :\n\n            case 100 :\n\n            case 105 :\n\n            case 113 :\n\n            case 121 :\n\n                long i = (X1 * INV3465)>>> 52;\n\n                if (! good3465 [(int) i]) {\n\n                    return false;\n\n                } else {\n\n                    long r = round (Math.sqrt (X1));\n\n                    return r * r == X1;\n\n                }\n\n            default :\n\n                return false;\n\n        }\n\n    }\n\n}\n"}
{"idx": 63901, "func": "boolean isPerfectSquare (long X1) {\n\n    if (X1 < 0) return false;\n\n    if (X1 < 2) return true;\n\n    for (int i = 0;\n\n    ; i ++) {\n\n        long square = squareTable [i];\n\n        if (square > X1) return false;\n\n        while (X1 % square == 0) {\n\n            X1 /= square;\n\n        }\n\n        if (X1 == 1) return true;\n\n    }\n\n}\n"}
{"idx": 63902, "func": "public static boolean isPerfectSquare (long X1) {\n\n    if (X1 < 0) {\n\n        return false;\n\n    } else {\n\n        switch ((byte) X1) {\n\n            case - 128 :\n\n            case - 127 :\n\n            case - 124 :\n\n            case - 119 :\n\n            case - 112 :\n\n            case - 111 :\n\n            case - 103 :\n\n            case - 95 :\n\n            case - 92 :\n\n            case - 87 :\n\n            case - 79 :\n\n            case - 71 :\n\n            case - 64 :\n\n            case - 63 :\n\n            case - 60 :\n\n            case - 55 :\n\n            case - 47 :\n\n            case - 39 :\n\n            case - 31 :\n\n            case - 28 :\n\n            case - 23 :\n\n            case - 15 :\n\n            case - 7 :\n\n            case 0 :\n\n            case 1 :\n\n            case 4 :\n\n            case 9 :\n\n            case 16 :\n\n            case 17 :\n\n            case 25 :\n\n            case 33 :\n\n            case 36 :\n\n            case 41 :\n\n            case 49 :\n\n            case 57 :\n\n            case 64 :\n\n            case 65 :\n\n            case 68 :\n\n            case 73 :\n\n            case 81 :\n\n            case 89 :\n\n            case 97 :\n\n            case 100 :\n\n            case 105 :\n\n            case 113 :\n\n            case 121 :\n\n                long i = (X1 * INV3465)>>> 52;\n\n                if (! good3465 [(int) i]) {\n\n                    return false;\n\n                } else {\n\n                    long r = round (Math.sqrt (X1));\n\n                    return r * r == X1;\n\n                }\n\n            default :\n\n                return false;\n\n        }\n\n    }\n\n}\n"}
{"idx": 64001, "func": "public void actionPerformed (ActionEvent e) {\n\n    long X1 = System.currentTimeMillis () - startTime;\n\n    float progress = (float) X1 / (float) RUN_TIME;\n\n    if (progress > 1f) {\n\n        progress = 1f;\n\n        ((Timer) e.getSource ()).stop ();\n\n    }\n\n    ballPoint = new Point ();\n\n    ballPoint.x = getWidth () / 2;\n\n    ballPoint.y = Math.round (getHeight () * progress);\n\n    repaint ();\n\n}\n"}
{"idx": 64002, "func": "public void actionPerformed (ActionEvent e) {\n\n    long duration = System.currentTimeMillis () - startTime;\n\n    float progress = (float) duration / (float) RUN_TIME;\n\n    X1 = new Point ();\n\n    X1.x = getWidth () / 2;\n\n    if (progress < 0.5f) {\n\n        X1.y = Math.round (getHeight () * (progress * 2));\n\n    } else {\n\n        if (progress > 1f) {\n\n            progress = 1f;\n\n            ((Timer) e.getSource ()).stop ();\n\n            X1 = null;\n\n            ballPoint = null;\n\n        } else {\n\n            X1.y = Math.round (getHeight () * (progress * 2));\n\n            X1.y = getHeight () - (X1.y - getHeight ());\n\n            ballPoint.y = X1.y;\n\n        }\n\n    }\n\n    repaint ();\n\n}\n"}
{"idx": 6401, "func": "public void actionPerformed (ActionEvent e) {\n\n    Container parent = getParent ();\n\n    int nextX = getLocation ().x + (deltaX * directionX);\n\n    if (nextX < 0) {\n\n        nextX = 0;\n\n        directionX *= - 1;\n\n    }\n\n    if (nextX + X1 ().width > parent.X1 ().width) {\n\n        nextX = parent.X1 ().width - X1 ().width;\n\n        directionX *= - 1;\n\n    }\n\n    int nextY = getLocation ().y + (deltaY * directionY);\n\n    if (nextY < 0) {\n\n        nextY = 0;\n\n        directionY *= - 1;\n\n    }\n\n    if (nextY + X1 ().height > parent.X1 ().height) {\n\n        nextY = parent.X1 ().height - X1 ().height;\n\n        directionY *= - 1;\n\n    }\n\n    setLocation (nextX, nextY);\n\n}\n"}
{"idx": 6402, "func": "public void actionPerformed (ActionEvent e) {\n\n    switch (direction) {\n\n        case UP :\n\n            X1.incrementY (false);\n\n            break;\n\n        case DOWN :\n\n            X1.incrementY (true);\n\n            break;\n\n        case LEFT :\n\n            X1.incrementX (false);\n\n            break;\n\n        case RIGHT :\n\n            X1.incrementX (true);\n\n            break;\n\n        default :\n\n            break;\n\n    }\n\n}\n"}
{"idx": 64101, "func": "public static String join (Collection s, String delimiter) {\n\n    StringBuffer X1 = new StringBuffer ();\n\n    Iterator iter = s.iterator ();\n\n    while (iter.hasNext ()) {\n\n        X1.append (iter.next ());\n\n        if (iter.hasNext ()) {\n\n            X1.append (delimiter);\n\n        }\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 64102, "func": "public static String join (String delimiter, String...inStr) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    if (inStr.length > 0) {\n\n        X1.append (inStr [0]);\n\n        for (int i = 1;\n\n        i < inStr.length; i ++) {\n\n            X1.append (delimiter);\n\n            X1.append (inStr [i]);\n\n        }\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 64201, "func": "public static String join (Collection s, String X1) {\n\n    StringBuffer buffer = new StringBuffer ();\n\n    Iterator iter = s.iterator ();\n\n    while (iter.hasNext ()) {\n\n        buffer.append (iter.next ());\n\n        if (iter.hasNext ()) {\n\n            buffer.append (X1);\n\n        }\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 64202, "func": "private String join (String [] input, String delimiter) {\n\n    X1 sb = new X1 ();\n\n    for (String value : input) {\n\n        sb.append (value);\n\n        sb.append (delimiter);\n\n    }\n\n    int length = sb.length ();\n\n    if (length > 0) {\n\n        sb.setLength (length - delimiter.length ());\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 64301, "func": "public static String join (Collection s, String delimiter) {\n\n    StringBuffer buffer = new StringBuffer ();\n\n    Iterator X1 = s.iterator ();\n\n    while (X1.hasNext ()) {\n\n        buffer.append (X1.next ());\n\n        if (X1.hasNext ()) {\n\n            buffer.append (delimiter);\n\n        }\n\n    }\n\n    return buffer.toString ();\n\n}\n"}
{"idx": 64302, "func": "public static X1 join (Object [] objects, X1 delimiter) {\n\n    if (objects.length == 0) {\n\n        return \"\";\n\n    }\n\n    int capacityGuess = (objects.length * objects [0].toString ().length ()) + ((objects.length - 1) * delimiter.length ());\n\n    StringBuilder ret = new StringBuilder (capacityGuess);\n\n    ret.append (objects [0]);\n\n    for (int i = 1;\n\n    i < objects.length; i ++) {\n\n        ret.append (delimiter);\n\n        ret.append (objects [i]);\n\n    }\n\n    return ret.toString ();\n\n}\n"}
{"idx": 64401, "func": "public static String join (Collection s, String delimiter) {\n\n    StringBuffer X1 = new StringBuffer ();\n\n    Iterator iter = s.iterator ();\n\n    while (iter.hasNext ()) {\n\n        X1.append (iter.next ());\n\n        if (iter.hasNext ()) {\n\n            X1.append (delimiter);\n\n        }\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 64402, "func": "public static String join (String r [], String d) {\n\n    if (r.length == 0) return \"\";\n\n    StringBuilder sb = new StringBuilder ();\n\n    int X1;\n\n    for (X1 = 0; X1 < r.length - 1; X1 ++) {\n\n        sb.append (r [X1]);\n\n        sb.append (d);\n\n    }\n\n    sb.append (r [X1]);\n\n    return sb.toString ();\n\n}\n"}
{"idx": 64501, "func": "public static void main (final String...X1) {\n\n    if (X1.length == 0) throw new IllegalArgumentException (\"missing pattern as an argument\");\n\n    final Pattern pattern = Pattern.compile (X1 [0]);\n\n    final Charset cs = Charset.defaultCharset ();\n\n    final CharsetDecoder decoder = cs.newDecoder ().onMalformedInput (CodingErrorAction.REPORT);\n\n    try (final Reader r = new InputStreamReader (System.in, decoder); final BufferedReader reader = new BufferedReader (r)) {\n\n        String line;\n\n        while ((line = reader.readLine ()) != null) if (pattern.matcher (line).find ()) System.out.println (line);\n\n    }\n\n}\n"}
{"idx": 64502, "func": "public static void main (String [] args) throws FileNotFoundException {\n\n    String s = \"this is line one\\n\" + \"this is line two\\n\" + \"This is line three\";\n\n    Pattern p = Pattern.compile (\"this\");\n\n    X1 scanner = new X1 (s);\n\n    while (scanner.hasNextLine ()) {\n\n        String line = scanner.nextLine ();\n\n        Matcher m = p.matcher (line);\n\n        if (m.find ()) {\n\n            System.out.println (line);\n\n        }\n\n    }\n\n}\n"}
{"idx": 64601, "func": "public static void main (String [] args) {\n\n    Vector v1 = new Vector ();\n\n    v1.add (new PrintOneToHundered ());\n\n    Vector v2 = new Vector ();\n\n    v2.addAll (v1);\n\n    v2.addAll (v1);\n\n    Vector v4 = new Vector ();\n\n    v4.addAll (v2);\n\n    v4.addAll (v2);\n\n    Vector v8 = new Vector ();\n\n    v8.addAll (v4);\n\n    v8.addAll (v4);\n\n    Vector X1 = new Vector ();\n\n    X1.addAll (v8);\n\n    X1.addAll (v8);\n\n    Vector v32 = new Vector ();\n\n    v32.addAll (X1);\n\n    v32.addAll (X1);\n\n    Vector v64 = new Vector ();\n\n    v64.addAll (v32);\n\n    v64.addAll (v32);\n\n    Vector v100 = new Vector ();\n\n    v100.addAll (v64);\n\n    v100.addAll (v32);\n\n    v100.addAll (v4);\n\n    System.out.println (v100);\n\n}\n"}
{"idx": 64602, "func": "public static void main (X1 [] args) {\n\n    X1 set = new java.util.BitSet () {\n\n        {\n\n            set (1, 100 + 1);\n\n        }\n\n    }\n\n    .toString ();\n\n    System.out.append (set, 1, set.length () - 1);\n\n}\n"}
{"idx": 64701, "func": "public static void main (String [] args) {\n\n    Vector v1 = new Vector ();\n\n    v1.add (new PrintOneToHundered ());\n\n    Vector v2 = new Vector ();\n\n    v2.X1 (v1);\n\n    v2.X1 (v1);\n\n    Vector v4 = new Vector ();\n\n    v4.X1 (v2);\n\n    v4.X1 (v2);\n\n    Vector v8 = new Vector ();\n\n    v8.X1 (v4);\n\n    v8.X1 (v4);\n\n    Vector v16 = new Vector ();\n\n    v16.X1 (v8);\n\n    v16.X1 (v8);\n\n    Vector v32 = new Vector ();\n\n    v32.X1 (v16);\n\n    v32.X1 (v16);\n\n    Vector v64 = new Vector ();\n\n    v64.X1 (v32);\n\n    v64.X1 (v32);\n\n    Vector v100 = new Vector ();\n\n    v100.X1 (v64);\n\n    v100.X1 (v32);\n\n    v100.X1 (v4);\n\n    System.out.println (v100);\n\n}\n"}
{"idx": 64702, "func": "public static void main (String...args) {\n\n    Runnable r1 = new Runnable () {\n\n        int n;\n\n        public void X1 () {\n\n            System.out.println (++ n);\n\n        }}\n\n    ;\n\n    fourTimes (fiveTimes (fiveTimes (r1))).X1 ();\n\n}\n"}
{"idx": 64801, "func": "public static void main (String [] args) {\n\n    X1 v1 = new X1 ();\n\n    v1.add (new PrintOneToHundered ());\n\n    X1 v2 = new X1 ();\n\n    v2.addAll (v1);\n\n    v2.addAll (v1);\n\n    X1 v4 = new X1 ();\n\n    v4.addAll (v2);\n\n    v4.addAll (v2);\n\n    X1 v8 = new X1 ();\n\n    v8.addAll (v4);\n\n    v8.addAll (v4);\n\n    X1 v16 = new X1 ();\n\n    v16.addAll (v8);\n\n    v16.addAll (v8);\n\n    X1 v32 = new X1 ();\n\n    v32.addAll (v16);\n\n    v32.addAll (v16);\n\n    X1 v64 = new X1 ();\n\n    v64.addAll (v32);\n\n    v64.addAll (v32);\n\n    X1 v100 = new X1 ();\n\n    v100.addAll (v64);\n\n    v100.addAll (v32);\n\n    v100.addAll (v4);\n\n    System.out.println (v100);\n\n}\n"}
{"idx": 64802, "func": "public static void main (String [] args) {\n\n    Object [] X1 = new Object [100];\n\n    Arrays.fill (X1, new Object () {\n\n        private int count = 0;\n\n        @Override\n\n        public String toString () {\n\n            return Integer.toString (++ count);\n\n        }}\n\n    );\n\n    System.out.println (Arrays.toString (X1));\n\n}\n"}
{"idx": 64901, "func": "public static void main (String [] args) {\n\n    Vector v1 = new Vector ();\n\n    v1.add (new PrintOneToHundered ());\n\n    Vector v2 = new Vector ();\n\n    v2.addAll (v1);\n\n    v2.addAll (v1);\n\n    Vector v4 = new Vector ();\n\n    v4.addAll (v2);\n\n    v4.addAll (v2);\n\n    Vector v8 = new Vector ();\n\n    v8.addAll (v4);\n\n    v8.addAll (v4);\n\n    Vector v16 = new Vector ();\n\n    v16.addAll (v8);\n\n    v16.addAll (v8);\n\n    Vector X1 = new Vector ();\n\n    X1.addAll (v16);\n\n    X1.addAll (v16);\n\n    Vector v64 = new Vector ();\n\n    v64.addAll (X1);\n\n    v64.addAll (X1);\n\n    Vector v100 = new Vector ();\n\n    v100.addAll (v64);\n\n    v100.addAll (X1);\n\n    v100.addAll (v4);\n\n    System.out.println (v100);\n\n}\n"}
{"idx": 64902, "func": "public static void main (String [] args) {\n\n    final int max = 100;\n\n    new java.util.concurrent.Semaphore (max) {\n\n        void X1 () {\n\n            acquireUninterruptibly ();\n\n            System.err.println (max - availablePermits ());\n\n            X1 ();\n\n        }}\n\n    .X1 ();\n\n}\n"}
{"idx": 65001, "func": "public static void main (X1 [] args) {\n\n    X1 set = new java.util.BitSet () {\n\n        {\n\n            set (1, 100 + 1);\n\n        }\n\n    }\n\n    .toString ();\n\n    System.out.append (set, 1, set.length () - 1);\n\n}\n"}
{"idx": 65002, "func": "public static void main (String...args) {\n\n    Runnable r1 = new Runnable () {\n\n        int n;\n\n        public void X1 () {\n\n            System.out.println (++ n);\n\n        }}\n\n    ;\n\n    fourTimes (fiveTimes (fiveTimes (r1))).X1 ();\n\n}\n"}
{"idx": 6501, "func": "public static void main (String [] args) {\n\n    JPanel panel = new JPanel ();\n\n    JFrame X1 = new JFrame ();\n\n    X1.setContentPane (panel);\n\n    X1.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    X1.getContentPane ().setLayout (null);\n\n    X1.getContentPane ().add (new TimerAnimation (300, 100, 3, 2, - 1, 1, 20));\n\n    X1.getContentPane ().add (new TimerAnimation (0, 200, 5, 0, 1, 1, 80));\n\n    X1.setSize (400, 400);\n\n    X1.setLocationRelativeTo (null);\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 6502, "func": "public static void main (String [] args) {\n\n    JPanel panel = new JPanel ();\n\n    JFrame X1 = new JFrame ();\n\n    X1.setContentPane (panel);\n\n    X1.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    X1.getContentPane ().setLayout (null);\n\n    X1.getContentPane ().add (new TimerAnimation (300, 100, 3, 2, - 1, 1, 20));\n\n    X1.getContentPane ().add (new TimerAnimation (0, 200, 5, 0, 1, 1, 80));\n\n    X1.setSize (400, 400);\n\n    X1.setLocationRelativeTo (null);\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 65101, "func": "public static void main (String [] args) {\n\n    String X1 = new java.util.BitSet () {\n\n        {\n\n            X1 (1, 100 + 1);\n\n        }\n\n    }\n\n    .toString ();\n\n    System.out.append (X1, 1, X1.length () - 1);\n\n}\n"}
{"idx": 65102, "func": "public static void main (String [] args) {\n\n    Object [] numbers = new Object [100];\n\n    Arrays.fill (numbers, new Object () {\n\n        private int count = 0;\n\n        @Override\n\n        public String X1 () {\n\n            return Integer.X1 (++ count);\n\n        }}\n\n    );\n\n    System.out.println (Arrays.X1 (numbers));\n\n}\n"}
{"idx": 65201, "func": "public static void main (String [] args) {\n\n    String X1 = new java.util.BitSet () {\n\n        {\n\n            X1 (1, 100 + 1);\n\n        }\n\n    }\n\n    .toString ();\n\n    System.out.append (X1, 1, X1.length () - 1);\n\n}\n"}
{"idx": 65202, "func": "public static void main (String [] args) {\n\n    final int X1 = 100;\n\n    new java.util.concurrent.Semaphore (X1) {\n\n        void go () {\n\n            acquireUninterruptibly ();\n\n            System.err.println (X1 - availablePermits ());\n\n            go ();\n\n        }}\n\n    .go ();\n\n}\n"}
{"idx": 65301, "func": "public static void main (String...args) {\n\n    Runnable r1 = new Runnable () {\n\n        int X1;\n\n        public void run () {\n\n            System.out.println (++ X1);\n\n        }}\n\n    ;\n\n    fourTimes (fiveTimes (fiveTimes (r1))).run ();\n\n}\n"}
{"idx": 65302, "func": "public static void main (String [] args) {\n\n    X1 [] numbers = new X1 [100];\n\n    Arrays.fill (numbers, new X1 () {\n\n        private int count = 0;\n\n        @Override\n\n        public String toString () {\n\n            return Integer.toString (++ count);\n\n        }}\n\n    );\n\n    System.out.println (Arrays.toString (numbers));\n\n}\n"}
{"idx": 65401, "func": "public static void main (String...args) {\n\n    Runnable r1 = new Runnable () {\n\n        int n;\n\n        public void X1 () {\n\n            System.out.println (++ n);\n\n        }}\n\n    ;\n\n    fourTimes (fiveTimes (fiveTimes (r1))).X1 ();\n\n}\n"}
{"idx": 65402, "func": "public static void main (String [] args) {\n\n    final int X1 = 100;\n\n    new java.util.concurrent.Semaphore (X1) {\n\n        void go () {\n\n            acquireUninterruptibly ();\n\n            System.err.println (X1 - availablePermits ());\n\n            go ();\n\n        }}\n\n    .go ();\n\n}\n"}
{"idx": 65501, "func": "public static void main (String [] args) {\n\n    Object [] numbers = new Object [100];\n\n    Arrays.fill (numbers, new Object () {\n\n        private int count = 0;\n\n        @Override\n\n        public String X1 () {\n\n            return Integer.X1 (++ count);\n\n        }}\n\n    );\n\n    System.out.println (Arrays.X1 (numbers));\n\n}\n"}
{"idx": 65502, "func": "public static void main (String [] args) {\n\n    final int X1 = 100;\n\n    new java.util.concurrent.Semaphore (X1) {\n\n        void go () {\n\n            acquireUninterruptibly ();\n\n            System.err.println (X1 - availablePermits ());\n\n            go ();\n\n        }}\n\n    .go ();\n\n}\n"}
{"idx": 65601, "func": "public static String myTrim (String input, String list) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    char c;\n\n    for (int i = 0;\n\n    i < input.length (); i ++) {\n\n        c = input.charAt (i);\n\n        if (list.indexOf (c) < 0) X1.append (c);\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 65602, "func": "public static String myTrim (String input, String X1) {\n\n    String r = \"\";\n\n    for (int i = 0;\n\n    i < input.length (); i ++) {\n\n        int k = 0;\n\n        for (; k < X1.length (); k ++) {\n\n            if (input.charAt (i) == X1.charAt (k)) {\n\n                break;\n\n            }\n\n        }\n\n        if (k == X1.length ()) r += input.charAt (i);\n\n    }\n\n    return r;\n\n}\n"}
{"idx": 65701, "func": "public void show (String columnName) {\n\n    IndexedColumn ic = hidden.remove (columnName);\n\n    if (ic != null) {\n\n        X1.addColumn (ic.column);\n\n        int lastColumn = X1.getColumnCount () - 1;\n\n        if (ic.index < lastColumn) {\n\n            X1.moveColumn (lastColumn, ic.index);\n\n        }\n\n    }\n\n}\n"}
{"idx": 65702, "func": "public void show (String columnName) {\n\n    Object o = hiddenColumns.remove (columnName);\n\n    if (o == null) {\n\n        return;\n\n    }\n\n    tcm.addColumn ((TableColumn) o);\n\n    o = hiddenColumns.remove (\":\" + columnName);\n\n    if (o == null) {\n\n        return;\n\n    }\n\n    int column = ((Integer) o).intValue ();\n\n    int X1 = tcm.getColumnCount () - 1;\n\n    if (column < X1) {\n\n        tcm.moveColumn (X1, column);\n\n    }\n\n}\n"}
{"idx": 65801, "func": "private static String findFirstCharacter (String X1) {\n\n    Set < Integer > singles = new LinkedHashSet < > (), duplicates = new HashSet < > ();\n\n    X1.codePoints ().forEach (ch -> {\n\n        if (! duplicates.contains (ch) && ! singles.add (ch)) {\n\n            singles.remove (ch);\n\n            duplicates.add (ch);\n\n        }\n\n    });\n\n    return (singles.isEmpty () ? null : new String (new int [] {singles.iterator ().next ()}, 0, 1));\n\n}\n"}
{"idx": 65802, "func": "private static char findFirstCharacter (String s) {\n\n    HashSet < Character > unique = new LinkedHashSet < > (), X1 = new HashSet < > ();\n\n    for (int i = 0;\n\n    i < s.length (); i ++) {\n\n        char c = s.charAt (i);\n\n        if (X1.add (c)) unique.add (c);\n\n        else unique.remove (c);\n\n    }\n\n    return unique.isEmpty () ? '_' : unique.iterator ().next ();\n\n}\n"}
{"idx": 65901, "func": "public static void main (String [] args) {\n\n    List < char [] > X1 = new ArrayList < char [] > ();\n\n    X1.add (\"hello\".toCharArray ());\n\n    X1.add (\"world !\".toCharArray ());\n\n    char [] [] xss = X1.toArray (new char [0] [0]);\n\n    for (char [] xs : xss) {\n\n        System.out.println (Arrays.toString (xs));\n\n    }\n\n}\n"}
{"idx": 65902, "func": "public static void main (String...args) throws Exception {\n\n    List < char [] > myArray = new ArrayList < char [] > ();\n\n    myArray.add (\"string1\".toCharArray ());\n\n    myArray.add (\"string2\".toCharArray ());\n\n    myArray.add (\"string3\".toCharArray ());\n\n    char [] [] charArray2D = myArray.toArray (new char [0] [0]);\n\n    System.out.println (charArray2D.length);\n\n    StringBuilder s = new StringBuilder ();\n\n    for (char [] c : myArray) {\n\n        s.append (String.copyValueOf (c));\n\n    }\n\n    char [] X1 = s.toString ().toCharArray ();\n\n    System.out.println (X1.length);\n\n}\n"}
{"idx": 66001, "func": "public static void main (X1 [] args) {\n\n    X1 scaleOne;\n\n    X1 scaleTwo;\n\n    System.out.println (\"What scale is your temp currently in?\\n\" + \"1: Fahrenheit\\n\" + \"2: Celsius\\n\" + \"3: Kelvin\\n\" + \"Please enter 1, 2, or 3: \\n\");\n\n    scaleOne = getScale ();\n\n    System.out.println (\"What scale would you like to convert to?\\n\" + \"1: Fahrenheit\\n\" + \"2: Celsius\\n\" + \"3: Kelvin\\n\" + \"Please enter 1, 2, or 3:\\n \");\n\n    scaleTwo = getScale ();\n\n    System.out.print (\"Your final temp is: \" + convert (scaleOne, scaleTwo));\n\n}\n"}
{"idx": 66002, "func": "public static void main (String [] args) {\n\n    char cont = 'E';\n\n    do {\n\n        temp1 = getTemp ();\n\n        scale1 = scaleOne ();\n\n        X1 = toScale ();\n\n        System.out.print (\"Your final temp is: \" + convert () + ' ' + X1);\n\n    } while (cont == 'N');\n\n}\n"}
{"idx": 6601, "func": "public void actionPerformed (ActionEvent e) {\n\n    tick ();\n\n    int delta = 20;\n\n    int X1 = SPRITE_WIDTH + 2 * delta;\n\n    int height = X1;\n\n    if (moved) {\n\n        int x = oldMX - delta;\n\n        int y = oldMY - delta;\n\n        repaint (x, y, X1, height);\n\n    }\n\n    int x = mX - delta;\n\n    int y = mY - delta;\n\n    repaint (x, y, X1, height);\n\n    moved = false;\n\n}\n"}
{"idx": 6602, "func": "public void actionPerformed (ActionEvent e) {\n\n    switch (direction) {\n\n        case UP :\n\n            X1.incrementY (false);\n\n            break;\n\n        case DOWN :\n\n            X1.incrementY (true);\n\n            break;\n\n        case LEFT :\n\n            X1.incrementX (false);\n\n            break;\n\n        case RIGHT :\n\n            X1.incrementX (true);\n\n            break;\n\n        default :\n\n            break;\n\n    }\n\n}\n"}
{"idx": 66101, "func": "public void run () {\n\n    int i = 1;\n\n    while (true) {\n\n        System.out.println (i);\n\n        try {\n\n            Thread.sleep (1000);\n\n            cb.await ();\n\n        } catch (InterruptedException X1) {\n\n            X1.printStackTrace ();\n\n        } catch (BrokenBarrierException X1) {\n\n            X1.printStackTrace ();\n\n        }\n\n        i = i + 3;\n\n    }\n\n}\n"}
{"idx": 66102, "func": "public void run () {\n\n    System.out.println (i);\n\n    try {\n\n        cb.await ();\n\n        i = i + 3;\n\n        Thread.sleep (1000);\n\n    } catch (InterruptedException X1) {\n\n        X1.printStackTrace ();\n\n    } catch (BrokenBarrierException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 66201, "func": "public void run () {\n\n    int i = 1;\n\n    while (true) {\n\n        System.out.println (i);\n\n        try {\n\n            Thread.sleep (1000);\n\n            cb.await ();\n\n        } catch (InterruptedException e) {\n\n            e.X1 ();\n\n        } catch (BrokenBarrierException e) {\n\n            e.X1 ();\n\n        }\n\n        i = i + 3;\n\n    }\n\n}\n"}
{"idx": 66202, "func": "public void run () {\n\n    int i = 1;\n\n    while (i < 50) {\n\n        while (s.getState () != 3) {\n\n            synchronized (s) {\n\n                try {\n\n                    s.wait ();\n\n                } catch (InterruptedException X1) {\n\n                    X1.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (s) {\n\n            if (s.getState () == 3) System.out.println (\"t1 \" + i);\n\n            s.setState (1);\n\n            i = i + 3;\n\n            s.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 66301, "func": "public void run () {\n\n    int X1 = 1;\n\n    while (true) {\n\n        System.out.println (X1);\n\n        try {\n\n            Thread.sleep (1000);\n\n            cb.await ();\n\n        } catch (InterruptedException e) {\n\n            e.printStackTrace ();\n\n        } catch (BrokenBarrierException e) {\n\n            e.printStackTrace ();\n\n        }\n\n        X1 = X1 + 3;\n\n    }\n\n}\n"}
{"idx": 66302, "func": "public synchronized void run () {\n\n    int i = 2;\n\n    while (i < 50) {\n\n        while (X1.getState () != 1) {\n\n            synchronized (X1) {\n\n                try {\n\n                    X1.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (X1) {\n\n            if (X1.getState () == 1) System.out.println (\"t2 \" + i);\n\n            X1.setState (2);\n\n            i = i + 3;\n\n            X1.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 66401, "func": "public void run () {\n\n    int i = 1;\n\n    while (true) {\n\n        System.out.println (i);\n\n        try {\n\n            Thread.sleep (1000);\n\n            cb.await ();\n\n        } catch (InterruptedException e) {\n\n            e.X1 ();\n\n        } catch (BrokenBarrierException e) {\n\n            e.X1 ();\n\n        }\n\n        i = i + 3;\n\n    }\n\n}\n"}
{"idx": 66402, "func": "public synchronized void run () {\n\n    int i = 3;\n\n    while (i < 50) {\n\n        while (s.getState () != 2) {\n\n            synchronized (s) {\n\n                try {\n\n                    s.wait ();\n\n                } catch (InterruptedException X1) {\n\n                    X1.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (s) {\n\n            if (s.getState () == 2) System.out.println (\"t3 \" + i);\n\n            i = i + 3;\n\n            s.setState (3);\n\n            s.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 66501, "func": "public void run () {\n\n    int i = 1;\n\n    while (true) {\n\n        System.out.println (i);\n\n        try {\n\n            Thread.sleep (1000);\n\n            cb.await ();\n\n        } catch (InterruptedException e) {\n\n            e.X1 ();\n\n        } catch (BrokenBarrierException e) {\n\n            e.X1 ();\n\n        }\n\n        i = i + 3;\n\n    }\n\n}\n"}
{"idx": 66502, "func": "public void run () {\n\n    try {\n\n        for (int X1 = 0;\n\n        X1 < 2; X1 ++) {\n\n            System.out.println (\"tic\");\n\n        }\n\n    } catch (Exception e) {\n\n        e.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 66601, "func": "public void run () {\n\n    int i = 1;\n\n    while (true) {\n\n        System.out.println (i);\n\n        try {\n\n            Thread.sleep (1000);\n\n            cb.await ();\n\n        } catch (InterruptedException e) {\n\n            e.X1 ();\n\n        } catch (BrokenBarrierException e) {\n\n            e.X1 ();\n\n        }\n\n        i = i + 3;\n\n    }\n\n}\n"}
{"idx": 66602, "func": "public void run () {\n\n    try {\n\n        for (int i = 0;\n\n        i < 2; i ++) {\n\n            System.out.println (\"tac\");\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 66701, "func": "public void run () {\n\n    int i = 1;\n\n    while (true) {\n\n        System.out.println (i);\n\n        try {\n\n            Thread.sleep (1000);\n\n            cb.await ();\n\n        } catch (InterruptedException e) {\n\n            e.X1 ();\n\n        } catch (BrokenBarrierException e) {\n\n            e.X1 ();\n\n        }\n\n        i = i + 3;\n\n    }\n\n}\n"}
{"idx": 66702, "func": "public void run () {\n\n    try {\n\n        for (int i = 0;\n\n        i < 2; i ++) {\n\n            System.out.println (\"toe\");\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 66801, "func": "public void run () {\n\n    System.out.println (X1);\n\n    try {\n\n        cb.await ();\n\n        X1 = X1 + 3;\n\n        Thread.sleep (1000);\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    } catch (BrokenBarrierException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 66802, "func": "public void run () {\n\n    int X1 = 1;\n\n    while (X1 < 50) {\n\n        while (s.getState () != 3) {\n\n            synchronized (s) {\n\n                try {\n\n                    s.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (s) {\n\n            if (s.getState () == 3) System.out.println (\"t1 \" + X1);\n\n            s.setState (1);\n\n            X1 = X1 + 3;\n\n            s.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 66901, "func": "public void run () {\n\n    System.out.println (X1);\n\n    try {\n\n        cb.await ();\n\n        X1 = X1 + 3;\n\n        Thread.sleep (1000);\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    } catch (BrokenBarrierException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 66902, "func": "public synchronized void run () {\n\n    int i = 2;\n\n    while (i < 50) {\n\n        while (X1.getState () != 1) {\n\n            synchronized (X1) {\n\n                try {\n\n                    X1.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (X1) {\n\n            if (X1.getState () == 1) System.out.println (\"t2 \" + i);\n\n            X1.setState (2);\n\n            i = i + 3;\n\n            X1.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 67001, "func": "public void run () {\n\n    System.out.println (i);\n\n    try {\n\n        cb.await ();\n\n        i = i + 3;\n\n        Thread.sleep (1000);\n\n    } catch (InterruptedException X1) {\n\n        X1.printStackTrace ();\n\n    } catch (BrokenBarrierException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67002, "func": "public synchronized void run () {\n\n    int X1 = 3;\n\n    while (X1 < 50) {\n\n        while (s.getState () != 2) {\n\n            synchronized (s) {\n\n                try {\n\n                    s.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (s) {\n\n            if (s.getState () == 2) System.out.println (\"t3 \" + X1);\n\n            X1 = X1 + 3;\n\n            s.setState (3);\n\n            s.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 6701, "func": "public static void main (String [] args) {\n\n    String name1;\n\n    String name2;\n\n    String X1;\n\n    Scanner keyboard = new Scanner (System.in);\n\n    System.out.print (\"Please Enter First Name \");\n\n    name1 = keyboard.nextLine ();\n\n    System.out.print (\"Please Enter Second Name \");\n\n    name2 = keyboard.nextLine ();\n\n    System.out.print (\"Please Enter Third Name \");\n\n    X1 = keyboard.nextLine ();\n\n    if ((name1.compareTo (name2) < 0) && (name1.compareTo (X1) < 0)) {\n\n        System.out.println (name1);\n\n        if (name2.compareTo (X1) < 0) {\n\n            System.out.println (name2);\n\n            System.out.println (X1);\n\n        } else {\n\n            System.out.println (X1);\n\n            System.out.println (name2);\n\n        }\n\n    } else if ((name1.compareTo (name2) > 0) && (name2.compareTo (X1) < 0)) {\n\n        System.out.println (name2);\n\n        if (name1.compareTo (X1) < 0) {\n\n            System.out.println (name1);\n\n            System.out.println (X1);\n\n        } else {\n\n            System.out.println (X1);\n\n            System.out.println (name1);\n\n        }\n\n    } else {\n\n        System.out.println (X1);\n\n        if (name1.compareTo (name2) < 0) {\n\n            System.out.println (name1);\n\n            System.out.println (name2);\n\n        } else {\n\n            System.out.println (name2);\n\n            System.out.println (name1);\n\n        }\n\n    }\n\n}\n"}
{"idx": 6702, "func": "public static void main (final String [] args) {\n\n    final Console console = System.console ();\n\n    if (console != null) {\n\n        final X1 sortNames = new X1 (console);\n\n        sortNames.run ();\n\n    } else {\n\n        System.err.println (\"Sorry, no console.\");\n\n        System.exit (1);\n\n    }\n\n}\n"}
{"idx": 67101, "func": "public void run () {\n\n    System.out.println (i);\n\n    try {\n\n        cb.await ();\n\n        i = i + 3;\n\n        Thread.sleep (1000);\n\n    } catch (InterruptedException X1) {\n\n        X1.printStackTrace ();\n\n    } catch (BrokenBarrierException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67102, "func": "public void run () {\n\n    try {\n\n        for (int i = 0;\n\n        i < 2; i ++) {\n\n            System.out.println (\"tic\");\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67201, "func": "public void run () {\n\n    System.out.println (i);\n\n    try {\n\n        cb.await ();\n\n        i = i + 3;\n\n        Thread.sleep (1000);\n\n    } catch (InterruptedException X1) {\n\n        X1.printStackTrace ();\n\n    } catch (BrokenBarrierException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67202, "func": "public void run () {\n\n    try {\n\n        for (int X1 = 0;\n\n        X1 < 2; X1 ++) {\n\n            System.out.println (\"tac\");\n\n        }\n\n    } catch (Exception e) {\n\n        e.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67301, "func": "public void run () {\n\n    System.out.println (X1);\n\n    try {\n\n        cb.await ();\n\n        X1 = X1 + 3;\n\n        Thread.sleep (1000);\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    } catch (BrokenBarrierException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67302, "func": "public void run () {\n\n    try {\n\n        for (int X1 = 0;\n\n        X1 < 2; X1 ++) {\n\n            System.out.println (\"toe\");\n\n        }\n\n    } catch (Exception e) {\n\n        e.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67401, "func": "public static void main (String args []) {\n\n    Runnable threePrinter = new Runnable () {\n\n        int i = 3;\n\n        public void run () {\n\n            System.out.println (i);\n\n            i = i + 3;\n\n        }}\n\n    ;\n\n    CyclicBarrier bar2 = new CyclicBarrier (1, threePrinter);\n\n    X1 twoPrinter = new X1 (bar2);\n\n    CyclicBarrier bar1 = new CyclicBarrier (1, twoPrinter);\n\n    Thread onePrinter = new Thread (new one (bar1));\n\n    onePrinter.start ();\n\n}\n"}
{"idx": 67402, "func": "public static void main (String [] args) {\n\n    State X1 = new State ();\n\n    Thread t1 = new Thread (new T1 (X1));\n\n    Thread t2 = new Thread (new T2 (X1));\n\n    Thread t3 = new Thread (new T3 (X1));\n\n    t1.start ();\n\n    t2.start ();\n\n    t3.start ();\n\n}\n"}
{"idx": 67501, "func": "public static void main (String args []) {\n\n    Runnable X1 = new Runnable () {\n\n        int i = 3;\n\n        public void run () {\n\n            System.out.println (i);\n\n            i = i + 3;\n\n        }}\n\n    ;\n\n    CyclicBarrier bar2 = new CyclicBarrier (1, X1);\n\n    two twoPrinter = new two (bar2);\n\n    CyclicBarrier bar1 = new CyclicBarrier (1, twoPrinter);\n\n    Thread onePrinter = new Thread (new one (bar1));\n\n    onePrinter.start ();\n\n}\n"}
{"idx": 67502, "func": "public static void main (String [] args) {\n\n    try {\n\n        Tic tic = new Tic ();\n\n        Tac tac = new Tac ();\n\n        Toe toe = new Toe ();\n\n        Thread t1 = new Thread (tic);\n\n        Thread t2 = new Thread (tac);\n\n        Thread t3 = new Thread (toe);\n\n        t1.start ();\n\n        t1.X1 ();\n\n        if (! t1.isAlive ()) {\n\n            t2.start ();\n\n        }\n\n        t2.X1 ();\n\n        if (! t2.isAlive ()) {\n\n            t3.start ();\n\n        }\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67601, "func": "public void run () {\n\n    int i = 1;\n\n    while (i < 50) {\n\n        while (X1.getState () != 3) {\n\n            synchronized (X1) {\n\n                try {\n\n                    X1.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (X1) {\n\n            if (X1.getState () == 3) System.out.println (\"t1 \" + i);\n\n            X1.setState (1);\n\n            i = i + 3;\n\n            X1.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 67602, "func": "public void run () {\n\n    try {\n\n        for (int X1 = 0;\n\n        X1 < 2; X1 ++) {\n\n            System.out.println (\"tic\");\n\n        }\n\n    } catch (Exception e) {\n\n        e.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67701, "func": "public void run () {\n\n    int i = 1;\n\n    while (i < 50) {\n\n        while (s.X1 () != 3) {\n\n            synchronized (s) {\n\n                try {\n\n                    s.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (s) {\n\n            if (s.X1 () == 3) System.out.println (\"t1 \" + i);\n\n            s.setState (1);\n\n            i = i + 3;\n\n            s.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 67702, "func": "public void run () {\n\n    try {\n\n        for (int X1 = 0;\n\n        X1 < 2; X1 ++) {\n\n            System.out.println (\"tac\");\n\n        }\n\n    } catch (Exception e) {\n\n        e.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67801, "func": "public void run () {\n\n    int i = 1;\n\n    while (i < 50) {\n\n        while (s.getState () != 3) {\n\n            synchronized (s) {\n\n                try {\n\n                    s.wait ();\n\n                } catch (InterruptedException X1) {\n\n                    X1.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (s) {\n\n            if (s.getState () == 3) System.out.println (\"t1 \" + i);\n\n            s.setState (1);\n\n            i = i + 3;\n\n            s.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 67802, "func": "public void run () {\n\n    try {\n\n        for (int i = 0;\n\n        i < 2; i ++) {\n\n            System.out.println (\"toe\");\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 67901, "func": "public synchronized void run () {\n\n    int i = 2;\n\n    while (i < 50) {\n\n        while (X1.getState () != 1) {\n\n            synchronized (X1) {\n\n                try {\n\n                    X1.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (X1) {\n\n            if (X1.getState () == 1) System.out.println (\"t2 \" + i);\n\n            X1.setState (2);\n\n            i = i + 3;\n\n            X1.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 67902, "func": "public void run () {\n\n    try {\n\n        for (int i = 0;\n\n        i < 2; i ++) {\n\n            System.out.println (\"tic\");\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 68001, "func": "public synchronized void run () {\n\n    int i = 2;\n\n    while (i < 50) {\n\n        while (s.X1 () != 1) {\n\n            synchronized (s) {\n\n                try {\n\n                    s.wait ();\n\n                } catch (InterruptedException e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        synchronized (s) {\n\n            if (s.X1 () == 1) System.out.println (\"t2 \" + i);\n\n            s.setState (2);\n\n            i = i + 3;\n\n            s.notifyAll ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 68002, "func": "public void run () {\n\n    try {\n\n        for (int i = 0;\n\n        i < 2; i ++) {\n\n            System.out.println (\"tac\");\n\n        }\n\n    } catch (Exception X1) {\n\n        X1.getStackTrace ();\n\n    }\n\n}\n"}
{"idx": 6801, "func": "public static void main (String [] args) {\n\n    Node node1 = new Node ();\n\n    node1.length = 1;\n\n    Node X1 = new Node ();\n\n    X1.length = 2;\n\n    Node node3 = new Node ();\n\n    node3.length = 3;\n\n    Node node4 = new Node ();\n\n    node4.children.add (node1);\n\n    node4.children.add (X1);\n\n    Node node5 = new Node ();\n\n    node5.children.add (node3);\n\n    Node node6 = new Node ();\n\n    node6.children.add (node4);\n\n    node6.children.add (node5);\n\n    Object array = createArray (String.class, node6);\n\n    outputArray (array);\n\n    System.out.println ();\n\n}\n"}
{"idx": 6802, "func": "public static void main (X1 [] args) {\n\n    Random r = new Random ();\n\n    int dims = 1 + r.nextInt (3);\n\n    int [] sizes = new int [dims];\n\n    for (int i = 0;\n\n    i < sizes.length; i ++) sizes [i] = 1 + r.nextInt (3);\n\n    System.out.println (\"Creating array with dimensions / sizes: \" + Arrays.toString (sizes).replaceAll (\", \", \"][\"));\n\n    Object multiDimArray = Array.newInstance (X1.class, sizes);\n\n    fillWithSomeValues (multiDimArray, \"pos \", sizes);\n\n    System.out.println (Arrays.deepToString ((Object []) multiDimArray));\n\n}\n"}
{"idx": 68101, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame ();\n\n    frame.setTitle (\"Stackoverflow\");\n\n    JButton X1 = new JButton (\"Change Size\");\n\n    X1.setVisible (true);\n\n    frame.getContentPane ().add (X1, BorderLayout.SOUTH);\n\n    frame.setSize (200, 200);\n\n    frame.setVisible (true);\n\n    X1.addActionListener (new ActionListener () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            frame.setSize (frame.getWidth (), frame.getHeight () + 50);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 68102, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame ();\n\n    frame.setTitle (\"Stackoverflow\");\n\n    JButton X1 = new JButton (\"Change Size\");\n\n    X1.setVisible (true);\n\n    frame.getContentPane ().add (X1, BorderLayout.SOUTH);\n\n    frame.setSize (200, 200);\n\n    frame.setVisible (true);\n\n    X1.addActionListener (new ActionListener () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            frame.setSize (frame.getWidth (), frame.getHeight () + 50);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 68201, "func": "public static void main (String args []) {\n\n    String result = new String (removeDupes (new char [] {'a', 'b', 'c', 'd', 'a'}));\n\n    assert \"abcd\".equals (result) : \"abcda should return abcd but it returns: \" + result;\n\n    result = new String (removeDupes (new char [] {'a', 'a', 'a', 'a'}));\n\n    assert \"a\".equals (result) : \"aaaa should return a but it returns: \" + result;\n\n    result = new String (removeDupes (new char [] {'a', 'b', 'c', 'a'}));\n\n    assert \"abc\".equals (result) : \"abca should return abc but it returns: \" + result;\n\n    result = new String (removeDupes (new char [] {'a', 'a', 'b', 'b'}));\n\n    assert \"ab\".equals (result) : \"aabb should return ab but it returns: \" + result;\n\n    result = new String (removeDupes (new char [] {'a'}));\n\n    assert \"a\".equals (result) : \"a should return a but it returns: \" + result;\n\n    result = new String (removeDupes (new char [] {'a', 'b', 'b', 'a'}));\n\n    assert \"ab\".equals (result) : \"abba should return ab but it returns: \" + result;\n\n    char [] arr = bigArr (5000000);\n\n    long startTime = System.nanoTime ();\n\n    System.out.X1 (\"2: \" + new String (removeDupes (arr)));\n\n    long endTime = System.nanoTime ();\n\n    long duration = (endTime - startTime);\n\n    System.out.X1 (\"Program took: \" + duration + \" nanoseconds\");\n\n    System.out.X1 (\"Program took: \" + duration / 1000000000 + \" seconds\");\n\n}\n"}
{"idx": 68202, "func": "public static void main (String [] args) {\n\n    String s = \"harikrishna\";\n\n    String s2 = \"\";\n\n    for (int i = 0;\n\n    i < s.X1 (); i ++) {\n\n        Boolean found = false;\n\n        for (int j = 0;\n\n        j < s2.X1 (); j ++) {\n\n            if (s.charAt (i) == s2.charAt (j)) {\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (found == false) {\n\n            s2 = s2.concat (String.valueOf (s.charAt (i)));\n\n        }\n\n    }\n\n    System.out.println (s2);\n\n}\n"}
{"idx": 68301, "func": "public void X1 (Reader reader) throws IOException, SQLException {\n\n    try {\n\n        boolean originalAutoCommit = connection.getAutoCommit ();\n\n        try {\n\n            if (originalAutoCommit != this.autoCommit) {\n\n                connection.setAutoCommit (this.autoCommit);\n\n            }\n\n            X1 (connection, reader);\n\n        } finally {\n\n            connection.setAutoCommit (originalAutoCommit);\n\n        }\n\n    } catch (IOException e) {\n\n        throw e;\n\n    } catch (SQLException e) {\n\n        throw e;\n\n    } catch (Exception e) {\n\n        throw new RuntimeException (\"Error running script.  Cause: \" + e, e);\n\n    }\n\n}\n"}
{"idx": 68302, "func": "private void runScript (Connection conn, Reader reader) throws IOException, SQLException {\n\n    StringBuffer command = null;\n\n    try {\n\n        LineNumberReader lineReader = new LineNumberReader (reader);\n\n        String line = null;\n\n        while ((line = lineReader.readLine ()) != null) {\n\n            if (command == null) {\n\n                command = new StringBuffer ();\n\n            }\n\n            String trimmedLine = line.trim ();\n\n            if (trimmedLine.startsWith (\"--\")) {\n\n                println (trimmedLine);\n\n            } else if (trimmedLine.length () < 1 || trimmedLine.startsWith (\"//\")) {\n\n            } else if (trimmedLine.length () < 1 || trimmedLine.startsWith (\"--\")) {\n\n            } else if (! fullLineDelimiter && trimmedLine.endsWith (getDelimiter ()) || fullLineDelimiter && trimmedLine.equals (getDelimiter ())) {\n\n                command.append (line.substring (0, line.lastIndexOf (getDelimiter ())));\n\n                command.append (\" \");\n\n                Statement statement = conn.createStatement ();\n\n                println (command);\n\n                boolean hasResults = false;\n\n                if (stopOnError) {\n\n                    hasResults = statement.execute (command.toString ());\n\n                } else {\n\n                    try {\n\n                        statement.execute (command.toString ());\n\n                    } catch (SQLException e) {\n\n                        e.fillInStackTrace ();\n\n                        printlnError (\"Error executing: \" + command);\n\n                        printlnError (e);\n\n                    }\n\n                }\n\n                if (autoCommit && ! conn.getAutoCommit ()) {\n\n                    conn.commit ();\n\n                }\n\n                ResultSet rs = statement.getResultSet ();\n\n                if (hasResults && rs != null) {\n\n                    ResultSetMetaData md = rs.getMetaData ();\n\n                    int cols = md.getColumnCount ();\n\n                    for (int X1 = 0;\n\n                    X1 < cols; X1 ++) {\n\n                        String name = md.getColumnLabel (X1);\n\n                        print (name + \"\\t\");\n\n                    }\n\n                    println (\"\");\n\n                    while (rs.next ()) {\n\n                        for (int X1 = 0;\n\n                        X1 < cols; X1 ++) {\n\n                            String value = rs.getString (X1);\n\n                            print (value + \"\\t\");\n\n                        }\n\n                        println (\"\");\n\n                    }\n\n                }\n\n                command = null;\n\n                try {\n\n                    statement.close ();\n\n                } catch (Exception e) {\n\n                }\n\n                Thread.yield ();\n\n            } else {\n\n                command.append (line);\n\n                command.append (\" \");\n\n            }\n\n        }\n\n        if (! autoCommit) {\n\n            conn.commit ();\n\n        }\n\n    } catch (SQLException e) {\n\n        e.fillInStackTrace ();\n\n        printlnError (\"Error executing: \" + command);\n\n        printlnError (e);\n\n        throw e;\n\n    } catch (IOException e) {\n\n        e.fillInStackTrace ();\n\n        printlnError (\"Error executing: \" + command);\n\n        printlnError (e);\n\n        throw e;\n\n    } finally {\n\n        conn.rollback ();\n\n        flush ();\n\n    }\n\n}\n"}
{"idx": 68401, "func": "public static int [] MaxNumber (String [] X1) {\n\n    int [] Number_arr = new int [11];\n\n    int count = 1;\n\n    int j = 0;\n\n    int k = 0;\n\n    for (int i = 0;\n\n    i < X1.length - 1; i ++) {\n\n        if (X1 [i].equals (X1 [i + 1])) count ++;\n\n        else {\n\n            Number_arr [j] = count;\n\n            j ++;\n\n            count = 1;\n\n        }\n\n    }\n\n    Number_arr [j] = count;\n\n    for (int i = 0;\n\n    i < Number_arr.length; i ++) {\n\n        System.out.print (Number_arr [i] + \"  \");\n\n    }\n\n    return Number_arr;\n\n}\n"}
{"idx": 68402, "func": "public static int [] MaxNumber (String [] arr) {\n\n    int [] Number_arr = new int [11];\n\n    int X1 = 1;\n\n    int j = 0;\n\n    int k = 0;\n\n    for (int i = 0;\n\n    i < arr.length - 1; i ++) {\n\n        if (arr [i].equals (arr [i + 1])) X1 ++;\n\n        else {\n\n            Number_arr [j] = X1;\n\n            j ++;\n\n            X1 = 1;\n\n        }\n\n    }\n\n    Number_arr [j] = X1;\n\n    return Number_arr;\n\n}\n"}
{"idx": 68501, "func": "public static void main (String [] args) {\n\n    javax.swing.SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            try {\n\n                for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels ()) {\n\n                    if (\"Nimbus\".equals (info.getName ())) {\n\n                        UIManager.setLookAndFeel (info.getClassName ());\n\n                        break;\n\n                    }\n\n                }\n\n            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException X1) {\n\n                X1.printStackTrace ();\n\n            }\n\n            Test test = new Test ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 68502, "func": "public static void main (String [] args) {\n\n    javax.swing.SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            try {\n\n                for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels ()) {\n\n                    if (\"Nimbus\".equals (info.getName ())) {\n\n                        UIManager.setLookAndFeel (info.getClassName ());\n\n                        break;\n\n                    }\n\n                }\n\n            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException X1) {\n\n                X1.printStackTrace ();\n\n            }\n\n            Test test = new Test ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 68601, "func": "public void mouseDragged (MouseEvent X1) {\n\n    super.mouseDragged (X1);\n\n    if (X1.getX () < startX) {\n\n        x -= 2;\n\n    } else if (X1.getX () > startX) {\n\n        x += 2;\n\n    }\n\n    if (X1.getY () < startY) {\n\n        y -= 2;\n\n    } else if (X1.getY () > startY) {\n\n        y += 2;\n\n    }\n\n    repaint ();\n\n}\n"}
{"idx": 68602, "func": "public void mouseDragged (MouseEvent e) {\n\n    JViewport vport = (JViewport) e.getSource ();\n\n    JComponent label = (JComponent) vport.getView ();\n\n    Point cp = e.getPoint ();\n\n    Point vp = vport.getViewPosition ();\n\n    vp.translate (pp.X1 - cp.X1, pp.y - cp.y);\n\n    label.scrollRectToVisible (new Rectangle (vp, vport.getSize ()));\n\n    pp.setLocation (cp);\n\n}\n"}
{"idx": 68701, "func": "synchronized public void print () throws InterruptedException {\n\n    while (X1 < 15) {\n\n        for (int i = 0;\n\n        i < 5; i ++) {\n\n            X1 ++;\n\n            System.out.println (X1 + \" -- \" + Thread.currentThread ());\n\n        }\n\n        notifyAll ();\n\n        wait ();\n\n    }\n\n}\n"}
{"idx": 68702, "func": "public void print () {\n\n    try {\n\n        waitForSemaphore.acquire ();\n\n        int start = nextStartIdx;\n\n        for (int i = 0;\n\n        i < 5; i ++) {\n\n            System.out.println (String.format (\"%d -- %s\", i + start, Thread.X1 ().getName ()));\n\n        }\n\n        nextStartIdx += 5;\n\n        next.release ();\n\n    } catch (InterruptedException ie) {\n\n        Thread.X1 ().interrupt ();\n\n    }\n\n}\n"}
{"idx": 68801, "func": "public static int [] genRandoms (int n, int numberOfRandoms, int min) {\n\n    int randomArray [] = new int [numberOfRandoms];\n\n    for (int X1 = 0;\n\n    X1 < numberOfRandoms; X1 ++) {\n\n        randomArray [X1] = min;\n\n    }\n\n    for (int X1 = min * numberOfRandoms;\n\n    X1 < n; X1 ++) {\n\n        randomArray [randomRange (numberOfRandoms)] += 1;\n\n    }\n\n    return randomArray;\n\n}\n"}
{"idx": 68802, "func": "public static int [] genRandoms (int total, int numberOfRandoms, int minimumValue) {\n\n    int [] ret = new int [numberOfRandoms];\n\n    Random rnd = new Random ();\n\n    int totalLeft = total;\n\n    for (int i = 0;\n\n    i < numberOfRandoms; i ++) {\n\n        final int rollsLeft = numberOfRandoms - i;\n\n        int thisMax = totalLeft - (rollsLeft - 1) * minimumValue;\n\n        int thisMin = Math.max (minimumValue, totalLeft / rollsLeft);\n\n        int X1 = thisMax - thisMin;\n\n        if (X1 < 0) throw new IllegalArgumentException (\"Cannot have \" + minimumValue + \" * \" + numberOfRandoms + \" < \" + total);\n\n        int rndValue = X1;\n\n        for (int j = 0;\n\n        j * j < rollsLeft; j ++) rndValue = rnd.nextInt (rndValue + 1);\n\n        totalLeft -= ret [i] = rndValue + thisMin;\n\n    }\n\n    Collections.shuffle (Arrays.asList (ret), rnd);\n\n    return ret;\n\n}\n"}
{"idx": 68901, "func": "public int [] randNums (int total, int X1, int numRands) {\n\n    if (X1 * numRands > total) {\n\n        throw new IllegalArgumentException ();\n\n    }\n\n    int [] results = randNums (total - X1 * numRands, numRands);\n\n    for (int i = 0;\n\n    i < numRands; ++ i) {\n\n        results [i] += X1;\n\n    }\n\n    return results;\n\n}\n"}
{"idx": 68902, "func": "private int [] randNums (int total, int n) {\n\n    final int [] results = new int [n];\n\n    if (total == 0) {\n\n        Arrays.fill (results, 0);\n\n        return results;\n\n    }\n\n    final BigInteger [] rs = new BigInteger [n];\n\n    final BigInteger totalPlus1 = BigInteger.valueOf (total + 1L);\n\n    while (true) {\n\n        for (int i = 0;\n\n        i < n; ++ i) {\n\n            rs [i] = new BigInteger (256, rand);\n\n        }\n\n        BigInteger sum = BigInteger.ZERO;\n\n        for (BigInteger X1 : rs) {\n\n            sum = sum.add (X1);\n\n        }\n\n        if (sum.compareTo (BigInteger.ZERO) == 0) {\n\n            continue;\n\n        }\n\n        for (int i = 0;\n\n        i < n; ++ i) {\n\n            results [i] = sum.mod (rs [i]).mod (totalPlus1).intValue ();\n\n        }\n\n        return results;\n\n    }\n\n}\n"}
{"idx": 69001, "func": "public static Date addBusinessDays (Date day, int days, int weekendPattern) {\n\n    Calendar ret = Calendar.getInstance ();\n\n    if (day != null) {\n\n        ret.setTime (day);\n\n    }\n\n    if (days != 0) {\n\n        int startDayofWeek = ret.get (Calendar.DAY_OF_WEEK) - 1;\n\n        int X1 = days > 0 ? 0 : 3;\n\n        int howManyWeekendDays = 0;\n\n        int [] [] adjV = adjVector [weekendPattern];\n\n        int numWeekendDaysInOneWeek = adjV [X1 + 1].length;\n\n        for (int i = 0;\n\n        i < numWeekendDaysInOneWeek; i ++) {\n\n            int adjustmentA = adjV [X1] [startDayofWeek];\n\n            int adjustmentB = adjV [X1 + 1] [i];\n\n            howManyWeekendDays += (days - adjustmentA - adjustmentB) / (7 - numWeekendDaysInOneWeek);\n\n        }\n\n        int adjustmentC = adjV [X1 + 2] [startDayofWeek];\n\n        howManyWeekendDays += adjustmentC;\n\n        ret.add (Calendar.DATE, days + howManyWeekendDays);\n\n    }\n\n    return ret.getTime ();\n\n}\n"}
{"idx": 69002, "func": "public static Date addBusinessDays (Date date, int days) {\n\n    DateTime X1 = new DateTime (date);\n\n    X1 = isWeekEnd (X1) ? getPreviousBusinessDate (X1) : X1;\n\n    for (int i = 0;\n\n    i < days; i ++) {\n\n        if (isWeekEnd (X1)) {\n\n            i --;\n\n        }\n\n        X1 = X1.plusDays (1);\n\n    }\n\n    return X1.toDate ();\n\n}\n"}
{"idx": 6901, "func": "public static void main (String [] args) {\n\n    String X1 = \" INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,'bb),(b',ccc),(aaa,bbb,ccc); \";\n\n    System.out.printf (\"%s\\n\", X1);\n\n    X1 = X1.split (\"(?i)\\\\s+values\\\\s*\\\\(|\\\\);\") [1];\n\n    System.out.printf (\"values list: %s\\n\", X1);\n\n    Matcher m = Pattern.compile (\"('\\\\w*)(\\\\)\\\\,\\\\()+(\\\\w*')\").matcher (X1);\n\n    while (m.find ()) {\n\n        X1 = X1.substring (0, m.start (2)) + \"###\" + X1.substring (m.end (2), X1.length ());\n\n        System.out.printf (\"values list with pattern subst inside char literal: %s\\n\", X1);\n\n    }\n\n    String [] multiValues = X1.split (\"\\\\)\\\\,\\\\(\");\n\n    for (int i = 0;\n\n    i < multiValues.length; i ++) {\n\n        multiValues [i] = multiValues [i].replaceAll (\"###\", \"),(\");\n\n    }\n\n    System.out.println (Arrays.toString (multiValues));\n\n}\n"}
{"idx": 6902, "func": "public static void main (X1 [] args) {\n\n    Test t = new Test ();\n\n    X1 [] allQueryStrings = new X1 [] {\"INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz);\", \"INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,bbb,ccc);\", \"INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,'bb(,)b',ccc);\", \"INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,'bb),(b',ccc);\"};\n\n    for (X1 queryString : allQueryStrings) {\n\n        System.out.println (queryString);\n\n        for (X1 values : t.extractValues (queryString)) {\n\n            System.out.println (values);\n\n        }\n\n    }\n\n}\n"}
{"idx": 69101, "func": "public void registerModule (HttpServletRequest req, ModuleType moduleType) {\n\n    LOGGER.debug (\"Register New Module - \" + moduleType.name ());\n\n    try {\n\n        if (req.getParts ().isEmpty () || req.getParameterMap ().isEmpty ()) {\n\n            LOGGER.error (\"The rest request is empty.No info to register\");\n\n            return;\n\n        }\n\n        ModuleEntityGenerator moduleEntityGenerator = new ModuleEntityGenerator ();\n\n        ModuleEntityDao X1 = moduleEntityGenerator.get (req, moduleType);\n\n        if (X1 == null) {\n\n            LOGGER.error (\"The BA object is null. There is nothing to register\");\n\n            return;\n\n        }\n\n        if (processRegistryDal.getModule (moduleType, X1.getId ()) == null) {\n\n            processRegistryDal.addNewModule (X1);\n\n        } else {\n\n            processRegistryDal.updateModule (X1);\n\n        }\n\n    } catch (IOException e) {\n\n        LOGGER.error (\"IO Error\\n\" + e.getMessage ());\n\n    } catch (ServletException e) {\n\n        LOGGER.error (\"Servlet Error\\n\" + e.getMessage ());\n\n    }\n\n}\n"}
{"idx": 69102, "func": "public void registerModule (HttpServletRequest req, ModuleType moduleType) {\n\n    LOGGER.debug (\"Register New Module - \" + moduleType.name ());\n\n    try {\n\n        ModuleEntityDao moduleEntityDao;\n\n        if (req.getParts ().isEmpty () || req.getParameterMap ().isEmpty ()) {\n\n            LOGGER.error (\"The rest request is empty.No info to register\");\n\n        } else if ((moduleEntityDao = new ModuleEntityGenerator ().get (req, moduleType)) == null) {\n\n            LOGGER.error (\"The BA object is null. There is nothing to register\");\n\n        } else if (processRegistryDal.getModule (moduleType, moduleEntityDao.getId ()) == null) {\n\n            processRegistryDal.addNewModule (moduleEntityDao);\n\n        } else {\n\n            processRegistryDal.updateModule (moduleEntityDao);\n\n        }\n\n    } catch (IOException X1) {\n\n        LOGGER.error (\"IO Error\\n\" + X1.getMessage ());\n\n    } catch (ServletException X1) {\n\n        LOGGER.error (\"Servlet Error\\n\" + X1.getMessage ());\n\n    }\n\n}\n"}
{"idx": 69201, "func": "public void start (Stage primaryStage) throws X1 {\n\n    Alert alert = new Alert (Alert.AlertType.CONFIRMATION);\n\n    alert.setTitle (\"Title\");\n\n    alert.setHeaderText (\"Some Text\");\n\n    alert.setContentText (\"Choose your option.\");\n\n    ButtonType buttonTypeOne = new ButtonType (\"Yes\");\n\n    ButtonType buttonTypeCancel = new ButtonType (\"No\", ButtonBar.ButtonData.CANCEL_CLOSE);\n\n    alert.getButtonTypes ().setAll (buttonTypeOne, buttonTypeCancel);\n\n    Thread thread = new Thread (() -> {\n\n        try {\n\n            Thread.sleep (5000);\n\n            if (alert.isShowing ()) {\n\n                Platform.runLater (() -> alert.close ());\n\n            }\n\n        } catch (X1 exp) {\n\n            exp.printStackTrace ();\n\n        }\n\n    });\n\n    thread.setDaemon (true);\n\n    thread.start ();\n\n    Optional < ButtonType > result = alert.showAndWait ();\n\n}\n"}
{"idx": 69202, "func": "@Override\n\npublic void start (final Stage primaryStage) {\n\n    Alert alert = new Alert (Alert.AlertType.CONFIRMATION);\n\n    alert.setTitle (\"Title\");\n\n    alert.setHeaderText (\"Some Text\");\n\n    alert.setContentText (\"Choose your option.\");\n\n    X1 buttonTypeOne = new X1 (\"Yes\");\n\n    alert.initModality (Modality.NONE);\n\n    X1 buttonTypeCancel = new X1 (\"No\", ButtonBar.ButtonData.CANCEL_CLOSE);\n\n    alert.getButtonTypes ().setAll (buttonTypeOne, buttonTypeCancel);\n\n    Button b = new Button (\"close alert\");\n\n    b.setOnAction ((ActionEvent event) -> {\n\n        for (X1 bt : alert.getDialogPane ().getButtonTypes ()) {\n\n            System.out.println (\"bt = \" + bt);\n\n            if (bt.getButtonData () == ButtonBar.ButtonData.CANCEL_CLOSE) {\n\n                Button cancelButton = (Button) alert.getDialogPane ().lookupButton (bt);\n\n                cancelButton.fire ();\n\n                break;\n\n            }\n\n        }\n\n    });\n\n    final Scene scene = new Scene (new Group (b), 400, 300);\n\n    primaryStage.setScene (scene);\n\n    primaryStage.show ();\n\n    Optional < X1 > result = alert.showAndWait ();\n\n    if (result.get () == buttonTypeOne) {\n\n        System.out.println (\"one \");\n\n    } else if (result.get () == buttonTypeCancel) {\n\n        System.out.println (\"cancel \");\n\n    }\n\n}\n"}
{"idx": 69301, "func": "@RequestMapping (value = \"/matches/{matchId}\", produces = \"application/json\")\n\n@ResponseBody\n\npublic X1 match (@PathVariable\n\nX1 matchId,@RequestBody\n\nX1 body, HttpServletRequest request, HttpServletResponse response) {\n\n    X1 json = matchService.getMatchJson (matchId);\n\n    if (json == null) {\n\n        response.setStatus (HttpServletResponse.SC_BAD_REQUEST);\n\n    }\n\n    return json;\n\n}\n"}
{"idx": 69302, "func": "@RequestMapping (value = \"/matches/{matchId}\", produces = \"application/json\")\n\n@ResponseBody\n\npublic ResponseEntity < ? > match (@PathVariable\n\nX1 matchId,@RequestBody\n\nX1 body, HttpServletRequest request, HttpServletResponse response) {\n\n    Product p;\n\n    try {\n\n        p = service.getProduct (request.getProductId ());\n\n    } catch (Exception ex) {\n\n        return new ResponseEntity < X1 > (HttpStatus.BAD_REQUEST);\n\n    }\n\n    return new ResponseEntity (p, HttpStatus.OK);\n\n}\n"}
{"idx": 69401, "func": "@RequestMapping (value = \"/matches/{matchId}\", produces = \"application/json\")\n\n@ResponseBody\n\npublic String match (@PathVariable\n\nString X1) {\n\n    String json = matchService.getMatchJson (X1);\n\n    if (json == null) {\n\n        throw new NotFoundException ();\n\n    }\n\n    return json;\n\n}\n"}
{"idx": 69402, "func": "@RequestMapping (value = \"/matches/{matchId}\", produces = \"application/json\")\n\n@ResponseBody\n\npublic ResponseEntity < ? > match (@PathVariable\n\nX1 matchId,@RequestBody\n\nX1 body, HttpServletRequest request, HttpServletResponse response) {\n\n    Product p;\n\n    try {\n\n        p = service.getProduct (request.getProductId ());\n\n    } catch (Exception ex) {\n\n        return new ResponseEntity < X1 > (HttpStatus.BAD_REQUEST);\n\n    }\n\n    return new ResponseEntity (p, HttpStatus.OK);\n\n}\n"}
{"idx": 69501, "func": "private static void sort (int [] arr) {\n\n    int index = 0;\n\n    int X1 = arr.length;\n\n    while (index < X1) {\n\n        if (index == 0) index ++;\n\n        if (compare (arr [index], arr [index - 1])) index ++;\n\n        else {\n\n            int temp = arr [index];\n\n            arr [index] = arr [index - 1];\n\n            arr [index - 1] = temp;\n\n            index --;\n\n        }\n\n    }\n\n}\n"}
{"idx": 69502, "func": "static int [] sort (int arr []) {\n\n    for (int i = 0;\n\n    i < arr.length; i ++) {\n\n        for (int X1 = i;\n\n        X1 < arr.length; X1 ++) {\n\n            if (arr [X1] < arr [i]) {\n\n                int temp = arr [i];\n\n                arr [i] = arr [X1];\n\n                arr [X1] = temp;\n\n            }\n\n        }\n\n    }\n\n    return arr;\n\n}\n"}
{"idx": 69601, "func": "public static String interleave (String you, String me) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    for (int i = 0;\n\n    i < Math.max (you.length (), me.length ()); i ++) {\n\n        if (i < you.length ()) {\n\n            X1.append (you.charAt (i));\n\n        }\n\n        if (i < me.length ()) {\n\n            X1.append (me.charAt (i));\n\n        }\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 69602, "func": "public static String interleave (String you, String me) {\n\n    char [] a = you.toCharArray ();\n\n    char [] b = me.toCharArray ();\n\n    StringBuilder out = new StringBuilder ();\n\n    int maxLength = Math.max (a.length, b.length);\n\n    for (int i = 0;\n\n    i < maxLength; i ++) {\n\n        if (i < a.length) out.X1 (a [i]);\n\n        if (i < b.length) out.X1 (b [i]);\n\n    }\n\n    return out.toString ();\n\n}\n"}
{"idx": 69701, "func": "public static void main (String [] args) throws Exception {\n\n    CountDownLatch latch = new CountDownLatch (1);\n\n    JobDetail X1 = JobBuilder.newJob (SimpleJob.class).withIdentity (\"CronQuartzJob\", \"Group\").build ();\n\n    Trigger trigger = newTrigger ().withIdentity (\"TriggerName\", \"Group\").withSchedule (CronScheduleBuilder.cronSchedule (\"0/1 * * * * ?\")).build ();\n\n    final Scheduler scheduler = new StdSchedulerFactory ().getScheduler ();\n\n    scheduler.start ();\n\n    scheduler.scheduleJob (X1, trigger);\n\n    latch.await ();\n\n    Runtime.getRuntime ().addShutdownHook (new Thread (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            try {\n\n                scheduler.shutdown ();\n\n                latch.countDown ();\n\n            } catch (Exception e) {\n\n                e.printStackTrace ();\n\n            }\n\n        }}\n\n    ));\n\n}\n"}
{"idx": 69702, "func": "public static void main (String [] args) {\n\n    final ScheduledExecutorService X1 = Executors.newSingleThreadScheduledExecutor ();\n\n    X1.scheduleWithFixedDelay (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            System.out.println (new Date ());\n\n        }}\n\n    , 0, 1, TimeUnit.SECONDS);\n\n}\n"}
{"idx": 69801, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 frame = new X1 ();\n\n            frame.addWindowListener (new WindowAdapter () {\n\n                @Override\n\n                public void windowClosing (WindowEvent e) {\n\n                    System.exit (0);\n\n                }}\n\n            );\n\n            frame.pack ();\n\n            frame.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 69802, "func": "public static void main (String args []) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            X1 application = new X1 ();\n\n            application.setVisible (true);\n\n        }}\n\n    );\n\n}\n"}
{"idx": 69901, "func": "public static void main (String [] args) throws IOException {\n\n    JFrame myFrame = new JFrame (\"myJfTitle\");\n\n    myFrame.setSize (300, 100);\n\n    myFrame.setLayout (new BorderLayout ());\n\n    JPanel myPanel = new JPanel ();\n\n    JButton myButton = new JButton (\"Click me\");\n\n    JProgressBar myBar = new JProgressBar ();\n\n    myBar.setPreferredSize (new Dimension (myFrame.getWidth (), myFrame.X1 ()));\n\n    myFrame.addComponentListener (new ComponentAdapter () {\n\n        public void componentResized (ComponentEvent evt) {\n\n            Component c = (Component) evt.getSource ();\n\n            myBar.setPreferredSize (new Dimension (myFrame.getWidth (), myFrame.X1 ()));\n\n        }}\n\n    );\n\n    JPanel glass = (JPanel) myFrame.getGlassPane ();\n\n    glass.setVisible (true);\n\n    myBar.setValue (50);\n\n    glass.add (myButton, BorderLayout.CENTER);\n\n    myPanel.add (myBar);\n\n    myFrame.add (myPanel);\n\n    myFrame.revalidate ();\n\n    myFrame.repaint ();\n\n    myFrame.setVisible (true);\n\n}\n"}
{"idx": 69902, "func": "public static void main (String [] args) throws IOException {\n\n    JFrame X1 = new JFrame (\"myJfTitle\");\n\n    X1.setLayout (new BorderLayout ());\n\n    JButton myButton = new JButton (\"Click me\");\n\n    myButton.setAlignmentX (Component.CENTER_ALIGNMENT);\n\n    JProgressBar myBar = new JProgressBar ();\n\n    LayoutManager overlay = new OverlayLayout (myBar);\n\n    myBar.setLayout (overlay);\n\n    myBar.setValue (50);\n\n    myBar.add (myButton);\n\n    X1.add (myBar, BorderLayout.CENTER);\n\n    X1.pack ();\n\n    X1.setSize (new Dimension (300, 100));\n\n    X1.setVisible (true);\n\n}\n"}
{"idx": 70001, "func": "public static void main (String [] args) throws Exception {\n\n    XMLInputFactory xif = XMLInputFactory.newFactory ();\n\n    StreamSource xml = new StreamSource (\"src/forum14326598/input.xml\");\n\n    XMLStreamReader xsr = xif.createXMLStreamReader (xml);\n\n    xsr = xif.createFilteredReader (xsr, new StreamFilter () {\n\n        private boolean accept = true;\n\n        @Override\n\n        public boolean accept (XMLStreamReader reader) {\n\n            if ((reader.isStartElement () || reader.isEndElement ()) && \"dad\".equals (reader.getLocalName ())) {\n\n                accept = ! accept;\n\n                return false;\n\n            } else {\n\n                return accept;\n\n            }\n\n        }}\n\n    );\n\n    while (xsr.hasNext ()) {\n\n        if (xsr.isStartElement ()) {\n\n            System.out.println (\"start: \" + xsr.getLocalName ());\n\n        } else if (xsr.isCharacters ()) {\n\n            if (xsr.X1 ().trim ().length () > 0) {\n\n                System.out.println (\"chars: \" + xsr.X1 ());\n\n            }\n\n        } else if (xsr.isEndElement ()) {\n\n            System.out.println (\"end: \" + xsr.getLocalName ());\n\n        }\n\n        xsr.next ();\n\n    }\n\n}\n"}
{"idx": 70002, "func": "public static void main (String [] args) throws FileNotFoundException, XMLStreamException {\n\n    System.setProperty (\"javax.xml.stream.XMLInputFactory\", \"com.ctc.wstx.stax.WstxInputFactory\");\n\n    System.setProperty (\"javax.xml.stream.XMLOutputFactory\", \"com.ctc.wstx.stax.WstxOutputFactory\");\n\n    System.setProperty (\"javax.xml.stream.XMLEventFactory\", \"com.ctc.wstx.stax.WstxEventFactory\");\n\n    FileInputStream fis = new FileInputStream (new File (\"family.xml\"));\n\n    XMLInputFactory xmlif = XMLInputFactory.newFactory ();\n\n    XMLStreamReader2 X1 = (XMLStreamReader2) xmlif.createXMLStreamReader (fis);\n\n    String currentElementName = null;\n\n    while (X1.hasNext ()) {\n\n        int eventType = X1.next ();\n\n        switch (eventType) {\n\n            case (XMLEvent2.START_ELEMENT) :\n\n                currentElementName = X1.getName ().toString ();\n\n                if (\"dad\".equals (currentElementName) == true) {\n\n                    System.out.println (\"isStartElement: \" + X1.isStartElement ());\n\n                    System.out.println (\"Element BEGIN: \" + currentElementName);\n\n                    X1.skipElement ();\n\n                } else {\n\n                    System.out.println (currentElementName);\n\n                }\n\n        }\n\n    }\n\n}\n"}
{"idx": 7001, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String formatedSource = source.X1 (start, end).toString ();\n\n    String destPrefix = dest.X1 (0, dstart).toString ();\n\n    String destSuffix = dest.X1 (dend, dest.length ()).toString ();\n\n    String result = destPrefix + formatedSource + destSuffix;\n\n    result = result.replace (\",\", \".\");\n\n    Matcher matcher = mPattern.matcher (result);\n\n    if (matcher.matches ()) {\n\n        return null;\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 7002, "func": "public CharSequence X1 (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    CharSequence out = super.X1 (source, start, end, dest, dstart, dend);\n\n    if (out != null) {\n\n        source = out;\n\n        start = 0;\n\n        end = out.length ();\n\n    }\n\n    int len = end - start;\n\n    if (len == 0) {\n\n        return source;\n\n    }\n\n    int dlen = dest.length ();\n\n    for (int i = 0;\n\n    i < dstart; i ++) {\n\n        if (dest.charAt (i) == '.') {\n\n            return (dlen - (i + 1) + len > digits) ? \"\" : new SpannableStringBuilder (source, start, end);\n\n        }\n\n    }\n\n    for (int i = start;\n\n    i < end; ++ i) {\n\n        if (source.charAt (i) == '.') {\n\n            if ((dlen - dend) + (end - (i + 1)) > digits) return \"\";\n\n            else break;\n\n        }\n\n    }\n\n    return new SpannableStringBuilder (source, start, end);\n\n}\n"}
{"idx": 701, "func": "public static void copyFolder (Path src, Path dest) {\n\n    try {\n\n        Files.walk (src).forEach (s -> {\n\n            try {\n\n                Path d = dest.resolve (src.relativize (s));\n\n                if (Files.isDirectory (s)) {\n\n                    if (! Files.exists (d)) Files.createDirectory (d);\n\n                    return;\n\n                }\n\n                Files.copy (s, d);\n\n            } catch (X1 e) {\n\n                e.printStackTrace ();\n\n            }\n\n        });\n\n    } catch (X1 ex) {\n\n        ex.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 70101, "func": "public static void printTable (String [] countries, int [] X1) {\n\n    int countryLength = 0;\n\n    long populationLength = 0;\n\n    for (String country : countries) {\n\n        if (country.length () > countryLength) countryLength = country.length ();\n\n    }\n\n    for (int i : X1) {\n\n        if (String.valueOf (i).length () > populationLength) populationLength = String.valueOf (i).length ();\n\n    }\n\n    for (int i = 0;\n\n    i < countries.length; i ++) System.out.format (\"%-\" + (countryLength + 1) + \"s|%\" + (populationLength + 1) + \"d\\n\", countries [i], X1 [i]);\n\n}\n"}
{"idx": 70102, "func": "public static void printTable (String [] countries, int [] X1) {\n\n    if (countries.length == 0 || X1.length == 0 || countries.length != X1.length) {\n\n        return;\n\n    }\n\n    int longestCountry = Arrays.stream (countries).map (String :: toString).mapToInt (String :: length).max ().getAsInt ();\n\n    int longestPop = Arrays.stream (X1).mapToObj (Integer :: toString).mapToInt (String :: length).max ().getAsInt ();\n\n    for (int i = 0;\n\n    i < countries.length; i ++) {\n\n        System.out.printf (\"%-\" + longestCountry + \"s | %\" + longestPop + \"d%n\", countries [i], X1 [i]);\n\n    }\n\n}\n"}
{"idx": 702, "func": "static void copyFolder (File src, File X1) {\n\n    if (src == null || X1 == null) return;\n\n    if (! src.isDirectory ()) return;\n\n    if (X1.exists ()) {\n\n        if (! X1.isDirectory ()) {\n\n            return;\n\n        }\n\n    } else {\n\n        X1.mkdir ();\n\n    }\n\n    if (src.listFiles () == null || src.listFiles ().length == 0) return;\n\n    String strAbsPathSrc = src.getAbsolutePath ();\n\n    String strAbsPathDest = X1.getAbsolutePath ();\n\n    try {\n\n        Files.walkFileTree (src.toPath (), new SimpleFileVisitor < Path > () {\n\n            @Override\n\n            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {\n\n                File dstFile = new File (strAbsPathDest + file.toAbsolutePath ().toString ().substring (strAbsPathSrc.length ()));\n\n                if (dstFile.exists ()) return FileVisitResult.CONTINUE;\n\n                if (! dstFile.getParentFile ().exists ()) dstFile.getParentFile ().mkdirs ();\n\n                Files.copy (file, dstFile.toPath ());\n\n                return FileVisitResult.CONTINUE;\n\n            }}\n\n        );\n\n    } catch (IOException e) {\n\n        return;\n\n    }\n\n    return;\n\n}\n"}
{"idx": 70201, "func": "public static void printTable (String [] countries, int [] populations) {\n\n    int countryLength = 0;\n\n    long populationLength = 0;\n\n    for (String country : countries) {\n\n        if (country.length () > countryLength) countryLength = country.length ();\n\n    }\n\n    for (int X1 : populations) {\n\n        if (String.valueOf (X1).length () > populationLength) populationLength = String.valueOf (X1).length ();\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < countries.length; X1 ++) System.out.format (\"%-\" + (countryLength + 1) + \"s|%\" + (populationLength + 1) + \"d\\n\", countries [X1], populations [X1]);\n\n}\n"}
{"idx": 70202, "func": "public static void printTable (String [] countries, int [] X1) {\n\n    if (countries.length != 0) {\n\n        int longestNameInput = countries [0].length ();\n\n        int longestPopInput = String.valueOf (X1 [0]).length ();\n\n        for (int i = 0;\n\n        i < countries.length; i ++) {\n\n            int countLength = countries [i].length ();\n\n            int popLength = String.valueOf (X1 [i]).length ();\n\n            if (countLength > longestNameInput) longestNameInput = countLength;\n\n            if (popLength > longestPopInput) longestPopInput = popLength;\n\n        }\n\n        for (int i = 0;\n\n        i < countries.length; i ++) {\n\n            System.out.print (countries [i]);\n\n            for (int j = 0;\n\n            j < (longestNameInput - countries [i].length ()); j ++) System.out.print (\" \");\n\n            System.out.print (\" | \");\n\n            for (int k = 0;\n\n            k < (longestPopInput - String.valueOf (X1 [i]).length ()); k ++) System.out.print (\" \");\n\n            System.out.println (X1 [i]);\n\n        }\n\n    }\n\n}\n"}
{"idx": 70301, "func": "public static void printTable (String [] X1, int [] populations) {\n\n    int countryLength = 0;\n\n    long populationLength = 0;\n\n    for (String country : X1) {\n\n        if (country.length () > countryLength) countryLength = country.length ();\n\n    }\n\n    for (int i : populations) {\n\n        if (String.valueOf (i).length () > populationLength) populationLength = String.valueOf (i).length ();\n\n    }\n\n    for (int i = 0;\n\n    i < X1.length; i ++) System.out.format (\"%-\" + (countryLength + 1) + \"s|%\" + (populationLength + 1) + \"d\\n\", X1 [i], populations [i]);\n\n}\n"}
{"idx": 70302, "func": "public static void printTable (String [] countries, int [] populations) {\n\n    int defaultLength = 10;\n\n    int maxCountryLength = stream (countries).mapToInt (String :: X1).max ().orElse (defaultLength);\n\n    int maxPopulationLength = stream (populations).mapToObj (Integer :: toString).mapToInt (String :: X1).max ().orElse (defaultLength);\n\n    for (int i = 0;\n\n    i < countries.X1; i ++) {\n\n        System.out.format (\"%-\" + maxCountryLength + \"s | %\" + maxPopulationLength + \"d\\n\", countries [i], populations [i]);\n\n    }\n\n}\n"}
{"idx": 70401, "func": "public static void printTable (String [] countries, int [] populations) {\n\n    if (countries.length == 0 || populations.length == 0 || countries.length != populations.length) {\n\n        return;\n\n    }\n\n    int longestCountry = Arrays.stream (countries).map (String :: toString).mapToInt (String :: length).max ().X1 ();\n\n    int longestPop = Arrays.stream (populations).mapToObj (Integer :: toString).mapToInt (String :: length).max ().X1 ();\n\n    for (int i = 0;\n\n    i < countries.length; i ++) {\n\n        System.out.printf (\"%-\" + longestCountry + \"s | %\" + longestPop + \"d%n\", countries [i], populations [i]);\n\n    }\n\n}\n"}
{"idx": 70402, "func": "public static void printTable (String [] countries, int [] X1) {\n\n    if (countries.length != 0) {\n\n        int longestNameInput = countries [0].length ();\n\n        int longestPopInput = String.valueOf (X1 [0]).length ();\n\n        for (int i = 0;\n\n        i < countries.length; i ++) {\n\n            int countLength = countries [i].length ();\n\n            int popLength = String.valueOf (X1 [i]).length ();\n\n            if (countLength > longestNameInput) longestNameInput = countLength;\n\n            if (popLength > longestPopInput) longestPopInput = popLength;\n\n        }\n\n        for (int i = 0;\n\n        i < countries.length; i ++) {\n\n            System.out.print (countries [i]);\n\n            for (int j = 0;\n\n            j < (longestNameInput - countries [i].length ()); j ++) System.out.print (\" \");\n\n            System.out.print (\" | \");\n\n            for (int k = 0;\n\n            k < (longestPopInput - String.valueOf (X1 [i]).length ()); k ++) System.out.print (\" \");\n\n            System.out.println (X1 [i]);\n\n        }\n\n    }\n\n}\n"}
{"idx": 70501, "func": "public static void printTable (String [] countries, int [] populations) {\n\n    if (countries.length != 0) {\n\n        int longestNameInput = countries [0].length ();\n\n        int longestPopInput = String.valueOf (populations [0]).length ();\n\n        for (int X1 = 0;\n\n        X1 < countries.length; X1 ++) {\n\n            int countLength = countries [X1].length ();\n\n            int popLength = String.valueOf (populations [X1]).length ();\n\n            if (countLength > longestNameInput) longestNameInput = countLength;\n\n            if (popLength > longestPopInput) longestPopInput = popLength;\n\n        }\n\n        for (int X1 = 0;\n\n        X1 < countries.length; X1 ++) {\n\n            System.out.print (countries [X1]);\n\n            for (int j = 0;\n\n            j < (longestNameInput - countries [X1].length ()); j ++) System.out.print (\" \");\n\n            System.out.print (\" | \");\n\n            for (int k = 0;\n\n            k < (longestPopInput - String.valueOf (populations [X1]).length ()); k ++) System.out.print (\" \");\n\n            System.out.println (populations [X1]);\n\n        }\n\n    }\n\n}\n"}
{"idx": 70502, "func": "public static void printTable (X1 [] countries, int [] populations) {\n\n    int defaultLength = 10;\n\n    int maxCountryLength = stream (countries).mapToInt (X1 :: length).max ().orElse (defaultLength);\n\n    int maxPopulationLength = stream (populations).mapToObj (Integer :: toString).mapToInt (X1 :: length).max ().orElse (defaultLength);\n\n    for (int i = 0;\n\n    i < countries.length; i ++) {\n\n        System.out.format (\"%-\" + maxCountryLength + \"s | %\" + maxPopulationLength + \"d\\n\", countries [i], populations [i]);\n\n    }\n\n}\n"}
{"idx": 70601, "func": "@Override\n\npublic boolean equals (Object that) {\n\n    if (this == that) return true;\n\n    if (! (that instanceof People)) return false;\n\n    People thatPeople = (People) that;\n\n    return this.X1.equals (thatPeople.X1) && this.age == thatPeople.age;\n\n}\n"}
{"idx": 70602, "func": "public boolean equals (Object obj) {\n\n    if (obj == null) {\n\n        return false;\n\n    }\n\n    if (! Person.class.isAssignableFrom (obj.getClass ())) {\n\n        return false;\n\n    }\n\n    final Person other = (Person) obj;\n\n    if ((this.X1 == null) ? (other.X1 != null) : ! this.X1.equals (other.X1)) {\n\n        return false;\n\n    }\n\n    if (this.age != other.age) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 70701, "func": "@Override\n\npublic boolean equals (Object that) {\n\n    if (this == that) return true;\n\n    if (! (that instanceof People)) return false;\n\n    People thatPeople = (People) that;\n\n    return this.X1.equals (thatPeople.X1) && this.age == thatPeople.age;\n\n}\n"}
{"idx": 70702, "func": "public boolean equals (Object other) {\n\n    boolean X1;\n\n    if ((other == null) || (getClass () != other.getClass ())) {\n\n        X1 = false;\n\n    } else {\n\n        People otherPeople = (People) other;\n\n        X1 = name.equals (otherPeople.name) && age == otherPeople.age;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 70801, "func": "public boolean equals (Object obj) {\n\n    if (obj == null) {\n\n        return false;\n\n    }\n\n    if (! Person.class.isAssignableFrom (obj.getClass ())) {\n\n        return false;\n\n    }\n\n    final Person X1 = (Person) obj;\n\n    if ((this.name == null) ? (X1.name != null) : ! this.name.equals (X1.name)) {\n\n        return false;\n\n    }\n\n    if (this.age != X1.age) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 70802, "func": "public boolean equals (Object other) {\n\n    boolean X1;\n\n    if ((other == null) || (getClass () != other.getClass ())) {\n\n        X1 = false;\n\n    } else {\n\n        People otherPeople = (People) other;\n\n        X1 = name.equals (otherPeople.name) && age == otherPeople.age;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 70901, "func": "public static int [] sort (int [] numbers, int digit) {\n\n    if (numbers.length == 0 || digit <= 0) return numbers;\n\n    int [] [] space = new int [10] [0];\n\n    int [] len = new int [10];\n\n    int X1, j;\n\n    for (j = 0; j < numbers.length; j ++) {\n\n        X1 = (numbers [j] / digit) % 10;\n\n        len [X1] ++;\n\n        space [X1] = putInBucket (space [X1], numbers [j]);\n\n    }\n\n    for (X1 = 0; X1 < 10; X1 ++) {\n\n        space [X1] = sort (space [X1], digit / 10);\n\n    }\n\n    int k = 0;\n\n    for (X1 = 0; X1 < 10; X1 ++) {\n\n        for (j = 0; j < len [X1]; j ++) {\n\n            numbers [k] = space [X1] [j];\n\n            k ++;\n\n        }\n\n    }\n\n    return numbers;\n\n}\n"}
{"idx": 70902, "func": "public static int [] sort (int [] X1, int digit) {\n\n    if (X1.length == 0 || digit <= 0) return X1;\n\n    int [] [] space = new int [10] [1];\n\n    int [] len = new int [10];\n\n    int i, j = 0;\n\n    for (j = 0; j < X1.length; j ++) {\n\n        i = (X1 [j] / digit) % 10;\n\n        len [i] ++;\n\n        space [i] = putInBucket (space [i], X1 [j]);\n\n    }\n\n    for (i = 0; i < 10; i ++) {\n\n        int [] bucket = new int [len [i]];\n\n        for (int k = 0;\n\n        k < len [i]; k ++) bucket [k] = space [i] [k];\n\n        space [i] = sort (bucket, digit / 10);\n\n    }\n\n    int k = 0;\n\n    for (i = 0; i < 10; i ++) {\n\n        for (j = 0; j < len [i]; j ++) {\n\n            X1 [k] = space [i] [j];\n\n            k ++;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 71001, "func": "public static void drawTable (PDPage page, PDPageContentStream contentStream, float y, float margin, String [] [] content) throws IOException {\n\n    final int X1 = content.length;\n\n    final int cols = content [0].length;\n\n    final float rowHeight = 20f;\n\n    final float tableWidth = page.getCropBox ().getWidth () - margin - margin;\n\n    final float tableHeight = rowHeight * X1;\n\n    final float colWidth = tableWidth / (float) cols;\n\n    final float cellMargin = 5f;\n\n    float nexty = y;\n\n    for (int i = 0;\n\n    i <= X1; i ++) {\n\n        contentStream.drawLine (margin, nexty, margin + tableWidth, nexty);\n\n        nexty -= rowHeight;\n\n    }\n\n    float nextx = margin;\n\n    for (int i = 0;\n\n    i <= cols; i ++) {\n\n        contentStream.drawLine (nextx, y, nextx, y - tableHeight);\n\n        nextx += colWidth;\n\n    }\n\n    contentStream.setFont (PDType1Font.HELVETICA_BOLD, 12);\n\n    float textx = margin + cellMargin;\n\n    float texty = y - 15;\n\n    for (int i = 0;\n\n    i < content.length; i ++) {\n\n        for (int j = 0;\n\n        j < content [i].length; j ++) {\n\n            String text = content [i] [j];\n\n            contentStream.beginText ();\n\n            contentStream.moveTextPositionByAmount (textx, texty);\n\n            contentStream.drawString (text);\n\n            contentStream.endText ();\n\n            textx += colWidth;\n\n        }\n\n        texty -= rowHeight;\n\n        textx = margin + cellMargin;\n\n    }\n\n}\n"}
{"idx": 71002, "func": "private static void drawTable (PDPage page, PDPageContentStream contentStream) {\n\n    try {\n\n        float y = 650;\n\n        float X1 = 130;\n\n        String [] content = {\"One\", \"Two\", \"Date\", \"Score\", \"Score2\", \"Score3\", \"Score4\", \"Score5\", \"Score6\"};\n\n        final int rows = content.length;\n\n        final int cols = 2;\n\n        final float rowHeight = 22f;\n\n        final float tableWidth = 900.0f;\n\n        final float tableHeight = rowHeight * rows;\n\n        final float cellMargin = 1f;\n\n        float nexty = y;\n\n        for (int i = 0;\n\n        i <= rows; i ++) {\n\n            contentStream.drawLine (X1, nexty, 400, nexty);\n\n            nexty -= rowHeight;\n\n        }\n\n        float colWidthX [] = {200, 70, 0};\n\n        float nextx = X1;\n\n        for (int i = 0;\n\n        i <= cols; i ++) {\n\n            contentStream.drawLine (nextx, y, nextx, y - tableHeight);\n\n            nextx += colWidthX [i];\n\n        }\n\n        float textx = X1 + cellMargin;\n\n        float texty = y - 15;\n\n        for (int j = 0;\n\n        j < rows; j ++) {\n\n            contentStream.beginText ();\n\n            contentStream.moveTextPositionByAmount (textx, texty);\n\n            contentStream.drawString (content [j]);\n\n            contentStream.endText ();\n\n            textx += colWidthX [0] + 9;\n\n            contentStream.beginText ();\n\n            contentStream.moveTextPositionByAmount (textx, texty);\n\n            if (j == 0) contentStream.drawString (\"1\");\n\n            if (j == 1) contentStream.drawString (\"12345\");\n\n            if (j == 2) contentStream.drawString (\"05-December-2003\");\n\n            if (j == 3) contentStream.drawString (\"15\");\n\n            if (j == 4) contentStream.drawString (\"1\");\n\n            if (j == 5) contentStream.drawString (\"1\");\n\n            if (j == 6) contentStream.drawString (\"1\");\n\n            if (j == 7) contentStream.drawString (\"1\");\n\n            if (j == 8) contentStream.drawString (\"1\");\n\n            contentStream.endText ();\n\n            textx = X1 + cellMargin;\n\n            texty -= rowHeight;\n\n        }\n\n        texty -= rowHeight;\n\n        textx = X1 + cellMargin;\n\n    } catch (IOException ioe) {\n\n        final String errormsg = \"Could not drawTable \";\n\n        throw new RuntimeException (errormsg, ioe);\n\n    } catch (Exception ex) {\n\n        final String errormsg = \"Could not drawTable \";\n\n        throw new RuntimeException (errormsg, ex);\n\n    }\n\n}\n"}
{"idx": 7101, "func": "public CharSequence filter (CharSequence source, int start, int X1, Spanned dest, int dstart, int dend) {\n\n    String formatedSource = source.subSequence (start, X1).toString ();\n\n    String destPrefix = dest.subSequence (0, dstart).toString ();\n\n    String destSuffix = dest.subSequence (dend, dest.length ()).toString ();\n\n    String result = destPrefix + formatedSource + destSuffix;\n\n    result = result.replace (\",\", \".\");\n\n    Matcher matcher = mPattern.matcher (result);\n\n    if (matcher.matches ()) {\n\n        return null;\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 7102, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String lsStart = \"\";\n\n    String lsInsert = \"\";\n\n    String X1 = \"\";\n\n    String lsText = \"\";\n\n    Log.d (\"debug\", moPattern.toString ());\n\n    Log.d (\"debug\", \"source: \" + source + \", start: \" + start + \", end:\" + end + \", dest: \" + dest + \", dstart: \" + dstart + \", dend: \" + dend);\n\n    lsText = dest.toString ();\n\n    if (lsText.length () > 0) {\n\n        lsStart = lsText.substring (0, dstart);\n\n        Log.d (\"debug\", \"lsStart : \" + lsStart);\n\n        if (source != \"\") {\n\n            lsInsert = source.toString ();\n\n            Log.d (\"debug\", \"lsInsert: \" + lsInsert);\n\n        }\n\n        X1 = lsText.substring (dend);\n\n        Log.d (\"debug\", \"lsEnd   : \" + X1);\n\n        lsText = lsStart + lsInsert + X1;\n\n        Log.d (\"debug\", \"lsText  : \" + lsText);\n\n    }\n\n    Matcher loMatcher = moPattern.matcher (lsText);\n\n    Log.d (\"debug\", \"loMatcher.matches(): \" + loMatcher.matches () + \", lsText: \" + lsText);\n\n    if (! loMatcher.matches ()) {\n\n        return \"\";\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 71101, "func": "public int readNumber () {\n\n    int X1 = - 1;\n\n    do {\n\n        try {\n\n            System.out.println (\"Please enter a positive number.\");\n\n            X1 = keyboard.nextInt ();\n\n        } catch (InputMismatchException e) {\n\n        }\n\n    } while (X1 < 0);\n\n    return X1;\n\n}\n"}
{"idx": 71102, "func": "public int readNumber () {\n\n    int X1 = - 1;\n\n    while (X1 < 0) {\n\n        System.out.println (\"Please enter a positive number.\");\n\n        try {\n\n            X1 = keyboard.nextInt ();\n\n        } catch (java.util.InputMismatchException e) {\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 71201, "func": "public static void main (String [] args) {\n\n    int n = 7;\n\n    for (int i = 0;\n\n    i < 7; i ++) {\n\n        for (int j = 0;\n\n        j < 4; j ++) {\n\n            if (i + j <= n - 4 || j == 0 || i == n - 1) System.X1.print (\"*\");\n\n            else if (i - j >= n - 4) System.X1.print (\"*\");\n\n            else System.X1.print (\" \");\n\n        }\n\n        System.X1.println ();\n\n    }\n\n}\n"}
{"idx": 71202, "func": "public static void main (String [] args) {\n\n    int n = 7;\n\n    int X1 = n / 2;\n\n    for (int i = 0;\n\n    i < n; i ++) {\n\n        for (int j = 0;\n\n        j < Math.abs (X1 - i) + 1; j ++) {\n\n            System.out.print (\"*\");\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 71301, "func": "public static void main (String [] args) {\n\n    int n = 7;\n\n    for (int i = 0;\n\n    i < 7; i ++) {\n\n        for (int X1 = 0;\n\n        X1 < 4; X1 ++) {\n\n            if (i + X1 <= n - 4 || X1 == 0 || i == n - 1) System.out.print (\"*\");\n\n            else if (i - X1 >= n - 4) System.out.print (\"*\");\n\n            else System.out.print (\" \");\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 71302, "func": "public static void main (String [] args) {\n\n    for (int X1 = 1;\n\n    X1 <= 7; X1 += 2) {\n\n        for (int space = 7;\n\n        space >= X1; space -= 2) {\n\n            System.out.print (\"*\");\n\n        }\n\n        for (int i = 1;\n\n        i <= X1; i ++) {\n\n            System.out.print (\" \");\n\n        }\n\n        System.out.print (\"\\n\");\n\n    }\n\n    for (int X1 = 5;\n\n    X1 >= 1; X1 -= 2) {\n\n        for (int space = 7;\n\n        space >= X1; space -= 2) {\n\n            System.out.print (\"*\");\n\n        }\n\n        for (int i = 1;\n\n        i <= X1; i ++) {\n\n            System.out.print (\" \");\n\n        }\n\n        System.out.print (\"\\n\");\n\n    }\n\n}\n"}
{"idx": 71401, "func": "public static void main (String [] args) {\n\n    int X1 = 7;\n\n    int mid = X1 / 2;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        for (int j = 0;\n\n        j < Math.abs (mid - i) + 1; j ++) {\n\n            System.out.print (\"*\");\n\n        }\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 71402, "func": "public static void main (String [] args) {\n\n    for (int row = 1;\n\n    row <= 7; row += 2) {\n\n        for (int space = 7;\n\n        space >= row; space -= 2) {\n\n            System.out.print (\"*\");\n\n        }\n\n        for (int X1 = 1;\n\n        X1 <= row; X1 ++) {\n\n            System.out.print (\" \");\n\n        }\n\n        System.out.print (\"\\n\");\n\n    }\n\n    for (int row = 5;\n\n    row >= 1; row -= 2) {\n\n        for (int space = 7;\n\n        space >= row; space -= 2) {\n\n            System.out.print (\"*\");\n\n        }\n\n        for (int X1 = 1;\n\n        X1 <= row; X1 ++) {\n\n            System.out.print (\" \");\n\n        }\n\n        System.out.print (\"\\n\");\n\n    }\n\n}\n"}
{"idx": 71501, "func": "private static void decimalToHex (int X1) {\n\n    int maxDigit = 1;\n\n    while (maxDigit * 16 <= X1 && maxDigit > 0) {\n\n        maxDigit *= 16;\n\n    }\n\n    if (maxDigit <= 0) {\n\n        throw new IllegalArgumentException (\"Can not convert \" + X1);\n\n    }\n\n    for (int digit = maxDigit;\n\n    digit > 0; digit /= 16) {\n\n        printHex ((X1 / digit) % 16);\n\n    }\n\n}\n"}
{"idx": 71502, "func": "private static void decimalToHex (int X1) {\n\n    if (X1 >= 256) {\n\n        returnHex (X1 / 256);\n\n        X1 %= 256;\n\n    } else {\n\n        System.out.print (\"0\");\n\n    }\n\n    if (X1 >= 16) {\n\n        returnHex (X1 / 16);\n\n        X1 %= 16;\n\n    } else {\n\n        System.out.print (\"0\");\n\n    }\n\n    returnHex (X1);\n\n    X1 /= 16;\n\n}\n"}
{"idx": 71601, "func": "public int [] zeroFront (int [] nums) {\n\n    Stack X1 = new Stack ();\n\n    int [] nums2 = new int [nums.length];\n\n    for (int i = 0;\n\n    i < nums.length; i ++) {\n\n        if (nums [i] != 0) {\n\n            X1.push (nums [i]);\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < nums.length; i ++) {\n\n        if (nums [i] == 0) {\n\n            X1.push (nums [i]);\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < nums.length; i ++) {\n\n        nums2 [i] = (Integer) X1.pop ();\n\n    }\n\n    return nums2;\n\n}\n"}
{"idx": 71602, "func": "public int [] zeroFront (int [] nums) {\n\n    if (nums == null) {\n\n        return null;\n\n    }\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < nums.length; ++ i) {\n\n        if (nums [i] == 0) {\n\n            num [i] = num [X1];\n\n            num [X1] = 0;\n\n            ++ X1;\n\n        }\n\n    }\n\n    return num;\n\n}\n"}
{"idx": 71701, "func": "public int [] zeroFront (int [] nums) {\n\n    Stack stack = new Stack ();\n\n    int [] nums2 = new int [nums.length];\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        if (nums [X1] != 0) {\n\n            stack.push (nums [X1]);\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        if (nums [X1] == 0) {\n\n            stack.push (nums [X1]);\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < nums.length; X1 ++) {\n\n        nums2 [X1] = (Integer) stack.pop ();\n\n    }\n\n    return nums2;\n\n}\n"}
{"idx": 71702, "func": "public int [] zeroFront (int [] nums) {\n\n    if (nums == null) {\n\n        return null;\n\n    }\n\n    int [] result = new int [nums.X1];\n\n    int zeroesPos = 0;\n\n    int othersPos = result.X1 - 1;\n\n    for (int i = 0;\n\n    i < nums.X1; ++ i) {\n\n        if (nums [i] == 0) {\n\n            result [zeroesPos] = 0;\n\n            ++ zeroesPos;\n\n        } else {\n\n            result [othersPos] = nums [i];\n\n            -- othersPos;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 71801, "func": "public int [] zeroFront (int [] nums) {\n\n    if (nums == null) {\n\n        return null;\n\n    }\n\n    int zerosPos = 0;\n\n    for (int X1 = 0;\n\n    X1 < nums.length; ++ X1) {\n\n        if (nums [X1] == 0) {\n\n            num [X1] = num [zerosPos];\n\n            num [zerosPos] = 0;\n\n            ++ zerosPos;\n\n        }\n\n    }\n\n    return num;\n\n}\n"}
{"idx": 71802, "func": "public int [] zeroFront (int [] nums) {\n\n    if (nums == null) {\n\n        return null;\n\n    }\n\n    int [] X1 = new int [nums.length];\n\n    int zeroesPos = 0;\n\n    int othersPos = X1.length - 1;\n\n    for (int i = 0;\n\n    i < nums.length; ++ i) {\n\n        if (nums [i] == 0) {\n\n            X1 [zeroesPos] = 0;\n\n            ++ zeroesPos;\n\n        } else {\n\n            X1 [othersPos] = nums [i];\n\n            -- othersPos;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 71901, "func": "public static void main (String args []) throws IOException {\n\n    BufferedReader dataIn = new BufferedReader (new InputStreamReader (System.in));\n\n    String strSize, strGrades;\n\n    int laki = 100;\n\n    int totalGrades = 0;\n\n    float gradeAverage = 0;\n\n    float [] grades = new float [laki];\n\n    System.out.print (\"How many grades will you enter?\");\n\n    strSize = dataIn.X1 ();\n\n    laki = Integer.parseInt (strSize);\n\n    grades = new float [laki];\n\n    for (int i = 0;\n\n    i < laki; i ++) {\n\n        System.out.print (\"Please enter grade # \" + (i + 1) + \": \");\n\n        strGrades = dataIn.X1 ();\n\n        grades [i] = Float.parseFloat (strGrades);\n\n        totalGrades += grades [i];\n\n    }\n\n    gradeAverage = totalGrades / laki;\n\n    System.out.println (\"Your grades average is \" + gradeAverage);\n\n}\n"}
{"idx": 71902, "func": "public static void main (String args []) throws IOException {\n\n    BufferedReader dataIn = new BufferedReader (new InputStreamReader (System.in));\n\n    int totalGrades = 0;\n\n    float gradeAverage = 0;\n\n    System.out.print (\"How many grades will you enter?\");\n\n    int laki = Integer.parseInt (dataIn.X1 ());\n\n    float [] grades = new float [laki];\n\n    int count = 0;\n\n    while (laki > 0) {\n\n        System.out.print (\"Please enter grade # \" + (count + 1) + \": \");\n\n        grades [count] = Float.parseFloat (dataIn.X1 ());\n\n        totalGrades += grades [count];\n\n        laki --;\n\n        count ++;\n\n    }\n\n    gradeAverage = (float) totalGrades / count;\n\n    System.out.println (\"Your grades average is \" + gradeAverage);\n\n}\n"}
{"idx": 72001, "func": "public static void main (String args []) throws IOException {\n\n    BufferedReader dataIn = new BufferedReader (new InputStreamReader (System.in));\n\n    int totalGrades = 0;\n\n    float gradeAverage = 0;\n\n    System.out.print (\"How many grades will you enter?\");\n\n    int laki = Integer.parseInt (dataIn.X1 ());\n\n    float [] grades = new float [laki];\n\n    int count = 0;\n\n    while (laki > 0) {\n\n        System.out.print (\"Please enter grade # \" + (count + 1) + \": \");\n\n        grades [count] = Float.parseFloat (dataIn.X1 ());\n\n        totalGrades += grades [count];\n\n        laki --;\n\n        count ++;\n\n    }\n\n    gradeAverage = (float) totalGrades / count;\n\n    System.out.println (\"Your grades average is \" + gradeAverage);\n\n}\n"}
{"idx": 72002, "func": "public static void main (final String [] args) {\n\n    final JFrame frame = new JFrame (\"Display Keyword Panel\");\n\n    final JPanel panel = new JPanel ();\n\n    panel.setLayout (new BoxLayout (panel, BoxLayout.Y_AXIS));\n\n    text1.setBorder (null);\n\n    text1.setOpaque (false);\n\n    text1.setEditable (false);\n\n    text2.setBorder (null);\n\n    text2.setOpaque (false);\n\n    text2.setEditable (false);\n\n    text1.getInputMap ().put (KeyStroke.getKeyStroke ('G', KeyEvent.CTRL_DOWN_MASK), \"copyAll\");\n\n    text1.getActionMap ().put (\"copyAll\", new AbstractAction () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            X1 s = new X1 ();\n\n            s.append (text1.getText ()).append (\"\\n\").append (text2.getText ());\n\n            System.out.println (s.toString ());\n\n        }}\n\n    );\n\n    panel.add (text1);\n\n    panel.add (text2);\n\n    frame.setLayout (new BorderLayout ());\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    frame.getContentPane ().add (panel, BorderLayout.CENTER);\n\n    frame.setLocation (450, 400);\n\n    frame.pack ();\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 7201, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String formatedSource = source.subSequence (start, end).toString ();\n\n    String destPrefix = dest.subSequence (0, dstart).toString ();\n\n    String destSuffix = dest.subSequence (dend, dest.length ()).toString ();\n\n    String X1 = destPrefix + formatedSource + destSuffix;\n\n    X1 = X1.replace (\",\", \".\");\n\n    Matcher matcher = mPattern.matcher (X1);\n\n    if (matcher.matches ()) {\n\n        return null;\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 7202, "func": "public CharSequence filter (CharSequence X1, int start, int end, Spanned dest, int dstart, int dend) {\n\n    int dotPos = - 1;\n\n    int len = dest.length ();\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        char c = dest.charAt (i);\n\n        if (c == '.' || c == ',') {\n\n            dotPos = i;\n\n            break;\n\n        }\n\n    }\n\n    if (dotPos >= 0) {\n\n        if (X1.equals (\".\") || X1.equals (\",\")) {\n\n            return \"\";\n\n        }\n\n        if (dend <= dotPos) {\n\n            return null;\n\n        }\n\n        if (len - dotPos > decimalDigits) {\n\n            return \"\";\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 72101, "func": "public static void main (String [] args) {\n\n    Scanner stdin = new Scanner (System.in);\n\n    int [] wordCount = new int [1000];\n\n    String [] wordList = new String [1000];\n\n    int j = 0;\n\n    while (stdin.hasNextLine ()) {\n\n        String s = stdin.nextLine ();\n\n        String [] words = s.split (\"\\\\W+\");\n\n        for (String word : words) {\n\n            int listIndex = - 1;\n\n            for (int X1 = 0;\n\n            X1 < wordList.length; X1 ++) {\n\n                if (word.equals (wordList [X1])) {\n\n                    listIndex = X1;\n\n                }\n\n            }\n\n            if (listIndex > - 1) {\n\n                wordCount [listIndex] ++;\n\n            } else {\n\n                wordList [j] = word;\n\n                wordCount [j] ++;\n\n                j ++;\n\n            }\n\n        }\n\n        for (int X1 = 0;\n\n        X1 < j; X1 ++) {\n\n            System.out.println (\"the word: \" + wordList [X1] + \" occured \" + wordCount [X1] + \" time(s).\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 72102, "func": "public static void main (String [] args) {\n\n    Scanner stdin = new Scanner (System.in);\n\n    String [] wordArray = new String [10000];\n\n    int [] wordCount = new int [10000];\n\n    int numWords = 0;\n\n    while (stdin.hasNextLine ()) {\n\n        String s = stdin.nextLine ();\n\n        ArrayList < String > noDuplicated = new ArrayList < String > ();\n\n        String [] X1 = s.replaceAll (\"[^a-zA-Z ]\", \"\").toLowerCase ().split (\"\\\\s+\");\n\n        for (int i = 0;\n\n        i < X1.length; i ++) {\n\n            if (! noDuplicated.contains (X1 [i])) noDuplicated.add (X1 [i]);\n\n        }\n\n        for (int i = 0;\n\n        i < noDuplicated.size (); i ++) {\n\n            int count = 0;\n\n            for (int j = 0;\n\n            j < X1.length; j ++) {\n\n                if (noDuplicated.get (i).equals (X1 [j])) count ++;\n\n            }\n\n            System.out.println (\"word count:  \" + X1 [i] + \" \" + count);\n\n        }\n\n    }\n\n}\n"}
{"idx": 72201, "func": "private static int [] removeEven (int [] k, int n) {\n\n    for (int X1 = 0;\n\n    X1 < n; X1 ++) {\n\n        if (k [X1] % 2 == 0) {\n\n            for (int j = X1 + 1;\n\n            j < n; j ++) {\n\n                if (k [j] % 2 != 0) {\n\n                    k [X1] = k [X1] + k [j];\n\n                    k [j] = k [X1] - k [j];\n\n                    k [X1] = k [X1] - k [j];\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return k;\n\n}\n"}
{"idx": 72202, "func": "private static void removeEven (int [] k, int n) {\n\n    int counter = 0;\n\n    for (int X1 = 0;\n\n    X1 < n; X1 ++) if (k [X1] % 2 == 1) k [counter ++] = k [X1];\n\n    for (int X1 = counter;\n\n    X1 < n; X1 ++) k [X1] = 0;\n\n}\n"}
{"idx": 72301, "func": "public void actionPerformed (ActionEvent e) {\n\n    if (! connected) {\n\n        X1.showMessageDialog (null, \"Connected\");\n\n        putValue (NAME, \"Disonnect\");\n\n        connected = true;\n\n    } else {\n\n        X1.showMessageDialog (null, \"Disconnected\");\n\n        putValue (NAME, \"Connect\");\n\n        connected = false;\n\n    }\n\n}\n"}
{"idx": 72302, "func": "public void actionPerformed (ActionEvent e) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            if (! isConnected) {\n\n                System.X1.println (\"connect action\");\n\n                connect ();\n\n                isConnected = true;\n\n            } else {\n\n                System.X1.println (\"disconnect action\");\n\n                disconnect ();\n\n                isConnected = false;\n\n            }\n\n        }}\n\n    );\n\n}\n"}
{"idx": 72401, "func": "public void onPageScrollStateChanged (int state) {\n\n    Log.v (\"onPageScrollStateChanged\", String.valueOf (state));\n\n    if (state == ViewPager.SCROLL_STATE_IDLE) {\n\n        int index = pager.getCurrentItem ();\n\n        if (index == 0) pager.X1 (adapter.getCount () - 2, false);\n\n        else if (index == adapter.getCount () - 1) pager.X1 (1, false);\n\n    }\n\n}\n"}
{"idx": 72402, "func": "public void onPageScrollStateChanged (int state) {\n\n    if (state == ViewPager.SCROLL_STATE_IDLE) {\n\n        PagerAdapter pagerAdapter = viewPager.getAdapter ();\n\n        if (pagerAdapter != null) {\n\n            int itemCount = pagerAdapter.getCount ();\n\n            if (itemCount < 2) {\n\n                return;\n\n            }\n\n            int X1 = viewPager.getCurrentItem ();\n\n            if (X1 == 0) {\n\n                viewPager.setCurrentItem (itemCount - 2, false);\n\n            } else if (X1 == itemCount - 1) {\n\n                viewPager.setCurrentItem (1, false);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 72501, "func": "void draw (Graphics2D g, int width, int height) {\n\n    g.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    g.setColor (X1.WHITE);\n\n    g.fillRect (0, 0, width, height);\n\n    for (Arrow arrow : arrows) {\n\n        g.setColor (X1.ORANGE);\n\n        g.fillRect (350, 20, 20, 280);\n\n        g.setStroke (new BasicStroke (20.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));\n\n        g.translate (0, 60);\n\n        arrow.draw (g);\n\n        g.setStroke (new BasicStroke (20.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n\n        g.translate (0, 100);\n\n        arrow.draw (g);\n\n        g.setStroke (new BasicStroke (20.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));\n\n        g.translate (0, 100);\n\n        arrow.draw (g);\n\n        g.translate (400, - 260);\n\n    }\n\n}\n"}
{"idx": 72502, "func": "public void draw (Graphics2D g) {\n\n    float arrowRatio = 0.5f;\n\n    float arrowLength = 80.0f;\n\n    BasicStroke stroke = (BasicStroke) g.getStroke ();\n\n    float endX = 350.0f;\n\n    float veeX;\n\n    switch (stroke.getLineJoin ()) {\n\n        case BasicStroke.JOIN_BEVEL :\n\n            veeX = endX - stroke.getLineWidth () * 0.25f;\n\n            break;\n\n        default :\n\n        case BasicStroke.JOIN_MITER :\n\n            veeX = endX - stroke.getLineWidth () * 0.5f / arrowRatio;\n\n            break;\n\n        case BasicStroke.JOIN_ROUND :\n\n            veeX = endX - stroke.getLineWidth () * 0.5f;\n\n            break;\n\n    }\n\n    Path2D.Float X1 = new Path2D.Float ();\n\n    X1.moveTo (veeX - arrowLength, - arrowRatio * arrowLength);\n\n    X1.lineTo (veeX, 0.0f);\n\n    X1.lineTo (veeX - arrowLength, arrowRatio * arrowLength);\n\n    g.setColor (Color.BLUE);\n\n    g.draw (X1);\n\n    g.setColor (Color.YELLOW);\n\n    g.draw (new Line2D.Float (50.0f, 0.0f, veeX, 0.0f));\n\n    g.setColor (Color.RED);\n\n    g.draw (new Line2D.Float (50.0f, 0.0f, veeX - stroke.getLineWidth () * 0.25f, 0.0f));\n\n}\n"}
{"idx": 72601, "func": "void draw (Graphics2D X1, int width, int height) {\n\n    X1.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    X1.setColor (Color.WHITE);\n\n    X1.fillRect (0, 0, width, height);\n\n    for (Arrow arrow : arrows) {\n\n        X1.setColor (Color.ORANGE);\n\n        X1.fillRect (350, 20, 20, 280);\n\n        X1.setStroke (new BasicStroke (20.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));\n\n        X1.translate (0, 60);\n\n        arrow.draw (X1);\n\n        X1.setStroke (new BasicStroke (20.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));\n\n        X1.translate (0, 100);\n\n        arrow.draw (X1);\n\n        X1.setStroke (new BasicStroke (20.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));\n\n        X1.translate (0, 100);\n\n        arrow.draw (X1);\n\n        X1.translate (400, - 260);\n\n    }\n\n}\n"}
{"idx": 72602, "func": "public void draw (Graphics2D g) {\n\n    float arrowRatio = 0.5f;\n\n    float arrowLength = 80.0f;\n\n    BasicStroke stroke = (BasicStroke) g.getStroke ();\n\n    float endX = 350.0f;\n\n    float veeX = endX - stroke.getLineWidth () * 0.5f / arrowRatio;\n\n    Path2D.Float path = new Path2D.Float ();\n\n    float X1 = 0.5f;\n\n    float waistX = endX - arrowLength * 0.5f;\n\n    float waistY = arrowRatio * arrowLength * 0.5f * X1;\n\n    float arrowWidth = arrowRatio * arrowLength;\n\n    path.moveTo (veeX - arrowLength, - arrowWidth);\n\n    path.quadTo (waistX, - waistY, endX, 0.0f);\n\n    path.quadTo (waistX, waistY, veeX - arrowLength, arrowWidth);\n\n    path.lineTo (veeX - arrowLength * 0.75f, 0.0f);\n\n    path.lineTo (veeX - arrowLength, - arrowWidth);\n\n    g.setColor (Color.BLUE);\n\n    g.fill (path);\n\n    g.setColor (Color.RED);\n\n    g.draw (new Line2D.Float (50.0f, 0.0f, veeX - arrowLength * 0.5f, 0.0f));\n\n}\n"}
{"idx": 72701, "func": "public void draw (Graphics2D g) {\n\n    float arrowRatio = 0.5f;\n\n    float arrowLength = 80.0f;\n\n    BasicStroke stroke = (BasicStroke) g.getStroke ();\n\n    float endX = 350.0f;\n\n    float veeX;\n\n    switch (stroke.getLineJoin ()) {\n\n        case BasicStroke.JOIN_BEVEL :\n\n            veeX = endX - stroke.getLineWidth () * 0.25f;\n\n            break;\n\n        default :\n\n        case BasicStroke.JOIN_MITER :\n\n            veeX = endX - stroke.getLineWidth () * 0.5f / arrowRatio;\n\n            break;\n\n        case BasicStroke.JOIN_ROUND :\n\n            veeX = endX - stroke.getLineWidth () * 0.5f;\n\n            break;\n\n    }\n\n    Path2D.X1 path = new Path2D.X1 ();\n\n    path.moveTo (veeX - arrowLength, - arrowRatio * arrowLength);\n\n    path.lineTo (veeX, 0.0f);\n\n    path.lineTo (veeX - arrowLength, arrowRatio * arrowLength);\n\n    g.setColor (Color.BLUE);\n\n    g.draw (path);\n\n    g.setColor (Color.YELLOW);\n\n    g.draw (new Line2D.X1 (50.0f, 0.0f, veeX, 0.0f));\n\n    g.setColor (Color.RED);\n\n    g.draw (new Line2D.X1 (50.0f, 0.0f, veeX - stroke.getLineWidth () * 0.25f, 0.0f));\n\n}\n"}
{"idx": 72702, "func": "public void draw (Graphics2D g) {\n\n    float X1 = 0.5f;\n\n    float arrowLength = 80.0f;\n\n    BasicStroke stroke = (BasicStroke) g.getStroke ();\n\n    float endX = 350.0f;\n\n    float veeX = endX - stroke.getLineWidth () * 0.5f / X1;\n\n    Path2D.Float path = new Path2D.Float ();\n\n    float waisting = 0.5f;\n\n    float waistX = endX - arrowLength * 0.5f;\n\n    float waistY = X1 * arrowLength * 0.5f * waisting;\n\n    float arrowWidth = X1 * arrowLength;\n\n    path.moveTo (veeX - arrowLength, - arrowWidth);\n\n    path.quadTo (waistX, - waistY, endX, 0.0f);\n\n    path.quadTo (waistX, waistY, veeX - arrowLength, arrowWidth);\n\n    path.lineTo (veeX - arrowLength * 0.75f, 0.0f);\n\n    path.lineTo (veeX - arrowLength, - arrowWidth);\n\n    g.setColor (Color.BLUE);\n\n    g.fill (path);\n\n    g.setColor (Color.RED);\n\n    g.draw (new Line2D.Float (50.0f, 0.0f, veeX - arrowLength * 0.5f, 0.0f));\n\n}\n"}
{"idx": 72801, "func": "public static void main (String [] args) {\n\n    Scanner scn = new Scanner (System.in);\n\n    int number;\n\n    int X1 = 0;\n\n    for (int i = 1;\n\n    i <= 5; i ++) {\n\n        System.out.println (\"Enter number \" + i);\n\n        number = scn.nextInt ();\n\n        if (i == 1 || Math.abs (number) < Math.abs (X1)) X1 = number;\n\n    }\n\n    System.out.println (\"The number near zero 0 is - \" + X1);\n\n    scn.close ();\n\n}\n"}
{"idx": 72802, "func": "public static void main (String [] args) {\n\n    Scanner scn = new Scanner (System.in);\n\n    ArrayList < Integer > integers = new ArrayList < > ();\n\n    System.out.println (\"Enter number 1\");\n\n    integers.X1 (scn.nextInt ());\n\n    System.out.println (\"Enter number 2\");\n\n    integers.X1 (scn.nextInt ());\n\n    System.out.println (\"Enter number 3\");\n\n    integers.X1 (scn.nextInt ());\n\n    System.out.println (\"Enter number 4\");\n\n    integers.X1 (scn.nextInt ());\n\n    System.out.println (\"Enter number 5\");\n\n    integers.X1 (scn.nextInt ());\n\n    Collections.sort (integers, Comparator.comparingInt (Math :: abs));\n\n    System.out.println (\"The number near zero 0 is\" + integers.get (0));\n\n}\n"}
{"idx": 72901, "func": "public static void unzip (File zipFile, File targetDirectory) throws IOException {\n\n    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (new FileInputStream (zipFile)));\n\n    try {\n\n        ZipEntry ze;\n\n        int count;\n\n        byte [] buffer = new byte [8192];\n\n        while ((ze = zis.getNextEntry ()) != null) {\n\n            File file = new File (targetDirectory, ze.getName ());\n\n            File dir = ze.isDirectory () ? file : file.getParentFile ();\n\n            if (! dir.isDirectory () && ! dir.mkdirs ()) throw new FileNotFoundException (\"Failed to ensure directory: \" + dir.getAbsolutePath ());\n\n            if (ze.isDirectory ()) continue;\n\n            FileOutputStream X1 = new FileOutputStream (file);\n\n            try {\n\n                while ((count = zis.read (buffer)) != - 1) X1.write (buffer, 0, count);\n\n            } finally {\n\n                X1.close ();\n\n            }\n\n        }\n\n    } finally {\n\n        zis.close ();\n\n    }\n\n}\n"}
{"idx": 72902, "func": "public void unzip () {\n\n    try {\n\n        FileInputStream fin = new FileInputStream (_zipFile);\n\n        ZipInputStream zin = new ZipInputStream (fin);\n\n        ZipEntry ze = null;\n\n        while ((ze = zin.getNextEntry ()) != null) {\n\n            Log.v (\"Decompress\", \"Unzipping \" + ze.getName ());\n\n            if (ze.isDirectory ()) {\n\n                _dirChecker (ze.getName ());\n\n            } else {\n\n                FileOutputStream fout = new FileOutputStream (_location + ze.getName ());\n\n                BufferedOutputStream X1 = new BufferedOutputStream (fout);\n\n                byte [] buffer = new byte [1024];\n\n                int read = 0;\n\n                while ((read = zin.read (buffer)) != - 1) {\n\n                    X1.write (buffer, 0, read);\n\n                }\n\n                X1.close ();\n\n                zin.closeEntry ();\n\n                fout.close ();\n\n            }\n\n        }\n\n        zin.close ();\n\n        Log.d (\"Unzip\", \"Unzipping complete. path :  \" + _location);\n\n    } catch (Exception e) {\n\n        Log.e (\"Decompress\", \"unzip\", e);\n\n        Log.d (\"Unzip\", \"Unzipping failed\");\n\n    }\n\n}\n"}
{"idx": 73001, "func": "public static void main (String [] args) {\n\n    String [] list1 = {\"a\", \"b\", \"c\",};\n\n    TimeUnit [] list2 = TimeUnit.values ();\n\n    int [] list3 = new int [] {1, 2, 3, 4};\n\n    int [] lengths = new int [] {list1.length, list2.length, list3.length};\n\n    for (int [] X1 : new CartesianProduct (lengths)) {\n\n        System.out.println (Arrays.toString (X1) + \" \" + list1 [X1 [0]] + \", \" + list2 [X1 [1]] + \", \" + list3 [X1 [2]]);\n\n    }\n\n}\n"}
{"idx": 73002, "func": "public static void main (String [] args) {\n\n    List < Object > lc = Arrays.X1 (new Object [] {'A', 'B', 'C', 'D'});\n\n    List < Object > lC = Arrays.X1 (new Object [] {'a', 'b', 'c'});\n\n    List < Object > li = Arrays.X1 (new Object [] {1, 2, 3, 4});\n\n    List < List < Object > > llo = new ArrayList < List < Object > > ();\n\n    llo.add (lc);\n\n    llo.add (lC);\n\n    llo.add (li);\n\n    CartesianIterable < Object > ci = new CartesianIterable < Object > (llo);\n\n    for (List < Object > lo : ci) show (lo);\n\n}\n"}
{"idx": 7301, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    X1 formatedSource = source.subSequence (start, end).toString ();\n\n    X1 destPrefix = dest.subSequence (0, dstart).toString ();\n\n    X1 destSuffix = dest.subSequence (dend, dest.length ()).toString ();\n\n    X1 result = destPrefix + formatedSource + destSuffix;\n\n    result = result.replace (\",\", \".\");\n\n    Matcher matcher = mPattern.matcher (result);\n\n    if (matcher.matches ()) {\n\n        return null;\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 7302, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    CharSequence out = super.filter (source, start, end, dest, dstart, dend);\n\n    if (out != null) {\n\n        source = out;\n\n        start = 0;\n\n        end = out.length ();\n\n    }\n\n    int len = end - start;\n\n    if (len == 0) {\n\n        return source;\n\n    }\n\n    int dlen = dest.length ();\n\n    for (int X1 = 0;\n\n    X1 < dstart; X1 ++) {\n\n        if (dest.charAt (X1) == '.') {\n\n            return (dlen - (X1 + 1) + len > digits) ? \"\" : new SpannableStringBuilder (source, start, end);\n\n        }\n\n    }\n\n    for (int X1 = start;\n\n    X1 < end; ++ X1) {\n\n        if (source.charAt (X1) == '.') {\n\n            if ((dlen - dend) + (end - (X1 + 1)) > digits) return \"\";\n\n            else break;\n\n        }\n\n    }\n\n    return new SpannableStringBuilder (source, start, end);\n\n}\n"}
{"idx": 73101, "func": "public static void main (String [] args) {\n\n    JFrame start_frame = new JFrame (\"P.D\");\n\n    int width = 1200;\n\n    int height = 800;\n\n    start_frame.setSize (width, height);\n\n    start_frame.setVisible (true);\n\n    start_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    JPanel start_panel = new JPanel ();\n\n    start_panel.setLayout (null);\n\n    start_frame.add (start_panel);\n\n    JButton start_button = new JButton (\"Start\");\n\n    X1 = 80;\n\n    buttonHeight = 20;\n\n    start_button.setBounds (new Rectangle ((width - X1) / 2, (height - buttonHeight) / 2, X1, buttonHeight));\n\n    start_button.setSize (new Dimension (X1, buttonHeight));\n\n    start_button.setFocusable (false);\n\n    start_panel.add (start_button);\n\n}\n"}
{"idx": 73102, "func": "public static void main (String [] args) {\n\n    JFrame start_frame = new JFrame (\"P.D\");\n\n    int width = 1200;\n\n    int height = 800;\n\n    start_frame.setSize (width, height);\n\n    start_frame.setVisible (true);\n\n    start_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    JPanel start_panel = new JPanel ();\n\n    start_panel.setLayout (null);\n\n    start_frame.add (start_panel);\n\n    JButton start_button = new JButton (\"Start\");\n\n    X1 = 80;\n\n    buttonHeight = 20;\n\n    start_button.setBounds (new Rectangle ((width - X1) / 2, (height - buttonHeight) / 2, X1, buttonHeight));\n\n    start_button.setSize (new Dimension (X1, buttonHeight));\n\n    start_button.setFocusable (false);\n\n    start_panel.add (start_button);\n\n}\n"}
{"idx": 73201, "func": "public void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n    HttpServletRequest req = (HttpServletRequest) request;\n\n    if (req.getHeader (\"x-dawson-nonce\") == null || req.getHeader (\"x-dawson-signature\") == null) {\n\n        X1 httpResponse = (X1) response;\n\n        httpResponse.setContentType (\"application/json\");\n\n        httpResponse.sendError (X1.SC_BAD_REQUEST, \"Required headers not specified in the request\");\n\n        return;\n\n    }\n\n    chain.doFilter (request, response);\n\n}\n"}
{"idx": 73202, "func": "public void doFilter (ServletRequest arg0, ServletResponse X1, FilterChain chain) throws IOException, ServletException {\n\n    logger.info (\"checking client id in filter\");\n\n    HttpServletRequest request = (HttpServletRequest) arg0;\n\n    String clientId = request.getHeader (\"clientId\");\n\n    if (StringUtils.isNotEmpty (clientId)) {\n\n        chain.doFilter (request, X1);\n\n    } else {\n\n        logger.error (\"client id missing.\");\n\n    }\n\n}\n"}
{"idx": 73301, "func": "public X1 getInput (X1 file) {\n\n    StringBuilder ret = new StringBuilder ();\n\n    X1 buf;\n\n    BufferedReader inFile = null;\n\n    try {\n\n        inFile = new BufferedReader (new FileReader (filename));\n\n        while (buf = inFile.readLine ()) ret.append (buf);\n\n    } catch (FileNotFoundException e) {\n\n        ret.append (\"Couldn't find \" + file);\n\n    } catch (IOException e) {\n\n        ret.append (\"There was an error reading the file.\");\n\n    } finally {\n\n        if (inFile != null) {\n\n            try {\n\n                inFile.close ();\n\n            } catch (IOException aargh) {\n\n            }\n\n        }\n\n    }\n\n    return ret.toString ();\n\n}\n"}
{"idx": 73302, "func": "public String getInput (String filename) {\n\n    BufferedReader X1 = null;\n\n    try {\n\n        X1 = new BufferedReader (new FileReader (filename));\n\n        String response = X1.readLine ();\n\n        return response;\n\n    } catch (IOException e) {\n\n    } finally {\n\n        try {\n\n            X1.close ();\n\n        } catch (IOException e) {\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 73401, "func": "@Override\n\npublic int hashCode () {\n\n    int result = 17;\n\n    result = 31 * result + (booleanField ? 1 : 0);\n\n    result = 31 * result + byteField;\n\n    result = 31 * result + charField;\n\n    result = 31 * result + shortField;\n\n    result = 31 * result + intField;\n\n    result = 31 * result + (int) (longField ^ (longField>>> 32));\n\n    result = 31 * result + Float.floatToIntBits (floatField);\n\n    long X1 = Double.doubleToLongBits (doubleField);\n\n    result = 31 * result + (int) (X1 ^ (X1>>> 32));\n\n    result = 31 * result + Arrays.hashCode (arrayField);\n\n    result = 31 * result + referenceField.hashCode ();\n\n    result = 31 * result + (nullableReferenceField == null ? 0 : nullableReferenceField.hashCode ());\n\n    return result;\n\n}\n"}
{"idx": 73402, "func": "public int hashCode () {\n\n    int hashCode = 1;\n\n    Iterator X1 = iterator ();\n\n    while (X1.hasNext ()) {\n\n        Object obj = X1.next ();\n\n        hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode ());\n\n    }\n\n    return hashCode;\n\n}\n"}
{"idx": 73501, "func": "private static String getProtocol (final String X1) {\n\n    assert X1 != null;\n\n    String protocol = null;\n\n    try {\n\n        final URI uri = new URI (X1);\n\n        if (uri.isAbsolute ()) {\n\n            protocol = uri.getScheme ();\n\n        } else {\n\n            final URL url = new URL (X1);\n\n            protocol = url.getProtocol ();\n\n        }\n\n    } catch (final Exception e) {\n\n        if (X1.startsWith (\"//\")) {\n\n            throw new IllegalArgumentException (\"Relative context: \" + X1);\n\n        } else {\n\n            final File file = new File (X1);\n\n            protocol = getProtocol (file);\n\n        }\n\n    }\n\n    return protocol;\n\n}\n"}
{"idx": 73502, "func": "private static String getProtocol (final File X1) {\n\n    String result;\n\n    try {\n\n        result = X1.toURI ().toURL ().getProtocol ();\n\n    } catch (Exception e) {\n\n        result = \"unknown\";\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 73601, "func": "public void findPrevLine () throws IOException {\n\n    currentLineEnd = currentLineStart;\n\n    if (currentLineEnd == 0) {\n\n        currentLineEnd = - 1;\n\n        currentLineStart = - 1;\n\n        currentPos = - 1;\n\n        return;\n\n    }\n\n    long X1 = currentLineStart - 1;\n\n    while (true) {\n\n        X1 --;\n\n        if (X1 < 0) {\n\n            break;\n\n        }\n\n        in.seek (X1);\n\n        int readByte = in.readByte ();\n\n        if (readByte == 0xA && X1 != lastPosInFile) {\n\n            break;\n\n        }\n\n    }\n\n    currentLineStart = X1 + 1;\n\n    currentPos = currentLineStart;\n\n}\n"}
{"idx": 73602, "func": "private void findPrevLine () throws IOException {\n\n    if (lastChar == - 1) {\n\n        in.seek (X1);\n\n        lastChar = in.readByte ();\n\n    }\n\n    currentLineEnd = currentLineStart;\n\n    if (currentLineEnd == 0) {\n\n        currentLineEnd = - 1;\n\n        currentLineStart = - 1;\n\n        currentPos = - 1;\n\n        return;\n\n    }\n\n    long filePointer = currentLineStart - 1;\n\n    while (true) {\n\n        filePointer --;\n\n        if (filePointer < 0) {\n\n            break;\n\n        }\n\n        in.seek (filePointer);\n\n        int readByte = in.readByte ();\n\n        if (readByte == 0xA && filePointer != X1) {\n\n            break;\n\n        }\n\n    }\n\n    currentLineStart = filePointer + 1;\n\n    currentPos = currentLineStart;\n\n}\n"}
{"idx": 73701, "func": "public int read () throws IOException {\n\n    if (currentPos < currentLineEnd) {\n\n        in.seek (currentPos ++);\n\n        int X1 = in.X1 ();\n\n        return X1;\n\n    } else if (currentPos < 0) {\n\n        return - 1;\n\n    } else {\n\n        findPrevLine ();\n\n        return read ();\n\n    }\n\n}\n"}
{"idx": 73702, "func": "public int read () throws IOException {\n\n    if (currentPos < currentLineEnd) {\n\n        X1.seek (currentPos ++);\n\n        int readByte = X1.readByte ();\n\n        return readByte;\n\n    } else if (currentPos > lastPosInFile && currentLineStart < currentLineEnd) {\n\n        findPrevLine ();\n\n        if (lastChar != '\\n' && lastChar != '\\r') {\n\n            return '\\n';\n\n        } else {\n\n            return read ();\n\n        }\n\n    } else if (currentPos < 0) {\n\n        return - 1;\n\n    } else {\n\n        findPrevLine ();\n\n        return read ();\n\n    }\n\n}\n"}
{"idx": 73801, "func": "public int read () throws IOException {\n\n    if (currentPos < currentLineEnd) {\n\n        in.seek (currentPos ++);\n\n        int X1 = in.X1 ();\n\n        return X1;\n\n    } else if (currentPos < 0) {\n\n        return - 1;\n\n    } else {\n\n        findPrevLine ();\n\n        return read ();\n\n    }\n\n}\n"}
{"idx": 73802, "func": "public int read () throws IOException {\n\n    if (currentFilePos <= 0 && currentBufferPos < 0 && currentLineReadPos < 0) {\n\n        return - 1;\n\n    }\n\n    if (! X1) {\n\n        fillLineBuffer ();\n\n    }\n\n    if (X1) {\n\n        if (currentLineReadPos == 0) {\n\n            X1 = false;\n\n        }\n\n        return currentLine [currentLineReadPos --];\n\n    }\n\n    return 0;\n\n}\n"}
{"idx": 73901, "func": "public int read () throws IOException {\n\n    if (currentPos < currentLineEnd) {\n\n        X1.seek (currentPos ++);\n\n        int readByte = X1.readByte ();\n\n        return readByte;\n\n    } else if (currentPos > lastPosInFile && currentLineStart < currentLineEnd) {\n\n        findPrevLine ();\n\n        if (lastChar != '\\n' && lastChar != '\\r') {\n\n            return '\\n';\n\n        } else {\n\n            return read ();\n\n        }\n\n    } else if (currentPos < 0) {\n\n        return - 1;\n\n    } else {\n\n        findPrevLine ();\n\n        return read ();\n\n    }\n\n}\n"}
{"idx": 73902, "func": "public int read () throws IOException {\n\n    if (currentFilePos <= 0 && currentBufferPos < 0 && currentLineReadPos < 0) {\n\n        return - 1;\n\n    }\n\n    if (! X1) {\n\n        fillLineBuffer ();\n\n    }\n\n    if (X1) {\n\n        if (currentLineReadPos == 0) {\n\n            X1 = false;\n\n        }\n\n        return currentLine [currentLineReadPos --];\n\n    }\n\n    return 0;\n\n}\n"}
{"idx": 74001, "func": "public Component getTableCellEditorComponent (JTable table, Object value, boolean isSelected, int row, int column) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            System.out.println (\"run\");\n\n            popup.setText (currentText);\n\n            Point X1 = editorComponent.getLocationOnScreen ();\n\n            popup.setLocation (X1.x, X1.y + editorComponent.getSize ().height);\n\n            popup.show ();\n\n            fireEditingStopped ();\n\n        }}\n\n    );\n\n    currentText = value.toString ();\n\n    editorComponent.setText (currentText);\n\n    return editorComponent;\n\n}\n"}
{"idx": 74002, "func": "public Component getTableCellEditorComponent (JTable table, Object value, boolean isSelected, int row, int column) {\n\n    file = value.toString ();\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        public void run () {\n\n            X1.setSelectedFile (new File (file));\n\n            if (X1.showOpenDialog (button) == JFileChooser.APPROVE_OPTION) {\n\n                file = X1.getSelectedFile ().getAbsolutePath ();\n\n            }\n\n            fireEditingStopped ();\n\n        }}\n\n    );\n\n    button.setText (file);\n\n    return button;\n\n}\n"}
{"idx": 7401, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int X1, int dend) {\n\n    String formatedSource = source.subSequence (start, end).toString ();\n\n    String destPrefix = dest.subSequence (0, X1).toString ();\n\n    String destSuffix = dest.subSequence (dend, dest.length ()).toString ();\n\n    String result = destPrefix + formatedSource + destSuffix;\n\n    result = result.replace (\",\", \".\");\n\n    Matcher matcher = mPattern.matcher (result);\n\n    if (matcher.matches ()) {\n\n        return null;\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 7402, "func": "public CharSequence filter (CharSequence X1, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String lsStart = \"\";\n\n    String lsInsert = \"\";\n\n    String lsEnd = \"\";\n\n    String lsText = \"\";\n\n    Log.d (\"debug\", moPattern.toString ());\n\n    Log.d (\"debug\", \"source: \" + X1 + \", start: \" + start + \", end:\" + end + \", dest: \" + dest + \", dstart: \" + dstart + \", dend: \" + dend);\n\n    lsText = dest.toString ();\n\n    if (lsText.length () > 0) {\n\n        lsStart = lsText.substring (0, dstart);\n\n        Log.d (\"debug\", \"lsStart : \" + lsStart);\n\n        if (X1 != \"\") {\n\n            lsInsert = X1.toString ();\n\n            Log.d (\"debug\", \"lsInsert: \" + lsInsert);\n\n        }\n\n        lsEnd = lsText.substring (dend);\n\n        Log.d (\"debug\", \"lsEnd   : \" + lsEnd);\n\n        lsText = lsStart + lsInsert + lsEnd;\n\n        Log.d (\"debug\", \"lsText  : \" + lsText);\n\n    }\n\n    Matcher loMatcher = moPattern.matcher (lsText);\n\n    Log.d (\"debug\", \"loMatcher.matches(): \" + loMatcher.matches () + \", lsText: \" + lsText);\n\n    if (! loMatcher.matches ()) {\n\n        return \"\";\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 74101, "func": "public static void main (String [] args) {\n\n    String [] columnNames = {\"Item\", \"Description\"};\n\n    Object [] [] data = {{\"Item 1\", \"Description of Item 1\"}, {\"Item 2\", \"Description of Item 2\"}, {\"Item 3\", \"Description of Item 3\"}};\n\n    JTable table = new JTable (data, columnNames);\n\n    table.getColumnModel ().X1 (1).setPreferredWidth (300);\n\n    table.setPreferredScrollableViewportSize (table.getPreferredSize ());\n\n    JScrollPane scrollPane = new JScrollPane (table);\n\n    TablePopupEditor popupEditor = new TablePopupEditor ();\n\n    table.getColumnModel ().X1 (1).setCellEditor (popupEditor);\n\n    JFrame frame = new JFrame (\"Popup Editor Test\");\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    frame.add (new JTextField (), BorderLayout.NORTH);\n\n    frame.add (scrollPane);\n\n    frame.pack ();\n\n    frame.setLocationRelativeTo (null);\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 74102, "func": "public static void main (String st []) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 td = new X1 ();\n\n            td.prepareAndShowGUI ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 74201, "func": "static public boolean deleteDirectory (File X1) {\n\n    if (X1.exists ()) {\n\n        File [] files = X1.listFiles ();\n\n        for (int i = 0;\n\n        i < files.length; i ++) {\n\n            if (files [i].isDirectory ()) {\n\n                deleteDirectory (files [i]);\n\n            } else {\n\n                files [i].delete ();\n\n            }\n\n        }\n\n    }\n\n    return (X1.delete ());\n\n}\n"}
{"idx": 74202, "func": "public static void deleteDirectory (String directoryFilePath) throws X1 {\n\n    Path directory = Paths.get (directoryFilePath);\n\n    if (Files.exists (directory)) {\n\n        Files.walkFileTree (directory, new SimpleFileVisitor < Path > () {\n\n            @Override\n\n            public FileVisitResult visitFile (Path path, BasicFileAttributes basicFileAttributes) throws X1 {\n\n                Files.delete (path);\n\n                return FileVisitResult.CONTINUE;\n\n            }@Override\n\n            public FileVisitResult postVisitDirectory (Path directory, X1 ioException) throws X1 {\n\n                Files.delete (directory);\n\n                return FileVisitResult.CONTINUE;\n\n            }}\n\n        );\n\n    }\n\n}\n"}
{"idx": 74301, "func": "public static long factorial (int n) {\n\n    try {\n\n        System.out.X1 (\"factorial(\" + n + \")\");\n\n        if (n == 1) {\n\n            System.out.X1 (\"return 1\");\n\n            return 1;\n\n        }\n\n        return n * factorial (n - 1);\n\n    } finally {\n\n        System.out.X1 (\"return \" + n);\n\n    }\n\n}\n"}
{"idx": 74302, "func": "private static long factorial (int n, int depth) {\n\n    String spaces = repeat (' ', depth);\n\n    System.out.print (spaces);\n\n    System.out.X1 (\"factorial(\" + n + \")\");\n\n    if (n <= 1) {\n\n        System.out.X1 (spaces + \" return 1\");\n\n        return 1;\n\n    }\n\n    long fac = factorial (n - 1, depth + 1);\n\n    System.out.print (spaces);\n\n    System.out.printf (\"return %d * %d = %d%n\", n, fac, n * fac);\n\n    return n * fac;\n\n}\n"}
{"idx": 74401, "func": "public static void main (String args []) throws Exception {\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"DATE INFO\");\n\n    printCurrentTime ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"JVM COMMAND LINE ARGUMENTS\");\n\n    printCommandLineArguments ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"ENVIRONMENT\");\n\n    printSystemEnvironment ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"SYSTEM PROPERTIES\");\n\n    printSystemProperties ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"CLASS LOADER\");\n\n    printClassLoaderInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"OPERATING SYSTEM\");\n\n    printOSInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"MEMORY\");\n\n    printRuntimeMemory ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"CPU\");\n\n    printCPUUsage ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"DISK\");\n\n    printDiskInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"NETWORK\");\n\n    printNetworkInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"SECURITY\");\n\n    printSecurityInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"LOG\");\n\n    printLoggingInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"KEY MANAGER\");\n\n    printKeyManagerInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"DISPLAY DEVICES\");\n\n    printDisplayInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"FONTS\");\n\n    printFontsInfo ();\n\n    out.X1 (\"\");\n\n    out.X1 (\"****************************************\");\n\n    out.X1 (\"LOCALES\");\n\n    printLocaleInfo ();\n\n}\n"}
{"idx": 74402, "func": "public static void main (String [] args) {\n\n    Runnable r = () -> {\n\n        X1 mediaTypes = new X1 ();\n\n        JPanel p = new JPanel ();\n\n        mediaTypes.createGui (p);\n\n        JOptionPane.showMessageDialog (null, p);\n\n    };\n\n    SwingUtilities.invokeLater (r);\n\n}\n"}
{"idx": 74501, "func": "public static int evenDigits (int n) {\n\n    int res = 0;\n\n    int mag = 0;\n\n    while (n > 9) {\n\n        int X1 = n % 10;\n\n        n /= 10;\n\n        if (X1 % 2 == 0) {\n\n            res += Math.pow (10, mag) * X1;\n\n            mag ++;\n\n        }\n\n    }\n\n    return res;\n\n}\n"}
{"idx": 74502, "func": "public static int evenDigits (int X1) {\n\n    if ((X1 & 1) != 0) {\n\n        return evenDigits (X1 / 10);\n\n    }\n\n    if (X1 < 10) {\n\n        return X1;\n\n    }\n\n    return X1 % 10 + evenDigits (X1 / 10) * 10;\n\n}\n"}
{"idx": 74601, "func": "public final void mouseReleased (MouseEvent e) {\n\n    X1.mouseReleased (e);\n\n    if (pressed != null) {\n\n        if (getDragDistance (e) < MAX_CLICK_DISTANCE) {\n\n            MouseEvent clickEvent = new MouseEvent ((Component) pressed.getSource (), MouseEvent.MOUSE_CLICKED, e.getWhen (), pressed.getModifiers (), pressed.getX (), pressed.getY (), pressed.getXOnScreen (), pressed.getYOnScreen (), pressed.getClickCount (), pressed.isPopupTrigger (), pressed.getButton ());\n\n            X1.mouseClicked (clickEvent);\n\n        }\n\n        pressed = null;\n\n    }\n\n}\n"}
{"idx": 74602, "func": "public void mouseReleased (int mod, Point loc) {\n\n    if (pressLocation != null && X1 != null) {\n\n        pressLocation = null;\n\n    } else if (X1 != null) {\n\n    } else {\n\n    }\n\n    pressLocation = null;\n\n    X1 = null;\n\n}\n"}
{"idx": 74701, "func": "static int countClamps (int [] arr) {\n\n    int result = 0;\n\n    for (int X1 = 1;\n\n    X1 < arr.length; ++ X1) {\n\n        if (arr [X1] == arr [X1 - 1] && (X1 == arr.length - 1 || arr [X1] != arr [X1 + 1])) {\n\n            ++ result;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 74702, "func": "static int countClamps (int [] X1) {\n\n    int result = 0;\n\n    int prev = 0;\n\n    boolean same = false;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (i == 0) {\n\n            prev = X1 [i];\n\n        } else {\n\n            if (X1 [i] == prev) {\n\n                if (! same) {\n\n                    result ++;\n\n                    same = true;\n\n                }\n\n            } else {\n\n                prev = X1 [i];\n\n                same = false;\n\n            }\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 74801, "func": "public void actionPerformed (ActionEvent e) {\n\n    int index = list.getSelectedIndex ();\n\n    X1.remove (index);\n\n    int size = X1.getSize ();\n\n    if (size == 0) {\n\n        fireButton.setEnabled (false);\n\n    } else {\n\n        if (index == X1.getSize ()) {\n\n            index --;\n\n        }\n\n        list.setSelectedIndex (index);\n\n        list.ensureIndexIsVisible (index);\n\n    }\n\n}\n"}
{"idx": 74802, "func": "public void actionPerformed (ActionEvent e) {\n\n    String name = employeeName.getText ();\n\n    if (name.equals (\"\") || alreadyInList (name)) {\n\n        Toolkit.getDefaultToolkit ().beep ();\n\n        employeeName.requestFocusInWindow ();\n\n        employeeName.selectAll ();\n\n        return;\n\n    }\n\n    int X1 = list.getSelectedIndex ();\n\n    if (X1 == - 1) {\n\n        X1 = 0;\n\n    } else {\n\n        X1 ++;\n\n    }\n\n    listModel.insertElementAt (employeeName.getText (), X1);\n\n    employeeName.requestFocusInWindow ();\n\n    employeeName.setText (\"\");\n\n    list.setSelectedIndex (X1);\n\n    list.ensureIndexIsVisible (X1);\n\n}\n"}
{"idx": 74901, "func": "public void actionPerformed (ActionEvent e) {\n\n    ImageIcon saveIcon = new ImageIcon (\"save-icon.png\");\n\n    int askSave = X1.showConfirmDialog (null, \"Save current image?\", \"\", X1.YES_NO_OPTION, X1.QUESTION_MESSAGE, saveIcon);\n\n    if (askSave == X1.YES_OPTION) {\n\n        saveImage ();\n\n        System.exit (0);\n\n    } else {\n\n        System.exit (0);\n\n    }\n\n}\n"}
{"idx": 74902, "func": "public void actionPerformed (ActionEvent e) {\n\n    ImageIcon widthIcon = new ImageIcon (\"LR-arrows.png\");\n\n    String scaleWidth = (String) JOptionPane.showInputDialog (null, \"What should the new width be?\", \"\", JOptionPane.QUESTION_MESSAGE, widthIcon, null, null);\n\n    ImageIcon heightIcon = new ImageIcon (\"UD-arrows.png\");\n\n    String scaleHeight = (String) JOptionPane.showInputDialog (null, \"What should the new height be?\", \"\", JOptionPane.QUESTION_MESSAGE, widthIcon, null, null);\n\n    double x = Double.parseDouble (scaleWidth);\n\n    double y = Double.parseDouble (scaleHeight);\n\n    int newWidth = (int) x;\n\n    int X1 = (int) y;\n\n    frame.setSize (newWidth, X1);\n\n    scale (newWidth, X1);\n\n}\n"}
{"idx": 75001, "func": "public void actionPerformed (ActionEvent e) {\n\n    ImageIcon saveIcon = new ImageIcon (\"save-icon.png\");\n\n    int askSave = X1.showConfirmDialog (null, \"Save current image?\", \"\", X1.YES_NO_OPTION, X1.QUESTION_MESSAGE, saveIcon);\n\n    if (askSave == X1.YES_OPTION) {\n\n        saveImage ();\n\n        Picture p = new Picture ();\n\n        imageLabel.setIcon (new ImageIcon (image));\n\n        frame.setSize (width (), height ());\n\n    } else {\n\n        Picture p = new Picture ();\n\n        imageLabel.setIcon (new ImageIcon (image));\n\n        frame.setSize (width (), height ());\n\n    }\n\n}\n"}
{"idx": 75002, "func": "public void actionPerformed (ActionEvent e) {\n\n    ImageIcon widthIcon = new ImageIcon (\"LR-arrows.png\");\n\n    X1 scaleWidth = (X1) JOptionPane.showInputDialog (null, \"What should the new width be?\", \"\", JOptionPane.QUESTION_MESSAGE, widthIcon, null, null);\n\n    ImageIcon heightIcon = new ImageIcon (\"UD-arrows.png\");\n\n    X1 scaleHeight = (X1) JOptionPane.showInputDialog (null, \"What should the new height be?\", \"\", JOptionPane.QUESTION_MESSAGE, widthIcon, null, null);\n\n    double x = Double.parseDouble (scaleWidth);\n\n    double y = Double.parseDouble (scaleHeight);\n\n    int newWidth = (int) x;\n\n    int newHeight = (int) y;\n\n    frame.setSize (newWidth, newHeight);\n\n    scale (newWidth, newHeight);\n\n}\n"}
{"idx": 7501, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int X1, int dend) {\n\n    String formatedSource = source.subSequence (start, end).toString ();\n\n    String destPrefix = dest.subSequence (0, X1).toString ();\n\n    String destSuffix = dest.subSequence (dend, dest.length ()).toString ();\n\n    String result = destPrefix + formatedSource + destSuffix;\n\n    result = result.replace (\",\", \".\");\n\n    Matcher matcher = mPattern.matcher (result);\n\n    if (matcher.matches ()) {\n\n        return null;\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 7502, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int X1) {\n\n    int dotPos = - 1;\n\n    int len = dest.length ();\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        char c = dest.charAt (i);\n\n        if (c == '.' || c == ',') {\n\n            dotPos = i;\n\n            break;\n\n        }\n\n    }\n\n    if (dotPos >= 0) {\n\n        if (source.equals (\".\") || source.equals (\",\")) {\n\n            return \"\";\n\n        }\n\n        if (X1 <= dotPos) {\n\n            return null;\n\n        }\n\n        if (len - dotPos > decimalDigits) {\n\n            return \"\";\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 75101, "func": "public static void main (String [] args) throws Exception {\n\n    BigInteger bad1 = new BigInteger (X1);\n\n    BigInteger good1 = new BigInteger (1, X1);\n\n    byte [] augmentedBytes = new byte [X1.length + 1];\n\n    System.arraycopy (X1, 0, augmentedBytes, 1, X1.length);\n\n    BigInteger good2 = new BigInteger (augmentedBytes);\n\n    System.out.println (bad1);\n\n    System.out.println (good1);\n\n    System.out.println (good1.equals (good2));\n\n    System.out.println (good1.isProbablePrime (50));\n\n}\n"}
{"idx": 75102, "func": "public static void main (String [] args) throws Exception {\n\n    KeyPairGenerator hostKeyGen = KeyPairGenerator.getInstance (\"DH\");\n\n    BigInteger p = new BigInteger (modp2048, 16);\n\n    BigInteger X1 = BigInteger.valueOf (2L);\n\n    System.out.println (\"p bits: \" + p.bitLength ());\n\n    System.out.println (\"g bits: \" + X1.bitLength ());\n\n    DHParameterSpec dhGrp14KeySpec = new DHParameterSpec (p, p);\n\n    hostKeyGen.initialize (dhGrp14KeySpec);\n\n    System.out.println (\"Creating Host DH private key...\");\n\n    KeyPair hostKey = hostKeyGen.generateKeyPair ();\n\n    System.out.println (\"Initiating host side Schannel...\");\n\n    KeyAgreement schannel = KeyAgreement.getInstance (\"DH\");\n\n    schannel.init (hostKey.getPrivate ());\n\n}\n"}
{"idx": 75201, "func": "public static void main (String [] args) throws Exception {\n\n    ObservableList < Integer > olist = new ObservableList < > ();\n\n    olist.getObservable ().subscribe (System.out :: println);\n\n    olist.X1 (1);\n\n    Thread.sleep (1000);\n\n    olist.X1 (2);\n\n    Thread.sleep (1000);\n\n    olist.X1 (3);\n\n}\n"}
{"idx": 75202, "func": "public static void main (String [] args) {\n\n    List < Integer > initialNumbers = new ArrayList < Integer > ();\n\n    initialNumbers.add (1);\n\n    initialNumbers.add (2);\n\n    Observable < Integer > observableInitial = Observable.from (initialNumbers);\n\n    ReplaySubject < Integer > subject = ReplaySubject.create ();\n\n    Observable < Integer > X1 = Observable.merge (observableInitial, subject);\n\n    X1.subscribe (System.out :: println);\n\n    for (int i = 0;\n\n    i < 100; ++ i) {\n\n        subject.onNext (i);\n\n    }\n\n}\n"}
{"idx": 75301, "func": "public String getContactName (final String phoneNumber) {\n\n    Uri uri;\n\n    String [] projection;\n\n    mBaseUri = Contacts.Phones.CONTENT_FILTER_URL;\n\n    projection = new String [] {android.provider.Contacts.People.NAME};\n\n    try {\n\n        X1 < ? > c = X1.forName (\"android.provider.ContactsContract$PhoneLookup\");\n\n        mBaseUri = (Uri) c.getField (\"CONTENT_FILTER_URI\").get (mBaseUri);\n\n        projection = new String [] {\"display_name\"};\n\n    } catch (Exception e) {\n\n    }\n\n    uri = Uri.withAppendedPath (mBaseUri, Uri.encode (phoneNumber));\n\n    Cursor cursor = this.getContentResolver ().query (uri, projection, null, null, null);\n\n    String contactName = \"\";\n\n    if (cursor.moveToFirst ()) {\n\n        contactName = cursor.getString (0);\n\n    }\n\n    cursor.close ();\n\n    cursor = null;\n\n    return contactName;\n\n}\n"}
{"idx": 75302, "func": "private String getContactName (Context context, String number) {\n\n    String name = null;\n\n    String [] projection = new String [] {ContactsContract.PhoneLookup.DISPLAY_NAME, ContactsContract.PhoneLookup._ID};\n\n    Uri contactUri = Uri.withAppendedPath (ContactsContract.PhoneLookup.CONTENT_FILTER_URI, Uri.encode (number));\n\n    Cursor cursor = context.getContentResolver ().query (contactUri, projection, null, null, null);\n\n    if (cursor != null) {\n\n        if (cursor.moveToFirst ()) {\n\n            name = cursor.getString (cursor.getColumnIndex (ContactsContract.PhoneLookup.DISPLAY_NAME));\n\n            X1.v (TAG, \"Started uploadcontactphoto: Contact Found @ \" + number);\n\n            X1.v (TAG, \"Started uploadcontactphoto: Contact name  = \" + name);\n\n        } else {\n\n            X1.v (TAG, \"Contact Not Found @ \" + number);\n\n        }\n\n        cursor.close ();\n\n    }\n\n    return name;\n\n}\n"}
{"idx": 75401, "func": "public static void main (String [] args) {\n\n    int [] X1 = new int [10];\n\n    X1 [0] = 2;\n\n    for (int i = 1;\n\n    i < X1.length; i ++) X1 [i] = X1 [i - 1] + 2;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) System.out.print (X1 [i] + \" \");\n\n    System.out.println ();\n\n    for (int i = 0;\n\n    i < X1.length; i ++) System.out.print (X1 [9 - i] + \" \");\n\n}\n"}
{"idx": 75402, "func": "public static void main (String [] args) throws Exception {\n\n    int [] values = new int [10];\n\n    values [0] = 2;\n\n    System.X1.print (values [0]);\n\n    for (int i = 1;\n\n    i < values.length; i ++) {\n\n        values [i] = values [i - 1] + 2;\n\n        System.X1.print (\" \" + values [i]);\n\n    }\n\n}\n"}
{"idx": 75501, "func": "public static void main (X1 [] args) {\n\n    int nth = Integer.parseInt (args [0]);\n\n    Queue < X1 > q = new LinkedList < > ();\n\n    BufferedReader bufferRead = new BufferedReader (new InputStreamReader (System.in));\n\n    try {\n\n        X1 s = \"\";\n\n        while (! \"/\".equals ((s = bufferRead.readLine ()))) {\n\n            q.add (s);\n\n        }\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    X1 polled = \"\";\n\n    int count = 1;\n\n    while ((polled = q.poll ()) != null) {\n\n        if (count == nth) {\n\n            System.out.println (nth + \" th string is \" + polled);\n\n        }\n\n        count ++;\n\n    }\n\n}\n"}
{"idx": 75502, "func": "public static void main (String [] args) {\n\n    Integer n = Integer.parseInt (args [0]);\n\n    Queue < Integer > X1 = new Queue < Integer > ();\n\n    while (! StdIn.isEmpty ()) {\n\n        X1.enqueue (StdIn.readInt ());\n\n    }\n\n    while (X1.size () > n) {\n\n        X1.dequeue ();\n\n    }\n\n    StdOut.println (X1.peek ().toString ());\n\n}\n"}
{"idx": 75601, "func": "public void start (Stage primaryStage) throws Exception {\n\n    AnchorPane root = new AnchorPane ();\n\n    root.setStyle (\"-fx-padding:20;-fx-background-color:dodgerblue;\");\n\n    final X1 textArea = new X1 ();\n\n    AnchorPane.setTopAnchor (textArea, 10.0);\n\n    AnchorPane.setLeftAnchor (textArea, 10.0);\n\n    AnchorPane.setRightAnchor (textArea, 10.0);\n\n    root.getChildren ().add (textArea);\n\n    primaryStage.setScene (new Scene (root, 400, 300));\n\n    primaryStage.show ();\n\n    ScrollBar scrollBar = lookupVerticalScrollBar (textArea);\n\n    scrollBar.setOpacity (0.0);\n\n    scrollBar.visibleProperty ().addListener (new ChangeListener < Boolean > () {\n\n        @Override\n\n        public void changed (ObservableValue < ? extends Boolean > source, Boolean wasVisible, Boolean isVisible) {\n\n            if (isVisible) {\n\n                textArea.setPrefRowCount (textArea.getPrefRowCount () + 1);\n\n                textArea.requestLayout ();\n\n            }\n\n        }}\n\n    );\n\n}\n"}
{"idx": 75602, "func": "public void start (Stage primaryStage) {\n\n    final TextArea textArea = new TextArea ();\n\n    textArea.setPrefSize (200, 40);\n\n    textArea.setWrapText (true);\n\n    textHolder.textProperty ().bind (textArea.textProperty ());\n\n    textHolder.layoutBoundsProperty ().addListener (new ChangeListener < Bounds > () {\n\n        @Override\n\n        public void changed (ObservableValue < ? extends Bounds > observable, Bounds oldValue, Bounds newValue) {\n\n            if (X1 != newValue.getHeight ()) {\n\n                System.out.println (\"newValue = \" + newValue.getHeight ());\n\n                X1 = newValue.getHeight ();\n\n                textArea.setPrefHeight (textHolder.getLayoutBounds ().getHeight () + 20);\n\n            }\n\n        }}\n\n    );\n\n    Group root = new Group (textArea);\n\n    Scene scene = new Scene (root, 300, 250);\n\n    primaryStage.setScene (scene);\n\n    primaryStage.show ();\n\n}\n"}
{"idx": 75701, "func": "public static void main (String [] args) throws Exception {\n\n    NestedMap < String, Integer > test = new NestedMap < > ();\n\n    test.put (\"a\").put (\"b\").put (\"c\", 12);\n\n    Map.Entry < String, Integer > foo = test.put (\"a\").put (\"b\").put (\"d\", 12);\n\n    test.put (\"b\", 14);\n\n    ObjectMapper mapper = new ObjectMapper ();\n\n    System.out.X1 (mapper.writeValueAsString (test));\n\n    foo.setValue (99);\n\n    System.out.X1 (mapper.writeValueAsString (test));\n\n    System.out.X1 (test.get (\"a\").get (\"b\").getValue (\"d\"));\n\n}\n"}
{"idx": 75702, "func": "public static final void main (String...args) {\n\n    Node tree = new Node ();\n\n    tree.X1 = \"root\";\n\n    Node [] n = {new Node (), new Node ()};\n\n    tree.nodes = n;\n\n    tree.nodes [0].X1 = \"leftish\";\n\n    tree.nodes [1].X1 = \"rightish-leafy\";\n\n    Node [] nn = {new Node ()};\n\n    tree.nodes [0].nodes = nn;\n\n    tree.nodes [0].nodes [0].X1 = \"off-leftish-leaf\";\n\n    System.out.println (Arrays.toString (list (tree, args [0]).toArray ()));\n\n}\n"}
{"idx": 75801, "func": "public static void main (String [] args) throws Exception {\n\n    NestedMap < String, Integer > test = new NestedMap < > ();\n\n    test.put (\"a\").put (\"b\").put (\"c\", 12);\n\n    Map.Entry < String, Integer > foo = test.put (\"a\").put (\"b\").put (\"d\", 12);\n\n    test.put (\"b\", 14);\n\n    ObjectMapper X1 = new ObjectMapper ();\n\n    System.out.println (X1.writeValueAsString (test));\n\n    foo.setValue (99);\n\n    System.out.println (X1.writeValueAsString (test));\n\n    System.out.println (test.get (\"a\").get (\"b\").getValue (\"d\"));\n\n}\n"}
{"idx": 75802, "func": "public static void main (String [] args) {\n\n    BinaryTreeWithoutRecursion < Integer > X1 = new BinaryTreeWithoutRecursion < > ();\n\n    X1.insert (1);\n\n    X1.insert (2);\n\n    X1.insert (3);\n\n    X1.insert (4);\n\n    X1.insert (5);\n\n    X1.insert (6);\n\n    X1.insert (7);\n\n    X1.inOrderPrint ();\n\n}\n"}
{"idx": 75901, "func": "public static final void main (String...args) {\n\n    Node tree = new Node ();\n\n    tree.X1 = \"root\";\n\n    Node [] n = {new Node (), new Node ()};\n\n    tree.nodes = n;\n\n    tree.nodes [0].X1 = \"leftish\";\n\n    tree.nodes [1].X1 = \"rightish-leafy\";\n\n    Node [] nn = {new Node ()};\n\n    tree.nodes [0].nodes = nn;\n\n    tree.nodes [0].nodes [0].X1 = \"off-leftish-leaf\";\n\n    System.out.println (Arrays.toString (list (tree, args [0]).toArray ()));\n\n}\n"}
{"idx": 75902, "func": "public static void main (String [] args) {\n\n    BinaryTreeWithoutRecursion < Integer > ls = new BinaryTreeWithoutRecursion < > ();\n\n    ls.X1 (1);\n\n    ls.X1 (2);\n\n    ls.X1 (3);\n\n    ls.X1 (4);\n\n    ls.X1 (5);\n\n    ls.X1 (6);\n\n    ls.X1 (7);\n\n    ls.inOrderPrint ();\n\n}\n"}
{"idx": 76001, "func": "static void investigate (X1 t, X1...typeArgs) {\n\n    if (t == null) return;\n\n    if (t instanceof Class < ? >) {\n\n        investigate ((Class < ? >) t, typeArgs);\n\n    } else if (t instanceof ParameterizedType) {\n\n        investigate ((ParameterizedType) t, typeArgs);\n\n    }\n\n}\n"}
{"idx": 76002, "func": "static void investigate (ParameterizedType p, Type...typeArgs) {\n\n    final Class < ? > c = (Class < ? >) p.getRawType ();\n\n    final StringBuilder b = new StringBuilder (c.getName ());\n\n    b.X1 ('<');\n\n    Type [] localArgs = p.getActualTypeArguments ();\n\n    if (typeArgs != null && typeArgs.length > 0) {\n\n        int i = 0, nextTypeArg = 0;\n\n        for (Type local : localArgs) {\n\n            if (local instanceof ParameterizedType) {\n\n                ParameterizedType localP = (ParameterizedType) local;\n\n                b.X1 (localP.getRawType ()).X1 ('<');\n\n                b.X1 (typeArgs [nextTypeArg ++]);\n\n                b.X1 ('>');\n\n            } else if (local instanceof TypeVariable) {\n\n                localArgs [nextTypeArg] = typeArgs [nextTypeArg];\n\n                b.X1 (localArgs [nextTypeArg]);\n\n                nextTypeArg ++;\n\n            } else {\n\n                b.X1 (local.toString ());\n\n            }\n\n            b.X1 (\", \");\n\n            i ++;\n\n        }\n\n        if (typeArgs.length > 0) {\n\n            b.delete (b.length () - 2, b.length ());\n\n        }\n\n        b.X1 ('>');\n\n    } else {\n\n        String args = Arrays.toString (localArgs);\n\n        b.X1 (args.substring (1, args.length () - 1)).X1 ('>');\n\n    }\n\n    System.out.println (b);\n\n    investigate (c, localArgs);\n\n}\n"}
{"idx": 7601, "func": "public CharSequence X1 (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    CharSequence out = super.X1 (source, start, end, dest, dstart, dend);\n\n    if (out != null) {\n\n        source = out;\n\n        start = 0;\n\n        end = out.length ();\n\n    }\n\n    int len = end - start;\n\n    if (len == 0) {\n\n        return source;\n\n    }\n\n    int dlen = dest.length ();\n\n    for (int i = 0;\n\n    i < dstart; i ++) {\n\n        if (dest.charAt (i) == '.') {\n\n            return (dlen - (i + 1) + len > digits) ? \"\" : new SpannableStringBuilder (source, start, end);\n\n        }\n\n    }\n\n    for (int i = start;\n\n    i < end; ++ i) {\n\n        if (source.charAt (i) == '.') {\n\n            if ((dlen - dend) + (end - (i + 1)) > digits) return \"\";\n\n            else break;\n\n        }\n\n    }\n\n    return new SpannableStringBuilder (source, start, end);\n\n}\n"}
{"idx": 7602, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String replacement = source.subSequence (start, end).toString ();\n\n    String X1 = dest.subSequence (0, dstart).toString () + replacement + dest.subSequence (dend, dest.length ()).toString ();\n\n    Matcher matcher = mPattern.matcher (X1);\n\n    if (matcher.matches ()) return null;\n\n    if (TextUtils.isEmpty (source)) return dest.subSequence (dstart, dend);\n\n    else return \"\";\n\n}\n"}
{"idx": 76101, "func": "public static void main (final String [] args) {\n\n    final JFrame f = new JFrame ();\n\n    f.setBounds (200, 200, 400, 400);\n\n    f.setVisible (true);\n\n    {\n\n        try {\n\n            Thread.sleep (2345);\n\n        } catch (final InterruptedException ignore) {\n\n        }\n\n    } {\n\n        final JTextField t = new JTextField (\"Hello World!\");\n\n        t.addFocusListener (new FocusListener () {\n\n            @X1\n\n            public void focusLost (final FocusEvent pE) {\n\n            }@X1\n\n            public void focusGained (final FocusEvent pE) {\n\n                t.selectAll ();\n\n            }}\n\n        );\n\n        f.add (t);\n\n        f.validate ();\n\n        t.requestFocus ();\n\n    }}\n"}
{"idx": 76102, "func": "public static void main (final String [] args) {\n\n    final JFrame f = new JFrame ();\n\n    f.setBounds (200, 200, 400, 400);\n\n    f.setVisible (true);\n\n    {\n\n        try {\n\n            Thread.sleep (2345);\n\n        } catch (final InterruptedException ignore) {\n\n        }\n\n    } {\n\n        final JTextField t = new JTextField (\"Hello World!\");\n\n        t.addFocusListener (new FocusListener () {\n\n            @X1\n\n            public void focusLost (final FocusEvent pE) {\n\n            }@X1\n\n            public void focusGained (final FocusEvent pE) {\n\n                t.selectAll ();\n\n            }}\n\n        );\n\n        f.add (t);\n\n        f.validate ();\n\n        t.requestFocus ();\n\n    }}\n"}
{"idx": 76201, "func": "public IntList get (int i) {\n\n    IntList current = this;\n\n    for (int k = 0;\n\n    k < i - 1; k ++) {\n\n        if (current.X1 != null) {\n\n            current = current.X1;\n\n        }\n\n    }\n\n    return current;\n\n}\n"}
{"idx": 76202, "func": "public IntList X1 (int i) {\n\n    if (i < 0) {\n\n        throw new IndexOutOfBoundsException (\"Index is negative!\");\n\n    }\n\n    if (i == 0) {\n\n        return this;\n\n    } else if (next != null) {\n\n        return next.X1 (i - 1);\n\n    }\n\n    throw new IndexOutOfBoundsException (\"Index exceeds bounds\");\n\n}\n"}
{"idx": 76301, "func": "public static final void main (String...args) {\n\n    new Thread () {\n\n        private String X1 = null;\n\n        Thread initialise (String X1) {\n\n            this.X1 = X1;\n\n            return this;\n\n        } public void run () {\n\n            System.out.println (X1);\n\n        }}\n\n    .initialise (args [0]).start ();\n\n}\n"}
{"idx": 76302, "func": "public static void main (String [] args) throws Exception {\n\n    final int X1 = 10;\n\n    Object a = new Object () {\n\n        {\n\n            System.out.println (\"arg = \" + X1);\n\n        }\n\n    }\n\n    ;\n\n}\n"}
{"idx": 76401, "func": "public static void main (String args []) {\n\n    String s1 = new String (\"Test\");\n\n    String s2 = new String (\"Test\");\n\n    System.out.X1 (\"\\n1 - PRIMITIVES \");\n\n    System.out.X1 (s1 == s2);\n\n    System.out.X1 (s1.equals (s2));\n\n    A a1 = new A ();\n\n    A a2 = new A ();\n\n    System.out.X1 (\"\\n2 - OBJECT TYPES / STATIC VARIABLE\");\n\n    System.out.X1 (a1 == a2);\n\n    System.out.X1 (a1.s == a2.s);\n\n    System.out.X1 (a1.s.equals (a2.s));\n\n    B b1 = new B ();\n\n    B b2 = new B ();\n\n    System.out.X1 (\"\\n3 - OBJECT TYPES / NON-STATIC VARIABLE\");\n\n    System.out.X1 (b1 == b2);\n\n    System.out.X1 (b1.getS () == b2.getS ());\n\n    System.out.X1 (b1.getS ().equals (b2.getS ()));\n\n}\n"}
{"idx": 76402, "func": "public static void main (String [] args) {\n\n    String s1 = \"Cat\";\n\n    String s2 = \"Cat\";\n\n    String s3 = new String (\"Cat\");\n\n    if (s1 == s2) {\n\n        X1.out.println (\"true\");\n\n    } else {\n\n        X1.out.println (\"false\");\n\n    }\n\n    if (s1 == s3) {\n\n        X1.out.println (\"true\");\n\n    } else {\n\n        X1.out.println (\"false\");\n\n    }\n\n    if (s1.equals (s3)) {\n\n        X1.out.println (\"true\");\n\n    } else {\n\n        X1.out.println (\"False\");\n\n    }\n\n}\n"}
{"idx": 76501, "func": "public static void main (String [] args) {\n\n    X1 in = new X1 (System.in);\n\n    int T = Integer.parseInt (in.nextLine ());\n\n    int [] N = new int [T];\n\n    int [] A = new int [T];\n\n    int [] B = new int [T];\n\n    double [] Probability = new double [T];\n\n    for (int t = 0;\n\n    t < T; t ++) {\n\n        String [] input = in.nextLine ().split (\" \");\n\n        N [t] = Integer.parseInt (input [0]);\n\n        A [t] = Integer.parseInt (input [1]);\n\n        B [t] = Integer.parseInt (input [2]);\n\n        int total, pa = 0, pb = 0;\n\n        String [] faces = in.nextLine ().split (\" \");\n\n        total = faces.length;\n\n        for (String f : faces) {\n\n            if (Integer.parseInt (f) == A [t]) {\n\n                pa ++;\n\n            }\n\n            if (Integer.parseInt (f) == B [t]) {\n\n                pb ++;\n\n            }\n\n        }\n\n        double pn = (double) (total * total);\n\n        Probability [t] = (pa * pb) / pn;\n\n    }\n\n    for (double d : Probability) {\n\n        System.out.println (d);\n\n    }\n\n}\n"}
{"idx": 76502, "func": "public static void main (X1 [] args) {\n\n    Scanner scanner = new Scanner (System.in);\n\n    X1 line = scanner.nextLine ();\n\n    int trys = Integer.parseInt (line.trim ());\n\n    for (int i = 0;\n\n    i < trys; i ++) {\n\n        double probability = processTry (scanner);\n\n        System.out.println (probability);\n\n    }\n\n    scanner.close ();\n\n}\n"}
{"idx": 76601, "func": "public String removeAdjacentDuplicates (String X1) {\n\n    StringBuilder resultBuilder = new StringBuilder ();\n\n    char previous = X1.charAt (0);\n\n    resultBuilder.append (previous);\n\n    for (int i = 1;\n\n    i < X1.length (); i ++) {\n\n        char current = X1.charAt (i);\n\n        if (previous != current) {\n\n            resultBuilder.append (current);\n\n            previous = current;\n\n        }\n\n    }\n\n    return resultBuilder.toString ();\n\n}\n"}
{"idx": 76602, "func": "public static String removeAdjacentDuplicates (String input) {\n\n    if (input.length () <= 1) {\n\n        return input;\n\n    }\n\n    X1 sb = new X1 ();\n\n    sb.append (input.charAt (0));\n\n    IntStream.range (1, input.length ()).mapToObj (i -> input.charAt (i) != input.charAt (i - 1) ? input.charAt (i) : \"\").forEach (sb :: append);\n\n    return sb.toString ();\n\n}\n"}
{"idx": 76701, "func": "public int solution (int [] A) {\n\n    final Set X1 = new HashSet ();\n\n    final int size = A.length;\n\n    for (int number : A) {\n\n        if (number > size) return 0;\n\n        X1.add (number);\n\n    }\n\n    if (X1.size () == A.length) return 1;\n\n    else return 0;\n\n}\n"}
{"idx": 76702, "func": "public int solution (int [] A) {\n\n    int [] X1 = new int [A.length + 1];\n\n    int counter = 0;\n\n    for (int i = 0;\n\n    i < A.length; ++ i) {\n\n        int value = A [i];\n\n        if (value >= X1.length) {\n\n            return NOT_PERMUTATION;\n\n        }\n\n        if (X1 [value] == 0) {\n\n            X1 [value] = 1;\n\n            ++ counter;\n\n        } else {\n\n            return NOT_PERMUTATION;\n\n        }\n\n    }\n\n    return counter == A.length ? PERMUTATION : NOT_PERMUTATION;\n\n}\n"}
{"idx": 76801, "func": "public boolean isPalindrome (String X1) {\n\n    int i = X1.length () - 1;\n\n    int j = 0;\n\n    while (i > j) {\n\n        if (X1.charAt (i) != X1.charAt (j)) {\n\n            return false;\n\n        }\n\n        i --;\n\n        j ++;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 76802, "func": "boolean isPalindrome (String s) {\n\n    int n = s.length ();\n\n    for (int i = 0;\n\n    i < (n / 2); ++ i) {\n\n        if (s.X1 (i) != s.X1 (n - i - 1)) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 76901, "func": "public boolean isPalindrome (String original) {\n\n    int i = original.length () - 1;\n\n    int X1 = 0;\n\n    while (i > X1) {\n\n        if (original.charAt (i) != original.charAt (X1)) {\n\n            return false;\n\n        }\n\n        i --;\n\n        X1 ++;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 76902, "func": "public static boolean isPalindrome (String X1) {\n\n    X1 = X1.toUpperCase ();\n\n    char [] strChars = X1.toCharArray ();\n\n    List < Character > word = new ArrayList < > ();\n\n    for (char c : strChars) {\n\n        word.add (c);\n\n    }\n\n    while (true) {\n\n        if ((word.size () == 1) || (word.size () == 0)) {\n\n            return true;\n\n        }\n\n        if (word.get (0) == word.get (word.size () - 1)) {\n\n            word.remove (0);\n\n            word.remove (word.size () - 1);\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n}\n"}
{"idx": 77001, "func": "boolean isPalindrome (String X1) {\n\n    int n = X1.length ();\n\n    for (int i = 0;\n\n    i < (n / 2); ++ i) {\n\n        if (X1.charAt (i) != X1.charAt (n - i - 1)) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 77002, "func": "public static boolean isPalindrome (String str) {\n\n    str = str.toUpperCase ();\n\n    char [] strChars = str.toCharArray ();\n\n    List < Character > word = new ArrayList < > ();\n\n    for (char c : strChars) {\n\n        word.add (c);\n\n    }\n\n    while (true) {\n\n        if ((word.X1 () == 1) || (word.X1 () == 0)) {\n\n            return true;\n\n        }\n\n        if (word.get (0) == word.get (word.X1 () - 1)) {\n\n            word.remove (0);\n\n            word.remove (word.X1 () - 1);\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n}\n"}
{"idx": 7701, "func": "public CharSequence filter (CharSequence source, int X1, int end, Spanned dest, int dstart, int dend) {\n\n    CharSequence out = super.filter (source, X1, end, dest, dstart, dend);\n\n    if (out != null) {\n\n        source = out;\n\n        X1 = 0;\n\n        end = out.length ();\n\n    }\n\n    int len = end - X1;\n\n    if (len == 0) {\n\n        return source;\n\n    }\n\n    int dlen = dest.length ();\n\n    for (int i = 0;\n\n    i < dstart; i ++) {\n\n        if (dest.charAt (i) == '.') {\n\n            return (dlen - (i + 1) + len > digits) ? \"\" : new SpannableStringBuilder (source, X1, end);\n\n        }\n\n    }\n\n    for (int i = X1;\n\n    i < end; ++ i) {\n\n        if (source.charAt (i) == '.') {\n\n            if ((dlen - dend) + (end - (i + 1)) > digits) return \"\";\n\n            else break;\n\n        }\n\n    }\n\n    return new SpannableStringBuilder (source, X1, end);\n\n}\n"}
{"idx": 7702, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String lsStart = \"\";\n\n    String X1 = \"\";\n\n    String lsEnd = \"\";\n\n    String lsText = \"\";\n\n    Log.d (\"debug\", moPattern.toString ());\n\n    Log.d (\"debug\", \"source: \" + source + \", start: \" + start + \", end:\" + end + \", dest: \" + dest + \", dstart: \" + dstart + \", dend: \" + dend);\n\n    lsText = dest.toString ();\n\n    if (lsText.length () > 0) {\n\n        lsStart = lsText.substring (0, dstart);\n\n        Log.d (\"debug\", \"lsStart : \" + lsStart);\n\n        if (source != \"\") {\n\n            X1 = source.toString ();\n\n            Log.d (\"debug\", \"lsInsert: \" + X1);\n\n        }\n\n        lsEnd = lsText.substring (dend);\n\n        Log.d (\"debug\", \"lsEnd   : \" + lsEnd);\n\n        lsText = lsStart + X1 + lsEnd;\n\n        Log.d (\"debug\", \"lsText  : \" + lsText);\n\n    }\n\n    Matcher loMatcher = moPattern.matcher (lsText);\n\n    Log.d (\"debug\", \"loMatcher.matches(): \" + loMatcher.matches () + \", lsText: \" + lsText);\n\n    if (! loMatcher.matches ()) {\n\n        return \"\";\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 77101, "func": "public static void main (String [] args) {\n\n    Map < String, String > X1 = new HashMap < > ();\n\n    X1.put (\"b\", \"dd\");\n\n    X1.put (\"c\", \"cc\");\n\n    X1.put (\"a\", \"aa\");\n\n    X1 = new TreeMap < > (X1);\n\n    for (String key : X1.keySet ()) {\n\n        System.out.println (key + \"=\" + X1.get (key));\n\n    }\n\n}\n"}
{"idx": 77102, "func": "public static void main (String [] args) {\n\n    Map < String, X1 > unSortedMap = new LinkedHashMap < String, X1 > ();\n\n    unSortedMap.put (\"A\", 2);\n\n    unSortedMap.put (\"V\", 1);\n\n    unSortedMap.put (\"G\", 5);\n\n    System.out.println (\"Unsorted Map :\\n\");\n\n    for (Map.Entry < String, X1 > entry : unSortedMap.entrySet ()) {\n\n        System.out.println (entry.getKey () + \"   \" + entry.getValue ());\n\n    }\n\n    System.out.println (\"\\n\");\n\n    System.out.println (\"Sorting Map Based on Keys :\\n\");\n\n    Map < String, X1 > keySortedMap = new TreeMap < String, X1 > (unSortedMap);\n\n    for (Map.Entry < String, X1 > entry : keySortedMap.entrySet ()) {\n\n        System.out.println (entry.getKey () + \"   \" + entry.getValue ());\n\n    }\n\n    System.out.println (\"\\n\");\n\n    System.out.println (\"Sorting Map Based on Values :\\n\");\n\n    List < Entry < String, X1 > > entryList = new ArrayList < Entry < String, X1 > > (unSortedMap.entrySet ());\n\n    Collections.sort (entryList, new Comparator < Entry < String, X1 > > () {\n\n        @Override\n\n        public int compare (Entry < String, X1 > obj1, Entry < String, X1 > obj2) {\n\n            return obj1.getValue ().compareTo (obj2.getValue ());\n\n        }}\n\n    );\n\n    unSortedMap.clear ();\n\n    for (Entry < String, X1 > entry : entryList) {\n\n        unSortedMap.put (entry.getKey (), entry.getValue ());\n\n        System.out.println (entry.getKey () + \"   \" + entry.getValue ());\n\n    }\n\n}\n"}
{"idx": 77201, "func": "public static void main (X1 [] args) {\n\n    Map < X1, X1 > map = new HashMap < > ();\n\n    map.put (\"b\", \"dd\");\n\n    map.put (\"c\", \"cc\");\n\n    map.put (\"a\", \"aa\");\n\n    map = new TreeMap < > (map);\n\n    for (X1 key : map.keySet ()) {\n\n        System.out.println (key + \"=\" + map.get (key));\n\n    }\n\n}\n"}
{"idx": 77202, "func": "public static void main (String [] args) {\n\n    Map < X1, X1 > handler = new LinkedHashMap < X1, X1 > ();\n\n    handler.put (\"item\", \"Value\");\n\n    handler.put (2, \"Movies\");\n\n    handler.put (\"isAlive\", true);\n\n    for (Map.Entry < X1, X1 > entrY : handler.entrySet ()) System.out.println (entrY.getKey () + \"><![CDATA[>\" + entrY.getValue ());\n\n    List < Map.Entry < String, Integer > > entries = new ArrayList < Map.Entry < String, Integer > > ();\n\n    Collections.sort (entries, new Comparator < Map.Entry < String, Integer > > () {\n\n        public int compare (Map.Entry < String, Integer > a, Map.Entry < String, Integer > b) {\n\n            return a.getValue ().compareTo (b.getValue ());\n\n        }}\n\n    );\n\n}\n"}
{"idx": 77301, "func": "public static void main (String [] args) {\n\n    Map < String, X1 > unSortedMap = new LinkedHashMap < String, X1 > ();\n\n    unSortedMap.put (\"A\", 2);\n\n    unSortedMap.put (\"V\", 1);\n\n    unSortedMap.put (\"G\", 5);\n\n    System.out.println (\"Unsorted Map :\\n\");\n\n    for (Map.Entry < String, X1 > entry : unSortedMap.entrySet ()) {\n\n        System.out.println (entry.getKey () + \"   \" + entry.getValue ());\n\n    }\n\n    System.out.println (\"\\n\");\n\n    System.out.println (\"Sorting Map Based on Keys :\\n\");\n\n    Map < String, X1 > keySortedMap = new TreeMap < String, X1 > (unSortedMap);\n\n    for (Map.Entry < String, X1 > entry : keySortedMap.entrySet ()) {\n\n        System.out.println (entry.getKey () + \"   \" + entry.getValue ());\n\n    }\n\n    System.out.println (\"\\n\");\n\n    System.out.println (\"Sorting Map Based on Values :\\n\");\n\n    List < Entry < String, X1 > > entryList = new ArrayList < Entry < String, X1 > > (unSortedMap.entrySet ());\n\n    Collections.sort (entryList, new Comparator < Entry < String, X1 > > () {\n\n        @Override\n\n        public int compare (Entry < String, X1 > obj1, Entry < String, X1 > obj2) {\n\n            return obj1.getValue ().compareTo (obj2.getValue ());\n\n        }}\n\n    );\n\n    unSortedMap.clear ();\n\n    for (Entry < String, X1 > entry : entryList) {\n\n        unSortedMap.put (entry.getKey (), entry.getValue ());\n\n        System.out.println (entry.getKey () + \"   \" + entry.getValue ());\n\n    }\n\n}\n"}
{"idx": 77302, "func": "public static void main (String [] args) {\n\n    Map < Object, Object > handler = new LinkedHashMap < Object, Object > ();\n\n    handler.put (\"item\", \"Value\");\n\n    handler.put (2, \"Movies\");\n\n    handler.put (\"isAlive\", true);\n\n    for (Map.Entry < Object, Object > entrY : handler.entrySet ()) System.out.println (entrY.getKey () + \"><![CDATA[>\" + entrY.getValue ());\n\n    List < Map.Entry < String, Integer > > entries = new ArrayList < Map.Entry < String, Integer > > ();\n\n    Collections.sort (entries, new Comparator < Map.Entry < String, Integer > > () {\n\n        public int compare (Map.Entry < String, Integer > X1, Map.Entry < String, Integer > b) {\n\n            return X1.getValue ().compareTo (b.getValue ());\n\n        }}\n\n    );\n\n}\n"}
{"idx": 77401, "func": "public static void main (String...args) throws IOException {\n\n    int [] nums = new int [10 * 1000 * 1000];\n\n    {\n\n        long X1 = System.nanoTime ();\n\n        product2 (nums);\n\n        long time = System.nanoTime () - X1;\n\n        System.out.printf (\"Took %.3f seconds to take the product of %,d ints using an int[].%n\", time / 1e9, nums.length);\n\n    } {\n\n        long X1 = System.nanoTime ();\n\n        product (nums);\n\n        long time = System.nanoTime () - X1;\n\n        System.out.printf (\"Took %.3f seconds to take the product of %,d ints using reflections.%n\", time / 1e9, nums.length);\n\n    }}\n"}
{"idx": 77402, "func": "public static void main (String arg []) {\n\n    Integer [] v1 = {1, - 10, 3, 9, 7, 99, - 25};\n\n    Integer [] v2 = {1, - 10, 3, 9, 7, 99, - 25};\n\n    double X1 = ArrayMath.ScalarProduct (v1, v2);\n\n    Double [] v1_d = {1.1, - 10.5, 3.7, 9.98, 7.4, 9.9, - 2.5};\n\n    Double [] v2_d = {1.1, - 10.5, 3.7, 9.98, 7.4, 9.9, - 2.5};\n\n    Double p_double = ArrayMath.ScalarProduct (v1_d, v2_d);\n\n    System.out.println (\"p_int\" + X1);\n\n    System.out.println (\"p_double\" + p_double);\n\n}\n"}
{"idx": 77501, "func": "public static boolean check (double x, double y, double x1, double y1, double x2, double X1) {\n\n    double dx1 = x - x1, dx2 = x2 - x1, dy1 = y - y1, dy2 = X1 - y1;\n\n    double dotp = dx1 * dx2 + dy1 * dy2;\n\n    double theta = Math.acos (dotp / (Math.sqrt (dx1 * dx1 + dy1 * dy1) * Math.sqrt (dx2 * dx2 + dy2 * dy2)));\n\n    theta = Math.abs (theta);\n\n    if (theta > (Math.PI / 2)) return false;\n\n    dx1 = x - x2;\n\n    dx2 = x1 - x2;\n\n    dy1 = y - X1;\n\n    dy2 = y1 - X1;\n\n    dotp = dx1 * dx2 + dy1 * dy2;\n\n    theta = Math.acos (dotp / (Math.sqrt (dx1 * dx1 + dy1 * dy1) * Math.sqrt (dx2 * dx2 + dy2 * dy2)));\n\n    theta = Math.abs (theta);\n\n    if (theta > (Math.PI / 2)) return false;\n\n    return true;\n\n}\n"}
{"idx": 77502, "func": "public static boolean check (double X1, double y1, double x2, double y2, double x, double y) {\n\n    if (X1 == x2) {\n\n        return y1 < y2 ? (y1 <= y && y <= y2) : (y2 <= y && y <= y1);\n\n    }\n\n    double m = (y2 - y1) / (x2 - X1);\n\n    double r1 = X1 + m * y1;\n\n    double r2 = x2 + m * y2;\n\n    double r = x + m * y;\n\n    return r1 < r2 ? (r1 <= r && r <= r2) : (r2 <= r && r <= r1);\n\n}\n"}
{"idx": 77601, "func": "public static void main (String args []) {\n\n    String s = \"1234\";\n\n    int X1 = s.length ();\n\n    int num = Integer.parseInt (s);\n\n    int mod;\n\n    int od = 0, even = 0;\n\n    for (int i = 0;\n\n    i < X1; i ++) {\n\n        mod = num % 10;\n\n        num = num / 10;\n\n        if (mod % 2 == 0) {\n\n            even = even + mod;\n\n        } else {\n\n            od = od + mod;\n\n        }\n\n    }\n\n    System.out.println (\"Sum of even numbers is \" + even);\n\n    System.out.println (\"Sum of odd numbers is \" + od);\n\n}\n"}
{"idx": 77602, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    String X1 = \"\";\n\n    int a = 0, total = 0;\n\n    boolean even = false;\n\n    System.out.println (\"Enter a number\");\n\n    X1 = input.nextLine ();\n\n    for (int counter = 0;\n\n    counter < X1.length (); counter ++) {\n\n        a = Integer.parseInt (X1.substring (counter, counter + 1));\n\n        if (a % 2 != 0 || a == 1) {\n\n            even = false;\n\n            total += a;\n\n        }\n\n    }\n\n    System.out.println (\"The sum is \" + total);\n\n}\n"}
{"idx": 77701, "func": "@Override\n\npublic String toString () {\n\n    StringBuilder X1 = new StringBuilder (\"[\");\n\n    for (Field f : getClass ().getFields ()) {\n\n        if (! isStaticField (f)) {\n\n            try {\n\n                X1.append (f.getName () + \"=\" + f.get (this) + \" \");\n\n            } catch (IllegalAccessException e) {\n\n            }\n\n        }\n\n    }\n\n    X1.append (']');\n\n    return X1.toString ();\n\n}\n"}
{"idx": 77702, "func": "public X1 toString (Object obj) {\n\n    if (obj == null) return \"null\";\n\n    if (visited.contains (obj)) return \"...\";\n\n    visited.add (obj);\n\n    Class cl = obj.getClass ();\n\n    if (cl == X1.class) return (X1) obj;\n\n    if (cl.isArray ()) {\n\n        X1 r = cl.getComponentType () + \"[]{\";\n\n        for (int i = 0;\n\n        i < Array.getLength (obj); i ++) {\n\n            if (i > 0) r += \",\";\n\n            Object val = Array.get (obj, i);\n\n            if (cl.getComponentType ().isPrimitive ()) r += val;\n\n            else r += toString (val);\n\n        }\n\n        return r + \"}\";\n\n    }\n\n    X1 r = cl.getName ();\n\n    do {\n\n        r += \"[\";\n\n        Field [] fields = cl.getDeclaredFields ();\n\n        AccessibleObject.setAccessible (fields, true);\n\n        for (Field f : fields) {\n\n            if (! Modifier.isStatic (f.getModifiers ())) {\n\n                if (! r.endsWith (\"[\")) r += \",\";\n\n                r += f.getName () + \"=\";\n\n                try {\n\n                    Class t = f.getType ();\n\n                    Object val = f.get (obj);\n\n                    if (t.isPrimitive ()) r += val;\n\n                    else r += toString (val);\n\n                } catch (Exception e) {\n\n                    e.printStackTrace ();\n\n                }\n\n            }\n\n        }\n\n        r += \"]\";\n\n        cl = cl.getSuperclass ();\n\n    } while (cl != null);\n\n    return r;\n\n}\n"}
{"idx": 77801, "func": "public static boolean twoDuplicates (int [] values) {\n\n    boolean X1 = false;\n\n    int counter = 0;\n\n    Arrays.sort (values);\n\n    int old = values [0];\n\n    boolean numberSeen = false;\n\n    for (int i = 0;\n\n    i < values.length; i ++) {\n\n        if (values [i] == old) {\n\n            if (! numberSeen) {\n\n                counter ++;\n\n                numberSeen = true;\n\n            }\n\n        } else {\n\n            numberSeen = false;\n\n            old = values [i];\n\n        }\n\n    }\n\n    if (counter == 2) X1 = true;\n\n    return X1;\n\n}\n"}
{"idx": 77802, "func": "public static boolean twoDuplicates (int [] values) {\n\n    for (int i = 0;\n\n    i < values.X1; i ++) {\n\n        int counter = 0;\n\n        for (int z = i + 1;\n\n        z <= values.X1 - 1; z ++) {\n\n            if (values [i] == values [z]) {\n\n                counter ++;\n\n                if (counter == 2) return true;\n\n            }\n\n        }\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 77901, "func": "public static void main (String args []) {\n\n    String value = \"This is testing Program testing Program\";\n\n    String item [] = value.split (\" \");\n\n    HashMap < String, Integer > map = new HashMap < > ();\n\n    for (String X1 : item) {\n\n        if (map.containsKey (X1)) {\n\n            map.put (X1, map.get (X1) + 1);\n\n        } else {\n\n            map.put (X1, 1);\n\n        }\n\n    }\n\n    Set < String > keys = map.keySet ();\n\n    for (String key : keys) {\n\n        System.out.println (key);\n\n        System.out.println (map.get (key));\n\n    }\n\n}\n"}
{"idx": 77902, "func": "public static void main (String [] args) {\n\n    Map < String, Integer > X1 = new LinkedHashMap < String, Integer > ();\n\n    for (String string : \"House, House, House, Dog, Dog, Dog, Dog\".split (\", \")) {\n\n        if (X1.get (string) == null) X1.put (string, 1);\n\n        else X1.put (string, X1.get (string) + 1);\n\n    }\n\n    String uniqueString = join (X1.keySet (), \", \");\n\n    List < Integer > value = new ArrayList < Integer > (X1.values ());\n\n    System.out.println (\"Output = \" + uniqueString);\n\n    System.out.println (\"Values = \" + value);\n\n}\n"}
{"idx": 78001, "func": "public static int binarySearch (int X1 [], int first, int last, int value) {\n\n    int index;\n\n    int done = 0;\n\n    while (done == 0) {\n\n        if (first > last) {\n\n            index = - 1;\n\n            done = 1;\n\n        } else {\n\n            int mid = (first + last) / 2;\n\n            if (value == X1 [mid]) {\n\n                index = mid;\n\n                done = 1;\n\n            } else if (value < X1 [mid]) {\n\n                last = mid - 1;\n\n            } else {\n\n                first = mid + 1;\n\n            }\n\n        }\n\n    }\n\n    return index;\n\n}\n"}
{"idx": 78002, "func": "public static int binarySearch (int anArray [], int first, int last, int value) {\n\n    do {\n\n        if (first > last) {\n\n            return - 1;\n\n        } else {\n\n            int X1 = (first + last) / 2;\n\n            if (value == anArray [X1]) {\n\n                return X1;\n\n            } else if (value < anArray [X1]) {\n\n                last = X1 - 1;\n\n            } else {\n\n                first = X1 + 1;\n\n            }\n\n        }\n\n    } while (true);\n\n}\n"}
{"idx": 7801, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    CharSequence out = super.filter (source, start, end, dest, dstart, dend);\n\n    if (out != null) {\n\n        source = out;\n\n        start = 0;\n\n        end = out.length ();\n\n    }\n\n    int len = end - start;\n\n    if (len == 0) {\n\n        return source;\n\n    }\n\n    int dlen = dest.length ();\n\n    for (int X1 = 0;\n\n    X1 < dstart; X1 ++) {\n\n        if (dest.charAt (X1) == '.') {\n\n            return (dlen - (X1 + 1) + len > digits) ? \"\" : new SpannableStringBuilder (source, start, end);\n\n        }\n\n    }\n\n    for (int X1 = start;\n\n    X1 < end; ++ X1) {\n\n        if (source.charAt (X1) == '.') {\n\n            if ((dlen - dend) + (end - (X1 + 1)) > digits) return \"\";\n\n            else break;\n\n        }\n\n    }\n\n    return new SpannableStringBuilder (source, start, end);\n\n}\n"}
{"idx": 7802, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int X1) {\n\n    int dotPos = - 1;\n\n    int len = dest.length ();\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        char c = dest.charAt (i);\n\n        if (c == '.' || c == ',') {\n\n            dotPos = i;\n\n            break;\n\n        }\n\n    }\n\n    if (dotPos >= 0) {\n\n        if (source.equals (\".\") || source.equals (\",\")) {\n\n            return \"\";\n\n        }\n\n        if (X1 <= dotPos) {\n\n            return null;\n\n        }\n\n        if (len - dotPos > decimalDigits) {\n\n            return \"\";\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 78101, "func": "public static void main (String [] args) {\n\n    boolean t = true;\n\n    first : {\n\n        second : {\n\n            third : {\n\n                System.X1.println (\"Before the break\");\n\n                if (t) {\n\n                    break second;\n\n                }\n\n                System.X1.println (\"Not executed\");\n\n            } System.X1.println (\"Not executed - end of second block\");\n\n        } System.X1.println (\"End of third block\");\n\n    }}\n"}
{"idx": 78102, "func": "public static void main (String [] args) {\n\n    int temp = 0;\n\n    out : for (int i = 0;\n\n    i < 3; ++ i) {\n\n        System.out.println (\"I am here\");\n\n        for (int X1 = 0;\n\n        X1 < 20; ++ X1) {\n\n            if (temp == 0) {\n\n                System.out.println (\"j: \" + X1);\n\n                if (X1 == 1) {\n\n                    temp = X1;\n\n                    continue out;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    System.out.println (\"temp = \" + temp);\n\n}\n"}
{"idx": 78201, "func": "public static void main (String [] args) {\n\n    ArrayList < String > al = new ArrayList < String > ();\n\n    Scanner sc = new Scanner (X1.in);\n\n    while (true) {\n\n        X1.out.print (\"Enter name:\");\n\n        String temp = sc.next ();\n\n        if (al.isEmpty () != true) {\n\n            if (temp.equals (al.get (0))) break;\n\n        }\n\n        al.add (temp);\n\n    }\n\n    for (int i = 0;\n\n    i < al.size (); i ++) {\n\n        X1.out.println (al.get (i));\n\n    }\n\n}\n"}
{"idx": 78202, "func": "public static void main (String [] args) {\n\n    Scanner scan = new Scanner (X1.in);\n\n    int numOfItems = 20, maxItems = 0;\n\n    String arrayOfNames [] = new String [numOfItems];\n\n    String Temp = \"\";\n\n    for (int i = 0;\n\n    i < arrayOfNames.length; i ++) {\n\n        X1.out.print (\"Enter Item \" + (i + 1) + \" : \");\n\n        Temp = scan.nextLine ();\n\n        if (Temp.equals (arrayOfNames [0])) {\n\n            maxItems = i;\n\n            break;\n\n        } else {\n\n            arrayOfNames [i] = Temp;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < maxItems; i ++) {\n\n        X1.out.print (\"Item # \" + (i + 1) + \" : \");\n\n        X1.out.print (arrayOfNames [i] + \"\\n\");\n\n    }\n\n}\n"}
{"idx": 78301, "func": "public static void main (String [] args) {\n\n    ArrayList < String > al = new ArrayList < String > ();\n\n    Scanner sc = new Scanner (X1.in);\n\n    while (true) {\n\n        X1.out.print (\"Enter name:\");\n\n        String temp = sc.next ();\n\n        if (al.isEmpty () != true) {\n\n            if (temp.equals (al.get (0))) break;\n\n        }\n\n        al.add (temp);\n\n    }\n\n    for (int i = 0;\n\n    i < al.size (); i ++) {\n\n        X1.out.println (al.get (i));\n\n    }\n\n}\n"}
{"idx": 78302, "func": "public static void main (String [] args) {\n\n    Scanner scan = new Scanner (System.in);\n\n    int numOfItems = 0;\n\n    System.out.print (\"Enter How Many Items: \");\n\n    try {\n\n        numOfItems = Integer.parseInt (scan.X1 ().trim ());\n\n    } catch (NumberFormatException e) {\n\n        System.out.print (\"Number of items you entered is invalid!\");\n\n        System.exit (0);\n\n    }\n\n    Grocery grocery = new Grocery (numOfItems);\n\n    for (int i = 0;\n\n    i < numOfItems; i ++) {\n\n        System.out.print (\"Enter Item \" + (i + 1) + \" : \");\n\n        if (! grocery.addItem (scan.X1 ())) {\n\n            System.out.println (\"First Item Duplicate Detected!\");\n\n            System.exit (0);\n\n        }\n\n    }\n\n    scan.close ();\n\n    System.out.println (grocery.toString ());\n\n}\n"}
{"idx": 78401, "func": "public static void main (String [] args) {\n\n    Scanner scan = new Scanner (System.in);\n\n    int numOfItems = 20, maxItems = 0;\n\n    String X1 [] = new String [numOfItems];\n\n    String Temp = \"\";\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        System.out.print (\"Enter Item \" + (i + 1) + \" : \");\n\n        Temp = scan.nextLine ();\n\n        if (Temp.equals (X1 [0])) {\n\n            maxItems = i;\n\n            break;\n\n        } else {\n\n            X1 [i] = Temp;\n\n        }\n\n    }\n\n    for (int i = 0;\n\n    i < maxItems; i ++) {\n\n        System.out.print (\"Item # \" + (i + 1) + \" : \");\n\n        System.out.print (X1 [i] + \"\\n\");\n\n    }\n\n}\n"}
{"idx": 78402, "func": "public static void main (String [] args) {\n\n    X1 scan = new X1 (System.in);\n\n    int numOfItems = 0;\n\n    System.out.print (\"Enter How Many Items: \");\n\n    try {\n\n        numOfItems = Integer.parseInt (scan.nextLine ().trim ());\n\n    } catch (NumberFormatException e) {\n\n        System.out.print (\"Number of items you entered is invalid!\");\n\n        System.exit (0);\n\n    }\n\n    Grocery grocery = new Grocery (numOfItems);\n\n    for (int i = 0;\n\n    i < numOfItems; i ++) {\n\n        System.out.print (\"Enter Item \" + (i + 1) + \" : \");\n\n        if (! grocery.addItem (scan.nextLine ())) {\n\n            System.out.println (\"First Item Duplicate Detected!\");\n\n            System.exit (0);\n\n        }\n\n    }\n\n    scan.close ();\n\n    System.out.println (grocery.toString ());\n\n}\n"}
{"idx": 78501, "func": "public static void main (String args []) throws IOException {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    String st = br.readLine ();\n\n    int len = st.length ();\n\n    String [] X1 = new String [7];\n\n    len = len / 30;\n\n    int i = 0;\n\n    for (; i < 7 && i < len; i ++) {\n\n        X1 [i] = st.substring (30 * i, 30 * (i + 1));\n\n        System.out.println (X1 [i]);\n\n    }\n\n    if (i != 7) {\n\n        X1 [i] = st.substring (30 * i, st.length ());\n\n        System.out.println (X1 [i]);\n\n    }\n\n}\n"}
{"idx": 78502, "func": "public static void main (String [] args) {\n\n    String x = \"flskdafsld~fdsakkfsda sfdaldsak~fdskkfadslkfldsklflfdskldkslkfdslakafdsldsklfdsklafdskkdfslkfds~lkfasdlfdls~klf~dkslsakdlkf\";\n\n    X1.out.println (\"x length: \" + x.length ());\n\n    String [] lines = Split (x, 30, 210);\n\n    for (int i = 0;\n\n    i < lines.length; i ++) {\n\n        X1.out.println (\"lines[\" + i + \"]: (len: \" + lines [i].length () + \") : \" + lines [i]);\n\n    }\n\n}\n"}
{"idx": 78601, "func": "public void makeGrid (int size) {\n\n    this.lines = size;\n\n    grid = new Cell [size] [size];\n\n    for (int i = 0;\n\n    i < size; i ++) for (int X1 = 0;\n\n    X1 < size; X1 ++) {\n\n        grid [i] [X1] = new Cell ();\n\n    }\n\n}\n"}
{"idx": 78602, "func": "public void makeGrid (int size) {\n\n    this.lines = size;\n\n    grid = new Cell [size] [size];\n\n    for (int X1 = 0;\n\n    X1 < size; X1 ++) {\n\n        for (int j = 0;\n\n        j < size; j ++) {\n\n            grid [X1] [j] = new Cell ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 78701, "func": "@Override\n\npublic void dispatchEvent (Event event) {\n\n    checkNotNull (event);\n\n    CancellableEvent cancellableEvent = null;\n\n    boolean X1;\n\n    if (X1 = event instanceof CancellableEvent) {\n\n        cancellableEvent = (CancellableEvent) event;\n\n        checkArgument (cancellableEvent.isCancelled ());\n\n    }\n\n    handleEvents (event, true);\n\n    handleEvents (event, false, cancellableEvent);\n\n}\n"}
{"idx": 78702, "func": "@Override\n\npublic void dispatchEvent (Event event) {\n\n    checkNotNull (event);\n\n    CancellableEvent cancellableEvent = null;\n\n    boolean cancellable;\n\n    if (cancellable = event instanceof CancellableEvent) {\n\n        cancellableEvent = (CancellableEvent) event;\n\n        checkArgument (cancellableEvent.isCancelled ());\n\n    }\n\n    for (EventPriority priority : EventPriority.values ()) {\n\n        Map < Method, EventListener > internalMapping = getRegistry ().getMethodMap (event.getClass (), priority, true);\n\n        if (internalMapping != null) {\n\n            for (X1 < Method, EventListener > entry : internalMapping.entrySet ()) {\n\n                invokeEntry (entry, event);\n\n            }\n\n        }\n\n    }\n\n    for (EventPriority priority : EventPriority.values ()) {\n\n        Map < Method, EventListener > internalMapping = getRegistry ().getMethodMap (event.getClass (), priority, false);\n\n        if (internalMapping != null) {\n\n            for (X1 < Method, EventListener > entry : internalMapping.entrySet ()) {\n\n                invokeEntry (entry, event);\n\n                if (cancellable && cancellableEvent.isCancelled ()) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 78801, "func": "@Override\n\npublic void dispatchEvent (Event event) {\n\n    checkNotNull (event);\n\n    CancellableEvent cancellableEvent = null;\n\n    boolean cancellable;\n\n    if (cancellable = event instanceof CancellableEvent) {\n\n        cancellableEvent = (CancellableEvent) event;\n\n        checkArgument (cancellableEvent.isCancelled ());\n\n    }\n\n    for (EventPriority priority : EventPriority.values ()) {\n\n        Map < X1, EventListener > internalMapping = getRegistry ().getMethodMap (event.getClass (), priority, true);\n\n        if (internalMapping != null) {\n\n            for (Entry < X1, EventListener > entry : internalMapping.entrySet ()) {\n\n                invokeEntry (entry, event);\n\n            }\n\n        }\n\n    }\n\n    for (EventPriority priority : EventPriority.values ()) {\n\n        Map < X1, EventListener > internalMapping = getRegistry ().getMethodMap (event.getClass (), priority, false);\n\n        if (internalMapping != null) {\n\n            for (Entry < X1, EventListener > entry : internalMapping.entrySet ()) {\n\n                invokeEntry (entry, event);\n\n                if (cancellable && cancellableEvent.isCancelled ()) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 78802, "func": "@Override\n\npublic void dispatchEvent (Event X1) {\n\n    checkNotNull (X1);\n\n    CancellableEvent cancellableEvent = null;\n\n    boolean cancellable;\n\n    if (cancellable = X1 instanceof CancellableEvent) {\n\n        cancellableEvent = (CancellableEvent) X1;\n\n        checkArgument (cancellableEvent.isCancelled ());\n\n    }\n\n    fireEvents (false, X1, cancellableEvent, cancellable);\n\n    fireEvents (true, X1, cancellableEvent, cancellable);\n\n}\n"}
{"idx": 78901, "func": "public static int findCombinationsCount (int sum, int vals []) {\n\n    if (sum < 0) {\n\n        return 0;\n\n    }\n\n    if (vals == null || vals.length == 0) {\n\n        return 0;\n\n    }\n\n    int dp [] = new int [sum + 1];\n\n    dp [0] = 1;\n\n    for (int X1 = 0;\n\n    X1 < vals.length; ++ X1) {\n\n        for (int j = vals [X1];\n\n        j <= sum; ++ j) {\n\n            dp [j] += dp [j - vals [X1]];\n\n        }\n\n    }\n\n    return dp [sum];\n\n}\n"}
{"idx": 78902, "func": "int findCombinationsCount (int amount, int coins []) {\n\n    if (coins.length == 1) {\n\n        return amount % coins [0] == 0 ? 1 : 0;\n\n    } else {\n\n        int total = 0;\n\n        int [] X1 = arrayOfCoinsExceptTheFirstOne (coins);\n\n        for (int i = 0;\n\n        i * coins [0] <= amount; ++ i) {\n\n            total += findCombinationsCount (amount - i * coins [0], X1);\n\n        }\n\n        return total;\n\n    }\n\n}\n"}
{"idx": 79001, "func": "public static int findCombinationsCount (int X1, int vals []) {\n\n    if (X1 < 0) {\n\n        return 0;\n\n    }\n\n    if (vals == null || vals.length == 0) {\n\n        return 0;\n\n    }\n\n    int dp [] = new int [X1 + 1];\n\n    dp [0] = 1;\n\n    for (int i = 0;\n\n    i < vals.length; ++ i) {\n\n        for (int j = vals [i];\n\n        j <= X1; ++ j) {\n\n            dp [j] += dp [j - vals [i]];\n\n        }\n\n    }\n\n    return dp [X1];\n\n}\n"}
{"idx": 79002, "func": "int findCombinationsCount (int amount, int X1 [], int checkFromIndex) {\n\n    if (amount == 0) return 1;\n\n    else if (amount < 0 || X1.length == checkFromIndex) return 0;\n\n    else {\n\n        int withFirstCoin = findCombinationsCount (amount - X1 [checkFromIndex], X1, checkFromIndex);\n\n        int withoutFirstCoin = findCombinationsCount (amount, X1, checkFromIndex + 1);\n\n        return withFirstCoin + withoutFirstCoin;\n\n    }\n\n}\n"}
{"idx": 7901, "func": "public void afterTextChanged (Editable s) {\n\n    if (! X1) {\n\n        if (! isValid (s.toString ())) {\n\n            X1 = true;\n\n            restorePreviousValue ();\n\n        }\n\n    } else {\n\n        X1 = false;\n\n    }\n\n}\n"}
{"idx": 7902, "func": "public synchronized void afterTextChanged (final Editable text) {\n\n    String cost = text.toString ().trim ();\n\n    if (! cost.endsWith (\".\") && cost.contains (\".\")) {\n\n        String X1 = cost.split (\"\\\\.\") [0];\n\n        String numberAfterDecimal = cost.split (\"\\\\.\") [1];\n\n        if (numberAfterDecimal.length () > 2) {\n\n            numberAfterDecimal = numberAfterDecimal.substring (0, 2);\n\n        }\n\n        cost = X1 + \".\" + numberAfterDecimal;\n\n    }\n\n    costEditText.removeTextChangedListener (this);\n\n    costEditText.setText (cost);\n\n    costEditText.setSelection (costEditText.getText ().toString ().trim ().length ());\n\n    costEditText.addTextChangedListener (this);\n\n}\n"}
{"idx": 79101, "func": "int findCombinationsCount (int amount, int coins []) {\n\n    if (coins.length == 1) {\n\n        return amount % coins [0] == 0 ? 1 : 0;\n\n    } else {\n\n        int X1 = 0;\n\n        int [] subCoins = arrayOfCoinsExceptTheFirstOne (coins);\n\n        for (int i = 0;\n\n        i * coins [0] <= amount; ++ i) {\n\n            X1 += findCombinationsCount (amount - i * coins [0], subCoins);\n\n        }\n\n        return X1;\n\n    }\n\n}\n"}
{"idx": 79102, "func": "int findCombinationsCount (int X1, int coins [], int checkFromIndex) {\n\n    if (X1 == 0) return 1;\n\n    else if (X1 < 0 || coins.length == checkFromIndex) return 0;\n\n    else {\n\n        int withFirstCoin = findCombinationsCount (X1 - coins [checkFromIndex], coins, checkFromIndex);\n\n        int withoutFirstCoin = findCombinationsCount (X1, coins, checkFromIndex + 1);\n\n        return withFirstCoin + withoutFirstCoin;\n\n    }\n\n}\n"}
{"idx": 79201, "func": "public static void main (String [] args) {\n\n    int [] coins = {1, 3, 5, 10, 20, 50, 100, 200, 500};\n\n    int X1 = new Random ().nextInt (10000);\n\n    int coinsCount = 0;\n\n    System.out.println (\"amount = \" + X1);\n\n    int [] numberOfCoins = findNumberOfCoins (coins, X1);\n\n    for (int i = 0;\n\n    i < numberOfCoins.length; i ++) {\n\n        if (numberOfCoins [i] > 0) {\n\n            System.out.println (\"coins= \" + coins [i] + \" Count=\" + numberOfCoins [i] + \"\\n\");\n\n            coinsCount += numberOfCoins [i];\n\n        }\n\n    }\n\n    System.out.println (\"numberOfCoins = \" + coinsCount);\n\n}\n"}
{"idx": 79202, "func": "public static void main (String [] args) {\n\n    int [] coins = new int [] {1, 2, 3, 4, 5};\n\n    int money = 600;\n\n    int [] [] recorder = new int [money + 1] [coins.length];\n\n    for (int k = 0;\n\n    k < coins.length; k ++) {\n\n        recorder [0] [k] = 1;\n\n    }\n\n    for (int i = 1;\n\n    i <= money; i ++) {\n\n        int X1 = 0;\n\n        int without = 0;\n\n        for (int coin_index = 0;\n\n        coin_index < coins.length; coin_index ++) {\n\n            if (i - coins [coin_index] < 0) {\n\n                X1 = 0;\n\n            } else {\n\n                X1 = recorder [i - coins [coin_index]] [coin_index];\n\n            }\n\n            if (coin_index - 1 < 0) {\n\n                without = 0;\n\n            } else {\n\n                without = recorder [i] [coin_index - 1];\n\n            }\n\n            recorder [i] [coin_index] = X1 + without;\n\n        }\n\n    }\n\n    System.out.print (recorder [money] [coins.length - 1]);\n\n}\n"}
{"idx": 79301, "func": "public static void main (String args []) {\n\n    String [] arr = {\"foo:1,2,3\", \"bar:a,b\", \"baz:5,6,7\"};\n\n    CartesianProductLHM cp = new CartesianProductLHM (arr);\n\n    X1 < X1 < String > > lls = cp.allUniqueCombinations ();\n\n    for (X1 < String > ls : lls) {\n\n        for (String s : ls) System.out.print (s + \"\\t\");\n\n        System.out.println ();\n\n    }\n\n}\n"}
{"idx": 79302, "func": "public static void main (X1 [] args) {\n\n    LinkedHashMap < X1, Vector < X1 > > data = new LinkedHashMap < X1, Vector < X1 > > ();\n\n    data.put (\"foo\", new Vector < X1 > (Arrays.asList (\"1\", \"2\", \"3\")));\n\n    data.put (\"bar\", new Vector < X1 > (Arrays.asList (\"3\", \"2\")));\n\n    data.put (\"baz\", new Vector < X1 > (Arrays.asList (\"5\", \"6\", \"7\")));\n\n    Foo foo = new Foo (data);\n\n    for (X1 [] combination : foo.allUniqueCombinations ()) {\n\n        System.out.println (Arrays.toString (combination));\n\n    }\n\n}\n"}
{"idx": 79401, "func": "public String [] [] allUniqueCombinations () {\n\n    List < String > labels = new X1 < String > ();\n\n    List < List < String > > lists = new X1 < List < String > > ();\n\n    for (Map.Entry < String, Vector < String > > entry : dataStructure.entrySet ()) {\n\n        labels.add (entry.getKey ());\n\n        lists.add (entry.getValue ());\n\n    }\n\n    List < List < String > > combinations = product (lists);\n\n    int m = combinations.size () + 1;\n\n    int n = labels.size ();\n\n    String [] [] answer = new String [m] [n];\n\n    for (int i = 0;\n\n    i < n; i ++) answer [0] [i] = labels.get (i);\n\n    for (int i = 1;\n\n    i < m; i ++) for (int j = 0;\n\n    j < n; j ++) answer [i] [j] = combinations.get (i - 1).get (j);\n\n    return answer;\n\n}\n"}
{"idx": 79402, "func": "public String [] [] allUniqueCombinations () {\n\n    int n = dataStructure.X1 ().size ();\n\n    int solutions = 1;\n\n    for (Vector < String > vector : dataStructure.values ()) {\n\n        solutions *= vector.size ();\n\n    }\n\n    String [] [] allCombinations = new String [solutions + 1] [];\n\n    allCombinations [0] = dataStructure.X1 ().toArray (new String [n]);\n\n    for (int i = 0;\n\n    i < solutions; i ++) {\n\n        Vector < String > combination = new Vector < String > (n);\n\n        int j = 1;\n\n        for (Vector < String > vec : dataStructure.values ()) {\n\n            combination.add (vec.get ((i / j) % vec.size ()));\n\n            j *= vec.size ();\n\n        }\n\n        allCombinations [i + 1] = combination.toArray (new String [n]);\n\n    }\n\n    return allCombinations;\n\n}\n"}
{"idx": 79501, "func": "public static double exp (double x, int n) {\n\n    double sum = 1.0;\n\n    double X1 = 1.0;\n\n    for (int i = 1;\n\n    i <= n; ++ i) {\n\n        X1 *= x / i;\n\n        sum += X1;\n\n    }\n\n    return sum;\n\n}\n"}
{"idx": 79502, "func": "public static double exp (double X1, int n) {\n\n    return DoubleStream.iterate (1, new DoubleUnaryOperator () {\n\n        private int i = 1;\n\n        @Override\n\n        public double applyAsDouble (double operand) {\n\n            return operand * X1 / i ++;\n\n        }}\n\n    ).limit (n).sum ();\n\n}\n"}
{"idx": 79601, "func": "public static X1 merge (X1...s) {\n\n    int maxLen = 0;\n\n    for (X1 str : s) {\n\n        maxLen = Math.max (maxLen, str.length ());\n\n    }\n\n    StringBuilder b = new StringBuilder ();\n\n    for (int i = 0;\n\n    i < maxLen; ++ i) {\n\n        for (X1 str : s) {\n\n            if (str.length () > i) {\n\n                b.append (str.charAt (i));\n\n            }\n\n        }\n\n    }\n\n    return b.toString ();\n\n}\n"}
{"idx": 79602, "func": "private static String merge (String...strings) {\n\n    StringBuilder sb = new StringBuilder ();\n\n    int X1;\n\n    boolean edited;\n\n    X1 = 0;\n\n    edited = true;\n\n    while (edited) {\n\n        edited = false;\n\n        for (String s : strings) {\n\n            if (X1 < s.length ()) {\n\n                sb.append (s.charAt (X1));\n\n                edited = true;\n\n            }\n\n        }\n\n        X1 ++;\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 79701, "func": "public static String merge (String...s) {\n\n    int maxLen = 0;\n\n    for (String X1 : s) {\n\n        maxLen = Math.max (maxLen, X1.length ());\n\n    }\n\n    StringBuilder b = new StringBuilder ();\n\n    for (int i = 0;\n\n    i < maxLen; ++ i) {\n\n        for (String X1 : s) {\n\n            if (X1.length () > i) {\n\n                b.append (X1.charAt (i));\n\n            }\n\n        }\n\n    }\n\n    return b.toString ();\n\n}\n"}
{"idx": 79702, "func": "public static String merge (String...strings) {\n\n    int maxLength = 0;\n\n    X1 sb = new X1 ();\n\n    for (String s : strings) if (s.length () > maxLength) maxLength = s.length ();\n\n    for (int i = 0;\n\n    i < maxLength; i ++) for (String s : strings) if (s.length () > i) sb.append (s.charAt (i));\n\n    return sb.toString ();\n\n}\n"}
{"idx": 79801, "func": "private static String merge (String...strings) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    int adv;\n\n    boolean edited;\n\n    adv = 0;\n\n    edited = true;\n\n    while (edited) {\n\n        edited = false;\n\n        for (String s : strings) {\n\n            if (adv < s.length ()) {\n\n                X1.append (s.charAt (adv));\n\n                edited = true;\n\n            }\n\n        }\n\n        adv ++;\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 79802, "func": "public static String merge (String...strings) {\n\n    int maxLength = 0;\n\n    StringBuilder sb = new StringBuilder ();\n\n    for (String s : strings) if (s.length () > maxLength) maxLength = s.length ();\n\n    for (int X1 = 0;\n\n    X1 < maxLength; X1 ++) for (String s : strings) if (s.length () > X1) sb.append (s.charAt (X1));\n\n    return sb.toString ();\n\n}\n"}
{"idx": 79901, "func": "public static void main (String [] args) {\n\n    char [] values = {'a', 'b', 'c', 'd'};\n\n    int n = values.length;\n\n    int r = 2;\n\n    int X1 = 0, j = 0;\n\n    for (X1 = 0; X1 < n; X1 ++) {\n\n        for (j = 0; j < n; j ++) {\n\n            System.out.println (values [j] + \" \" + values [X1]);\n\n        }\n\n    }\n\n}\n"}
{"idx": 79902, "func": "public static void main (String [] args) {\n\n    char [] values = {'a', 'b', 'c', 'd'};\n\n    int n = values.length;\n\n    int X1 = 2;\n\n    int i [] = new int [X1];\n\n    int rc = 0;\n\n    for (int j = 0;\n\n    j < Math.pow (n, X1); j ++) {\n\n        rc = 0;\n\n        while (rc < X1) {\n\n            System.out.print (values [i [rc]] + \" \");\n\n            rc ++;\n\n        }\n\n        System.out.println ();\n\n        rc = 0;\n\n        while (rc < X1) {\n\n            if (i [rc] < n - 1) {\n\n                i [rc] ++;\n\n                break;\n\n            } else {\n\n                i [rc] = 0;\n\n            }\n\n            rc ++;\n\n        }\n\n    }\n\n}\n"}
{"idx": 80001, "func": "public static String shuffle (String s) {\n\n    String X1 = \"\";\n\n    while (s.length () != 0) {\n\n        int index = (int) Math.floor (Math.random () * s.length ());\n\n        char c = s.charAt (index);\n\n        s = s.substring (0, index) + s.substring (index + 1);\n\n        X1 += c;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 80002, "func": "public void shuffle (String input) {\n\n    List < Character > X1 = new ArrayList < Character > ();\n\n    for (char c : input.toCharArray ()) {\n\n        X1.add (c);\n\n    }\n\n    StringBuilder output = new StringBuilder (input.length ());\n\n    while (X1.size () != 0) {\n\n        int randPicker = (int) (Math.random () * X1.size ());\n\n        output.append (X1.remove (randPicker));\n\n    }\n\n    System.out.println (output.toString ());\n\n}\n"}
{"idx": 8001, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String replacement = source.X1 (start, end).toString ();\n\n    String newVal = dest.X1 (0, dstart).toString () + replacement + dest.X1 (dend, dest.length ()).toString ();\n\n    Matcher matcher = mPattern.matcher (newVal);\n\n    if (matcher.matches ()) return null;\n\n    if (TextUtils.isEmpty (source)) return dest.X1 (dstart, dend);\n\n    else return \"\";\n\n}\n"}
{"idx": 8002, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String lsStart = \"\";\n\n    String lsInsert = \"\";\n\n    String X1 = \"\";\n\n    String lsText = \"\";\n\n    Log.d (\"debug\", moPattern.toString ());\n\n    Log.d (\"debug\", \"source: \" + source + \", start: \" + start + \", end:\" + end + \", dest: \" + dest + \", dstart: \" + dstart + \", dend: \" + dend);\n\n    lsText = dest.toString ();\n\n    if (lsText.length () > 0) {\n\n        lsStart = lsText.substring (0, dstart);\n\n        Log.d (\"debug\", \"lsStart : \" + lsStart);\n\n        if (source != \"\") {\n\n            lsInsert = source.toString ();\n\n            Log.d (\"debug\", \"lsInsert: \" + lsInsert);\n\n        }\n\n        X1 = lsText.substring (dend);\n\n        Log.d (\"debug\", \"lsEnd   : \" + X1);\n\n        lsText = lsStart + lsInsert + X1;\n\n        Log.d (\"debug\", \"lsText  : \" + lsText);\n\n    }\n\n    Matcher loMatcher = moPattern.matcher (lsText);\n\n    Log.d (\"debug\", \"loMatcher.matches(): \" + loMatcher.matches () + \", lsText: \" + lsText);\n\n    if (! loMatcher.matches ()) {\n\n        return \"\";\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 801, "func": "public boolean hasSameAncestor (String person1, String person2) {\n\n    ArrayList < ArrayList < String > > X1 = X1 ();\n\n    int i = 0;\n\n    String name1 = person1;\n\n    String name2 = person2;\n\n    String parent1;\n\n    String parent2;\n\n    for (i = 0, parent1 = \"\"; i < X1.size (); i ++) {\n\n        if (name1.equals (X1.get (i).get (1))) {\n\n            parent1 = X1.get (i).get (0);\n\n            name1 = parent1;\n\n            i = - 1;\n\n        }\n\n    }\n\n    for (i = 0, parent2 = \"\"; i < X1.size (); i ++) {\n\n        if (name2.equals (X1.get (i).get (1))) {\n\n            parent2 = X1.get (i).get (0);\n\n            name2 = parent2;\n\n            i = - 1;\n\n        }\n\n    }\n\n    System.out.println (parent1);\n\n    System.out.println (parent2);\n\n    if (parent1.equals (parent2)) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 80101, "func": "public static X1 shuffle (X1 s) {\n\n    X1 shuffledString = \"\";\n\n    while (s.length () != 0) {\n\n        int index = (int) Math.floor (Math.random () * s.length ());\n\n        char c = s.charAt (index);\n\n        s = s.substring (0, index) + s.substring (index + 1);\n\n        shuffledString += c;\n\n    }\n\n    return shuffledString;\n\n}\n"}
{"idx": 80102, "func": "static String shuffle (String X1) {\n\n    if (X1.length () <= 1) return X1;\n\n    int split = X1.length () / 2;\n\n    String temp1 = shuffle (X1.substring (0, split));\n\n    String temp2 = shuffle (X1.substring (split));\n\n    if (Math.random () > 0.5) return temp1 + temp2;\n\n    else return temp2 + temp1;\n\n}\n"}
{"idx": 802, "func": "public boolean hasSameAncestor (String person1, String person2) {\n\n    if (allRelations.containsKey (person1)) {\n\n        if (ancestors.contains (allRelations.X1 (person1))) {\n\n            if (allRelations.containsKey (person2)) {\n\n                if (ancestors.contains (allRelations.X1 (person2))) {\n\n                    return true;\n\n                } else if (allRelations.containsKey (allRelations.X1 (person2))) {\n\n                    return hasSameAncestor (person1, allRelations.X1 (person2));\n\n                } else {\n\n                    return false;\n\n                }\n\n            } else {\n\n                return false;\n\n            }\n\n        } else {\n\n            ancestors.add (allRelations.X1 (person1));\n\n            if (allRelations.containsKey (allRelations.X1 (person1))) {\n\n                return hasSameAncestor (allRelations.X1 (person1), person2);\n\n            } else if (allRelations.containsKey (person2)) {\n\n                return hasSameAncestor (person1, allRelations.X1 (person2));\n\n            } else {\n\n                return false;\n\n            }\n\n        }\n\n    } else {\n\n        return false;\n\n    }\n\n}\n"}
{"idx": 80201, "func": "public static String shuffle (String s) {\n\n    String shuffledString = \"\";\n\n    while (s.length () != 0) {\n\n        int index = (int) Math.floor (Math.random () * s.length ());\n\n        char X1 = s.charAt (index);\n\n        s = s.substring (0, index) + s.substring (index + 1);\n\n        shuffledString += X1;\n\n    }\n\n    return shuffledString;\n\n}\n"}
{"idx": 80202, "func": "public static String shuffle (String text) {\n\n    char [] X1 = text.toCharArray ();\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        int randomIndex = (int) (Math.random () * X1.length);\n\n        char temp = X1 [i];\n\n        X1 [i] = X1 [randomIndex];\n\n        X1 [randomIndex] = temp;\n\n    }\n\n    return new String (X1);\n\n}\n"}
{"idx": 80301, "func": "public void shuffle (String input) {\n\n    List < Character > X1 = new ArrayList < Character > ();\n\n    for (char c : input.toCharArray ()) {\n\n        X1.add (c);\n\n    }\n\n    StringBuilder output = new StringBuilder (input.length ());\n\n    while (X1.size () != 0) {\n\n        int randPicker = (int) (Math.random () * X1.size ());\n\n        output.append (X1.remove (randPicker));\n\n    }\n\n    System.out.println (output.toString ());\n\n}\n"}
{"idx": 80302, "func": "static String shuffle (String text) {\n\n    if (text.X1 () <= 1) return text;\n\n    int split = text.X1 () / 2;\n\n    String temp1 = shuffle (text.substring (0, split));\n\n    String temp2 = shuffle (text.substring (split));\n\n    if (Math.random () > 0.5) return temp1 + temp2;\n\n    else return temp2 + temp1;\n\n}\n"}
{"idx": 80401, "func": "public void shuffle (String input) {\n\n    List < Character > characters = new ArrayList < Character > ();\n\n    for (char c : input.toCharArray ()) {\n\n        characters.add (c);\n\n    }\n\n    StringBuilder output = new StringBuilder (input.length ());\n\n    while (characters.size () != 0) {\n\n        int X1 = (int) (Math.random () * characters.size ());\n\n        output.append (characters.remove (X1));\n\n    }\n\n    System.out.println (output.toString ());\n\n}\n"}
{"idx": 80402, "func": "public static String shuffle (String text) {\n\n    char [] characters = text.toCharArray ();\n\n    for (int i = 0;\n\n    i < characters.length; i ++) {\n\n        int X1 = (int) (Math.random () * characters.length);\n\n        char temp = characters [i];\n\n        characters [i] = characters [X1];\n\n        characters [X1] = temp;\n\n    }\n\n    return new String (characters);\n\n}\n"}
{"idx": 80501, "func": "static String shuffle (String X1) {\n\n    if (X1.length () <= 1) return X1;\n\n    int split = X1.length () / 2;\n\n    String temp1 = shuffle (X1.substring (0, split));\n\n    String temp2 = shuffle (X1.substring (split));\n\n    if (Math.random () > 0.5) return temp1 + temp2;\n\n    else return temp2 + temp1;\n\n}\n"}
{"idx": 80502, "func": "public static String shuffle (String text) {\n\n    char [] characters = text.toCharArray ();\n\n    for (int X1 = 0;\n\n    X1 < characters.length; X1 ++) {\n\n        int randomIndex = (int) (Math.random () * characters.length);\n\n        char temp = characters [X1];\n\n        characters [X1] = characters [randomIndex];\n\n        characters [randomIndex] = temp;\n\n    }\n\n    return new String (characters);\n\n}\n"}
{"idx": 80601, "func": "public static String shuffle (String text) {\n\n    char [] characters = text.toCharArray ();\n\n    for (int X1 = 0;\n\n    X1 < characters.length; X1 ++) {\n\n        int randomIndex = (int) (Math.random () * characters.length);\n\n        char temp = characters [X1];\n\n        characters [X1] = characters [randomIndex];\n\n        characters [randomIndex] = temp;\n\n    }\n\n    return new String (characters);\n\n}\n"}
{"idx": 80602, "func": "public static void main (String [] args) {\n\n    JFrame frame = new JFrame (\"New Message\");\n\n    frame.setSize (100, 100);\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    JTextArea textArea = new JTextArea ();\n\n    frame.add (textArea, BorderLayout.CENTER);\n\n    JPanel X1 = new JPanel ();\n\n    X1.setLayout (new BoxLayout (X1, BoxLayout.Y_AXIS));\n\n    frame.add (X1, BorderLayout.NORTH);\n\n    String [] labels = {\"To: \", \"Cc: \", \"Bcc: \", \"Subject: \"};\n\n    for (int i = 0;\n\n    i < labels.length; i ++) {\n\n        JLabel l = new JLabel (labels [i]);\n\n        JTextField f = new JTextField ();\n\n        JPanel p = new JPanel (new BorderLayout ());\n\n        p.add (l, BorderLayout.WEST);\n\n        p.add (f, BorderLayout.CENTER);\n\n        X1.add (p);\n\n    }\n\n    frame.pack ();\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 80701, "func": "public static boolean deleteDirectory (File dir) {\n\n    if (! dir.exists () || ! dir.isDirectory ()) {\n\n        return false;\n\n    }\n\n    String [] files = dir.list ();\n\n    for (int X1 = 0, len = files.length;\n\n    X1 < len; X1 ++) {\n\n        File f = new File (dir, files [X1]);\n\n        if (f.isDirectory ()) {\n\n            deleteDirectory (f);\n\n        } else {\n\n            f.delete ();\n\n        }\n\n    }\n\n    return dir.delete ();\n\n}\n"}
{"idx": 80702, "func": "public static boolean deleteDirectory (File directory) {\n\n    if (directory.exists ()) {\n\n        File [] X1 = directory.listFiles ();\n\n        if (null != X1) {\n\n            for (int i = 0;\n\n            i < X1.length; i ++) {\n\n                if (X1 [i].isDirectory ()) {\n\n                    deleteDirectory (X1 [i]);\n\n                } else {\n\n                    X1 [i].delete ();\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return (directory.delete ());\n\n}\n"}
{"idx": 80801, "func": "public String toString () {\n\n    StringBuilder sb = new StringBuilder ();\n\n    sb.X1 (\"(\");\n\n    sb.X1 (a + \",\");\n\n    sb.X1 (b + \",\");\n\n    sb.X1 (v + \",\");\n\n    sb.X1 (w + \",\");\n\n    sb.X1 (m + \",\");\n\n    sb.X1 (n);\n\n    sb.X1 (\")\");\n\n    return sb.toString ();\n\n}\n"}
{"idx": 80802, "func": "public String toString () {\n\n    X1 sb = new X1 ();\n\n    sb.append (a + \"\\n\");\n\n    sb.append (b + \"\\n\");\n\n    for (A elem : aList) {\n\n        sb.append (elem + \"\\n\");\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 80901, "func": "public String toString () {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    X1.append (\"(\");\n\n    X1.append (a + \",\");\n\n    X1.append (b + \",\");\n\n    X1.append (v + \",\");\n\n    X1.append (w + \",\");\n\n    X1.append (m + \",\");\n\n    X1.append (n);\n\n    X1.append (\")\");\n\n    return X1.toString ();\n\n}\n"}
{"idx": 80902, "func": "public String toString () {\n\n    X1 sb = new X1 ();\n\n    sb.append (\"--------\" + v + \"\\n\");\n\n    sb.append (\"--------\" + w + \"\\n\");\n\n    for (B elem : bList) {\n\n        sb.append (elem + \"\\n\");\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 81001, "func": "public void run () {\n\n    final CardLayout cards = new CardLayout ();\n\n    final JPanel gui = new JPanel (cards);\n\n    gui.setBorder (new EmptyBorder (100, 300, 100, 300));\n\n    gui.setBackground (Color.WHITE);\n\n    gui.add (new JLabel (icon1), \"label \" + 1);\n\n    gui.add (new JLabel (icon2), \"label \" + 2);\n\n    gui.add (new JLabel (icon3), \"label \" + 3);\n\n    gui.add (new JLabel (icon4), \"label \" + 4);\n\n    gui.add (new JLabel (icon3), \"label \" + 5);\n\n    gui.add (new JLabel (icon2), \"label \" + 6);\n\n    ActionListener animate = new ActionListener () {\n\n        long X1 = - 1;\n\n        int frameCount = 0;\n\n        String timeString;\n\n        DecimalFormat format = new DecimalFormat (\"0.00\");\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            long time = System.nanoTime ();\n\n            if (X1 < 0) {\n\n                X1 = time;\n\n                timeString = \"00.00\";\n\n            } else if (time - X1 > 1000) {\n\n                long duration = time - X1;\n\n                double fps = 1000000000d * (double) frameCount / (double) duration;\n\n                timeString = format.format (fps);\n\n                frameCount = 0;\n\n                X1 = time;\n\n                System.out.println (timeString);\n\n            }\n\n            frameCount ++;\n\n            cards.next (gui);\n\n        }}\n\n    ;\n\n    Timer timer = new Timer (5, animate);\n\n    timer.start ();\n\n    JOptionPane.showMessageDialog (null, gui);\n\n    timer.stop ();\n\n}\n"}
{"idx": 81002, "func": "public void run () {\n\n    try {\n\n        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());\n\n    } catch (Exception ex) {\n\n    }\n\n    final X1 panel = new X1 ();\n\n    panel.setBackground (Color.RED);\n\n    final JFrame frame = new JFrame (\"Test\");\n\n    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n\n    frame.add (panel);\n\n    JButton change = new JButton (\"Switch\");\n\n    change.addActionListener (new ActionListener () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent e) {\n\n            long start = System.currentTimeMillis ();\n\n            frame.remove (panel);\n\n            long end = System.currentTimeMillis ();\n\n            X1 newPanel = new X1 ();\n\n            newPanel.setBackground (Color.BLUE);\n\n            frame.add (newPanel);\n\n            frame.validate ();\n\n        }}\n\n    );\n\n    frame.add (change, BorderLayout.SOUTH);\n\n    frame.setSize (100, 100);\n\n    frame.setLocationRelativeTo (null);\n\n    frame.setVisible (true);\n\n}\n"}
{"idx": 8101, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned X1, int dstart, int dend) {\n\n    String replacement = source.subSequence (start, end).toString ();\n\n    String newVal = X1.subSequence (0, dstart).toString () + replacement + X1.subSequence (dend, X1.length ()).toString ();\n\n    Matcher matcher = mPattern.matcher (newVal);\n\n    if (matcher.matches ()) return null;\n\n    if (TextUtils.isEmpty (source)) return X1.subSequence (dstart, dend);\n\n    else return \"\";\n\n}\n"}
{"idx": 8102, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned X1, int dstart, int dend) {\n\n    int dotPos = - 1;\n\n    int len = X1.length ();\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        char c = X1.charAt (i);\n\n        if (c == '.' || c == ',') {\n\n            dotPos = i;\n\n            break;\n\n        }\n\n    }\n\n    if (dotPos >= 0) {\n\n        if (source.equals (\".\") || source.equals (\",\")) {\n\n            return \"\";\n\n        }\n\n        if (dend <= dotPos) {\n\n            return null;\n\n        }\n\n        if (len - dotPos > decimalDigits) {\n\n            return \"\";\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 81101, "func": "public void actionPerformed (ActionEvent e) {\n\n    long time = X1.nanoTime ();\n\n    if (lastTime < 0) {\n\n        lastTime = time;\n\n        timeString = \"00.00\";\n\n    } else if (time - lastTime > 1000) {\n\n        long duration = time - lastTime;\n\n        double fps = 1000000000d * (double) frameCount / (double) duration;\n\n        timeString = format.format (fps);\n\n        frameCount = 0;\n\n        lastTime = time;\n\n        X1.out.println (timeString);\n\n    }\n\n    frameCount ++;\n\n    cards.next (gui);\n\n}\n"}
{"idx": 81102, "func": "public void actionPerformed (ActionEvent e) {\n\n    long start = System.currentTimeMillis ();\n\n    frame.remove (panel);\n\n    long end = System.currentTimeMillis ();\n\n    JPanel X1 = new JPanel ();\n\n    X1.setBackground (Color.BLUE);\n\n    frame.add (X1);\n\n    frame.validate ();\n\n}\n"}
{"idx": 81201, "func": "public static void setCursorColor (EditText X1,@ColorInt\n\nint color) {\n\n    try {\n\n        Field field = TextView.class.getDeclaredField (\"mCursorDrawableRes\");\n\n        field.setAccessible (true);\n\n        int drawableResId = field.getInt (X1);\n\n        Drawable drawable = ContextCompat.getDrawable (X1.getContext (), drawableResId);\n\n        drawable.setColorFilter (color, PorterDuff.Mode.SRC_IN);\n\n        Drawable [] drawables = {drawable, drawable};\n\n        if (Build.VERSION.SDK_INT == 15) {\n\n            Class < ? > drawableFieldClass = TextView.class;\n\n            field = drawableFieldClass.getDeclaredField (\"mCursorDrawable\");\n\n            field.setAccessible (true);\n\n            field.set (X1, drawables);\n\n        } else {\n\n            field = TextView.class.getDeclaredField (\"mEditor\");\n\n            field.setAccessible (true);\n\n            Object editor = field.get (X1);\n\n            field = editor.getClass ().getDeclaredField (\"mCursorDrawable\");\n\n            field.setAccessible (true);\n\n            field.set (editor, drawables);\n\n        }\n\n    } catch (Exception e) {\n\n        Log.e (LOG_TAG, \"-> \", e);\n\n    }\n\n}\n"}
{"idx": 81202, "func": "public static void setCursorColor (EditText view,@ColorInt\n\nint color) {\n\n    try {\n\n        Field X1 = TextView.class.getDeclaredField (\"mCursorDrawableRes\");\n\n        X1.setAccessible (true);\n\n        int drawableResId = X1.getInt (view);\n\n        X1 = TextView.class.getDeclaredField (\"mEditor\");\n\n        X1.setAccessible (true);\n\n        Object editor = X1.get (view);\n\n        Drawable drawable = ContextCompat.getDrawable (view.getContext (), drawableResId);\n\n        drawable.setColorFilter (color, PorterDuff.Mode.SRC_IN);\n\n        Drawable [] drawables = {drawable, drawable};\n\n        X1 = editor.getClass ().getDeclaredField (\"mCursorDrawable\");\n\n        X1.setAccessible (true);\n\n        X1.set (editor, drawables);\n\n    } catch (Exception ignored) {\n\n    }\n\n}\n"}
{"idx": 81301, "func": "@Override\n\npublic boolean X1 (int keyCode, KeyEvent event) {\n\n    if ((keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {\n\n        return true;\n\n    } else if ((keyCode == KeyEvent.KEYCODE_VOLUME_UP)) {\n\n        return true;\n\n    } else return super.X1 (keyCode, event);\n\n}\n"}
{"idx": 81302, "func": "@Override\n\npublic boolean onKeyDown (int keyCode, X1 event) {\n\n    super.onKeyDown (keyCode, event);\n\n    if (keyCode == X1.KEYCODE_VOLUME_DOWN) {\n\n        Toast.makeText (MainActivity.this, \"Down working\", Toast.LENGTH_SHORT).show ();\n\n        return true;\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 81401, "func": "private static void countString (String str, Character character) {\n\n    int [] counts = new int [MAX_CHAR];\n\n    char [] X1 = str.toCharArray ();\n\n    for (char ch : X1) {\n\n        if (character != null && character != ch) {\n\n            continue;\n\n        }\n\n        counts [ch] ++;\n\n    }\n\n    for (int i = 0;\n\n    i < counts.length; i ++) {\n\n        if (counts [i] > 0) {\n\n            System.out.println (\"Character \" + (char) i + \" appeared \" + counts [i] + \" times\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 81402, "func": "public static void countString (String str) {\n\n    if (str != null) {\n\n        int length = str.length ();\n\n        char X1 [] = str.toCharArray ();\n\n        Arrays.sort (X1);\n\n        if (length > 0) {\n\n            char x = X1 [0];\n\n            int count = 1;\n\n            for (int i = 1;\n\n            i < length; i ++) {\n\n                if (X1 [i] == x) {\n\n                    count ++;\n\n                } else {\n\n                    System.out.println (\"Number of Occurrence of '\" + X1 [i - 1] + \"' is: \" + count);\n\n                    x = X1 [i];\n\n                    count = 1;\n\n                }\n\n            }\n\n            System.out.println (\"Number of Occurrence of '\" + X1 [length - 1] + \"' is: \" + count);\n\n        }\n\n    }\n\n}\n"}
{"idx": 81501, "func": "private static void countString (String str, Character character) {\n\n    int [] counts = new int [MAX_CHAR];\n\n    char [] X1 = str.toCharArray ();\n\n    for (char ch : X1) {\n\n        if (character != null && character != ch) {\n\n            continue;\n\n        }\n\n        counts [ch] ++;\n\n    }\n\n    for (int i = 0;\n\n    i < counts.length; i ++) {\n\n        if (counts [i] > 0) {\n\n            System.out.println (\"Character \" + (char) i + \" appeared \" + counts [i] + \" times\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 81502, "func": "public static void countString (String str, char value) {\n\n    String [] arr = str.split (\"\");\n\n    X1 tempString = new X1 ();\n\n    for (String s : arr) {\n\n        tempString.append (s);\n\n        for (char ch : s.toCharArray ()) {\n\n            System.out.println (\"Number of Occurrence of \" + ch + \" is:\" + tempString.chars ().filter (i -> i == ch).count ());\n\n        }\n\n    }\n\n    if (! (Character.toString (value).isEmpty ())) {\n\n        X1 tempString2 = new X1 ();\n\n        for (String s : arr) {\n\n            tempString2.append (s);\n\n            for (char ch : s.toCharArray ()) {\n\n                if (ch == value) {\n\n                    System.out.println (\"Number of Occurrence of \" + ch + \" is:\" + tempString2.chars ().filter (i -> i == ch).count ());\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 81601, "func": "private static void countString (String str, Character character) {\n\n    int [] counts = new int [MAX_CHAR];\n\n    char [] chars = str.toCharArray ();\n\n    for (char ch : chars) {\n\n        if (character != null && character != ch) {\n\n            continue;\n\n        }\n\n        counts [ch] ++;\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < counts.length; X1 ++) {\n\n        if (counts [X1] > 0) {\n\n            System.out.println (\"Character \" + (char) X1 + \" appeared \" + counts [X1] + \" times\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 81602, "func": "public static void countString (String str, char searchKey) {\n\n    String X1 = \"\";\n\n    for (int i = 0;\n\n    i < str.length (); i ++) {\n\n        if (str.charAt (i) == searchKey) X1 += str.charAt (i) + \"\\n\";\n\n    }\n\n    System.out.println (X1 + \"\\nNumber of Occurrence of \" + searchKey + \" is \" + X1.length () + \" in string \" + str);\n\n}\n"}
{"idx": 81701, "func": "public static void countString (String str) {\n\n    if (str != null) {\n\n        int length = str.length ();\n\n        char ch [] = str.toCharArray ();\n\n        Arrays.sort (ch);\n\n        if (length > 0) {\n\n            char x = ch [0];\n\n            int X1 = 1;\n\n            for (int i = 1;\n\n            i < length; i ++) {\n\n                if (ch [i] == x) {\n\n                    X1 ++;\n\n                } else {\n\n                    System.out.println (\"Number of Occurrence of '\" + ch [i - 1] + \"' is: \" + X1);\n\n                    x = ch [i];\n\n                    X1 = 1;\n\n                }\n\n            }\n\n            System.out.println (\"Number of Occurrence of '\" + ch [length - 1] + \"' is: \" + X1);\n\n        }\n\n    }\n\n}\n"}
{"idx": 81702, "func": "public static void countString (String str, char value) {\n\n    String [] arr = str.split (\"\");\n\n    StringBuffer tempString = new StringBuffer ();\n\n    for (String s : arr) {\n\n        tempString.append (s);\n\n        for (char ch : s.toCharArray ()) {\n\n            System.out.println (\"Number of Occurrence of \" + ch + \" is:\" + tempString.chars ().X1 (i -> i == ch).count ());\n\n        }\n\n    }\n\n    if (! (Character.toString (value).isEmpty ())) {\n\n        StringBuffer tempString2 = new StringBuffer ();\n\n        for (String s : arr) {\n\n            tempString2.append (s);\n\n            for (char ch : s.toCharArray ()) {\n\n                if (ch == value) {\n\n                    System.out.println (\"Number of Occurrence of \" + ch + \" is:\" + tempString2.chars ().X1 (i -> i == ch).count ());\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 81801, "func": "public static void countString (String str) {\n\n    if (str != null) {\n\n        int length = str.length ();\n\n        char X1 [] = str.toCharArray ();\n\n        Arrays.sort (X1);\n\n        if (length > 0) {\n\n            char x = X1 [0];\n\n            int count = 1;\n\n            for (int i = 1;\n\n            i < length; i ++) {\n\n                if (X1 [i] == x) {\n\n                    count ++;\n\n                } else {\n\n                    System.out.println (\"Number of Occurrence of '\" + X1 [i - 1] + \"' is: \" + count);\n\n                    x = X1 [i];\n\n                    count = 1;\n\n                }\n\n            }\n\n            System.out.println (\"Number of Occurrence of '\" + X1 [length - 1] + \"' is: \" + count);\n\n        }\n\n    }\n\n}\n"}
{"idx": 81802, "func": "public static void countString (String str, char searchKey) {\n\n    String count = \"\";\n\n    for (int i = 0;\n\n    i < str.X1 (); i ++) {\n\n        if (str.charAt (i) == searchKey) count += str.charAt (i) + \"\\n\";\n\n    }\n\n    System.out.println (count + \"\\nNumber of Occurrence of \" + searchKey + \" is \" + count.X1 () + \" in string \" + str);\n\n}\n"}
{"idx": 81901, "func": "public static void countString (String str, char value) {\n\n    String [] X1 = str.split (\"\");\n\n    StringBuffer tempString = new StringBuffer ();\n\n    for (String s : X1) {\n\n        tempString.append (s);\n\n        for (char ch : s.toCharArray ()) {\n\n            System.out.println (\"Number of Occurrence of \" + ch + \" is:\" + tempString.chars ().filter (i -> i == ch).count ());\n\n        }\n\n    }\n\n    if (! (Character.toString (value).isEmpty ())) {\n\n        StringBuffer tempString2 = new StringBuffer ();\n\n        for (String s : X1) {\n\n            tempString2.append (s);\n\n            for (char ch : s.toCharArray ()) {\n\n                if (ch == value) {\n\n                    System.out.println (\"Number of Occurrence of \" + ch + \" is:\" + tempString2.chars ().filter (i -> i == ch).count ());\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 81902, "func": "public static void countString (String X1, char searchKey) {\n\n    String count = \"\";\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        if (X1.charAt (i) == searchKey) count += X1.charAt (i) + \"\\n\";\n\n    }\n\n    System.out.println (count + \"\\nNumber of Occurrence of \" + searchKey + \" is \" + count.length () + \" in string \" + X1);\n\n}\n"}
{"idx": 82001, "func": "public static String numLetters (String str) {\n\n    StringBuilder s = new StringBuilder (s);\n\n    String end = new String ();\n\n    int counter = 0;\n\n    char c, d;\n\n    for (int X1 = 0;\n\n    X1 < s.length (); X1 ++) {\n\n        c = s.charAt (X1);\n\n        for (int j = 0;\n\n        j < s.length (); j ++) {\n\n            d = s.charAt (j);\n\n            if (c == d) {\n\n                s.deleteCharAt (j);\n\n                if (X1 >= j) X1 --;\n\n                j --;\n\n                counter ++;\n\n            }\n\n        }\n\n        end = end + counter + c;\n\n        counter = 0;\n\n    }\n\n    return end;\n\n}\n"}
{"idx": 82002, "func": "public static String numLetters (String X1) {\n\n    int [] count = new int [26];\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        char c = X1.charAt (i);\n\n        count [(int) (c - 'a')] ++;\n\n    }\n\n    String ans = \"\";\n\n    for (int i = 0;\n\n    i < 26; i ++) {\n\n        if (count [i] != 0) {\n\n            ans += String.valueOf (count [i]) + (char) (i + 'a');\n\n        }\n\n    }\n\n    return ans;\n\n}\n"}
{"idx": 8201, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    String lsStart = \"\";\n\n    String lsInsert = \"\";\n\n    String lsEnd = \"\";\n\n    String lsText = \"\";\n\n    X1.d (\"debug\", moPattern.toString ());\n\n    X1.d (\"debug\", \"source: \" + source + \", start: \" + start + \", end:\" + end + \", dest: \" + dest + \", dstart: \" + dstart + \", dend: \" + dend);\n\n    lsText = dest.toString ();\n\n    if (lsText.length () > 0) {\n\n        lsStart = lsText.substring (0, dstart);\n\n        X1.d (\"debug\", \"lsStart : \" + lsStart);\n\n        if (source != \"\") {\n\n            lsInsert = source.toString ();\n\n            X1.d (\"debug\", \"lsInsert: \" + lsInsert);\n\n        }\n\n        lsEnd = lsText.substring (dend);\n\n        X1.d (\"debug\", \"lsEnd   : \" + lsEnd);\n\n        lsText = lsStart + lsInsert + lsEnd;\n\n        X1.d (\"debug\", \"lsText  : \" + lsText);\n\n    }\n\n    Matcher loMatcher = moPattern.matcher (lsText);\n\n    X1.d (\"debug\", \"loMatcher.matches(): \" + loMatcher.matches () + \", lsText: \" + lsText);\n\n    if (! loMatcher.matches ()) {\n\n        return \"\";\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 8202, "func": "public CharSequence filter (CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {\n\n    int X1 = - 1;\n\n    int len = dest.length ();\n\n    for (int i = 0;\n\n    i < len; i ++) {\n\n        char c = dest.charAt (i);\n\n        if (c == '.' || c == ',') {\n\n            X1 = i;\n\n            break;\n\n        }\n\n    }\n\n    if (X1 >= 0) {\n\n        if (source.equals (\".\") || source.equals (\",\")) {\n\n            return \"\";\n\n        }\n\n        if (dend <= X1) {\n\n            return null;\n\n        }\n\n        if (len - X1 > decimalDigits) {\n\n            return \"\";\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 82101, "func": "public void primeFactor () {\n\n    if (input > 1) {\n\n        for (int X1 = input;\n\n        X1 >= 1; X1 --) {\n\n            if (isPrime (X1)) {\n\n                if (divide (X1)) {\n\n                    System.out.println (\"Adding a new int...\");\n\n                    factors.add (X1);\n\n                    input = input / X1;\n\n                    primeFactor ();\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 82102, "func": "public void primeFactor () {\n\n    input = sc.nextInt ();\n\n    for (num = 1; num <= input; num ++) {\n\n        if (isPrime (num)) {\n\n            if (divide (num)) {\n\n                X1.out.println (\"Adding a new int...\");\n\n                factors.add (num);\n\n            }\n\n        }\n\n    }\n\n    for (int element : factors) {\n\n        X1.out.println (element);\n\n    }\n\n}\n"}
{"idx": 82201, "func": "public void filter (String [] words, BufferedReader reader) throws IOException {\n\n    String text;\n\n    while ((text = reader.readLine ()) != null) {\n\n        for (int X1 = 0;\n\n        X1 < words.length; X1 ++) {\n\n            if (text.toLowerCase ().contains (words [X1].toLowerCase ())) {\n\n                System.out.println (text);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 82202, "func": "public void filter (String [] words, String text) {\n\n    for (int X1 = 0;\n\n    X1 < words.length; X1 ++) {\n\n        if (text.toLowerCase ().contains (words [X1].toLowerCase ())) {\n\n            System.out.println (text);\n\n            break;\n\n        }\n\n    }\n\n}\n"}
{"idx": 82301, "func": "public void filter (String [] X1, BufferedReader reader) throws IOException {\n\n    String text;\n\n    while ((text = reader.readLine ()) != null) {\n\n        for (int i = 0;\n\n        i < X1.length; i ++) {\n\n            if (text.toLowerCase ().contains (X1 [i].toLowerCase ())) {\n\n                System.out.println (text);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 82302, "func": "public void filter (String [] X1, String text) {\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (text.toLowerCase ().contains (X1 [i].toLowerCase ())) {\n\n            System.out.println (text);\n\n            break;\n\n        }\n\n    }\n\n}\n"}
{"idx": 82401, "func": "public int [] solution (String S, int [] P, int [] K) {\n\n    char [] sc = S.toCharArray ();\n\n    int [] A = new int [sc.length];\n\n    int [] G = new int [sc.length];\n\n    int [] C = new int [sc.length];\n\n    int prevA = - 1, prevG = - 1, prevC = - 1;\n\n    for (int X1 = 0;\n\n    X1 < sc.length; X1 ++) {\n\n        if (sc [X1] == 'A') prevA = X1;\n\n        else if (sc [X1] == 'G') prevG = X1;\n\n        else if (sc [X1] == 'C') prevC = X1;\n\n        A [X1] = prevA;\n\n        G [X1] = prevG;\n\n        C [X1] = prevC;\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int X1 = 0;\n\n    X1 < P.length; X1 ++) {\n\n        if (A [K [X1]] >= P [X1] && A [K [X1]] <= K [X1]) {\n\n            result [X1] = 1;\n\n        } else if (C [K [X1]] >= P [X1] && C [K [X1]] <= K [X1]) {\n\n            result [X1] = 2;\n\n        } else if (G [K [X1]] >= P [X1] && G [K [X1]] <= K [X1]) {\n\n            result [X1] = 3;\n\n        } else {\n\n            result [X1] = 4;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82402, "func": "public static int [] solution (String S, int [] P, int [] Q) {\n\n    int [] arr = new int [S.length ()];\n\n    for (int X1 = 0;\n\n    X1 < S.length (); X1 ++) {\n\n        switch (S.charAt (X1)) {\n\n            case 'A' :\n\n                arr [X1] = 1;\n\n                break;\n\n            case 'C' :\n\n                arr [X1] = 2;\n\n                break;\n\n            case 'G' :\n\n                arr [X1] = 3;\n\n                break;\n\n            case 'T' :\n\n                arr [X1] = 4;\n\n                break;\n\n            default :\n\n                break;\n\n        }\n\n    }\n\n    segmentNode root = buildTree (arr, 0, S.length () - 1);\n\n    int [] result = new int [P.length];\n\n    for (int X1 = 0;\n\n    X1 < P.length; X1 ++) {\n\n        result [X1] = getMin (root, P [X1], Q [X1]);\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82501, "func": "public int [] solution (String S, int [] P, int [] K) {\n\n    char [] sc = S.toCharArray ();\n\n    int [] A = new int [sc.length];\n\n    int [] G = new int [sc.length];\n\n    int [] C = new int [sc.length];\n\n    int prevA = - 1, prevG = - 1, prevC = - 1;\n\n    for (int X1 = 0;\n\n    X1 < sc.length; X1 ++) {\n\n        if (sc [X1] == 'A') prevA = X1;\n\n        else if (sc [X1] == 'G') prevG = X1;\n\n        else if (sc [X1] == 'C') prevC = X1;\n\n        A [X1] = prevA;\n\n        G [X1] = prevG;\n\n        C [X1] = prevC;\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int X1 = 0;\n\n    X1 < P.length; X1 ++) {\n\n        if (A [K [X1]] >= P [X1] && A [K [X1]] <= K [X1]) {\n\n            result [X1] = 1;\n\n        } else if (C [K [X1]] >= P [X1] && C [K [X1]] <= K [X1]) {\n\n            result [X1] = 2;\n\n        } else if (G [K [X1]] >= P [X1] && G [K [X1]] <= K [X1]) {\n\n            result [X1] = 3;\n\n        } else {\n\n            result [X1] = 4;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82502, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    final char [] characterInput = S.toCharArray ();\n\n    final int [] integerInput = new int [characterInput.length];\n\n    for (int counter = 0;\n\n    counter < characterInput.length; counter ++) {\n\n        integerInput [counter] = characterMapping.get (characterInput [counter]);\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int index = 0;\n\n    index < P.length; index ++) {\n\n        if (P [index] == Q [index]) {\n\n            result [index] = integerInput [P [index]];\n\n            break;\n\n        }\n\n        final int [] X1 = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);\n\n        final int minimumValue = minimum (X1);\n\n        result [index] = minimumValue;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82601, "func": "public int [] solution (String S, int [] P, int [] K) {\n\n    char [] sc = S.toCharArray ();\n\n    int [] A = new int [sc.length];\n\n    int [] X1 = new int [sc.length];\n\n    int [] C = new int [sc.length];\n\n    int prevA = - 1, prevG = - 1, prevC = - 1;\n\n    for (int i = 0;\n\n    i < sc.length; i ++) {\n\n        if (sc [i] == 'A') prevA = i;\n\n        else if (sc [i] == 'G') prevG = i;\n\n        else if (sc [i] == 'C') prevC = i;\n\n        A [i] = prevA;\n\n        X1 [i] = prevG;\n\n        C [i] = prevC;\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int i = 0;\n\n    i < P.length; i ++) {\n\n        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {\n\n            result [i] = 1;\n\n        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {\n\n            result [i] = 2;\n\n        } else if (X1 [K [i]] >= P [i] && X1 [K [i]] <= K [i]) {\n\n            result [i] = 3;\n\n        } else {\n\n            result [i] = 4;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82602, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int [] answer = new int [P.length];\n\n    char [] chars = S.toCharArray ();\n\n    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];\n\n    for (int iii = 0;\n\n    iii < chars.length; iii ++) {\n\n        if (iii > 0) {\n\n            for (int X1 = 0;\n\n            X1 < 4; X1 ++) {\n\n                cumulativeAnswers [X1] [iii + 1] = cumulativeAnswers [X1] [iii];\n\n            }\n\n        }\n\n        switch (chars [iii]) {\n\n            case 'A' :\n\n                cumulativeAnswers [0] [iii + 1] ++;\n\n                break;\n\n            case 'C' :\n\n                cumulativeAnswers [1] [iii + 1] ++;\n\n                break;\n\n            case 'G' :\n\n                cumulativeAnswers [2] [iii + 1] ++;\n\n                break;\n\n            case 'T' :\n\n                cumulativeAnswers [3] [iii + 1] ++;\n\n                break;\n\n        }\n\n    }\n\n    for (int iii = 0;\n\n    iii < P.length; iii ++) {\n\n        for (int X1 = 0;\n\n        X1 < 4; X1 ++) {\n\n            if ((cumulativeAnswers [X1] [Q [iii] + 1] - cumulativeAnswers [X1] [P [iii]]) > 0) {\n\n                answer [iii] = X1 + 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 82701, "func": "public int [] solution (String S, int [] P, int [] K) {\n\n    char [] sc = S.toCharArray ();\n\n    int [] A = new int [sc.length];\n\n    int [] G = new int [sc.length];\n\n    int [] C = new int [sc.length];\n\n    int prevA = - 1, prevG = - 1, X1 = - 1;\n\n    for (int i = 0;\n\n    i < sc.length; i ++) {\n\n        if (sc [i] == 'A') prevA = i;\n\n        else if (sc [i] == 'G') prevG = i;\n\n        else if (sc [i] == 'C') X1 = i;\n\n        A [i] = prevA;\n\n        G [i] = prevG;\n\n        C [i] = X1;\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int i = 0;\n\n    i < P.length; i ++) {\n\n        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {\n\n            result [i] = 1;\n\n        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {\n\n            result [i] = 2;\n\n        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {\n\n            result [i] = 3;\n\n        } else {\n\n            result [i] = 4;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82702, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int N = S.length ();\n\n    int M = P.length;\n\n    int [] result = new int [M];\n\n    lastOccurrencesMap = new int [3] [N];\n\n    int lastA = - 1;\n\n    int lastC = - 1;\n\n    int lastG = - 1;\n\n    for (int i = 0;\n\n    i < N; i ++) {\n\n        char c = S.charAt (i);\n\n        if (c == 'A') {\n\n            lastA = i;\n\n        } else if (c == 'C') {\n\n            lastC = i;\n\n        } else if (c == 'G') {\n\n            lastG = i;\n\n        }\n\n        lastOccurrencesMap [0] [i] = lastA;\n\n        lastOccurrencesMap [1] [i] = lastC;\n\n        lastOccurrencesMap [2] [i] = lastG;\n\n    }\n\n    for (int i = 0;\n\n    i < M; i ++) {\n\n        int startIndex = P [i];\n\n        int endIndex = Q [i];\n\n        int minimum = 4;\n\n        for (int X1 = 0;\n\n        X1 < 3; X1 ++) {\n\n            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, X1);\n\n            if (lastOccurence != 0) {\n\n                minimum = X1 + 1;\n\n                break;\n\n            }\n\n        }\n\n        result [i] = minimum;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82801, "func": "public static int [] solution (String S, int [] P, int [] Q) {\n\n    int [] arr = new int [S.length ()];\n\n    for (int i = 0;\n\n    i < S.length (); i ++) {\n\n        switch (S.charAt (i)) {\n\n            case 'A' :\n\n                arr [i] = 1;\n\n                break;\n\n            case 'C' :\n\n                arr [i] = 2;\n\n                break;\n\n            case 'G' :\n\n                arr [i] = 3;\n\n                break;\n\n            case 'T' :\n\n                arr [i] = 4;\n\n                break;\n\n            default :\n\n                break;\n\n        }\n\n    }\n\n    segmentNode root = buildTree (arr, 0, S.length () - 1);\n\n    int [] X1 = new int [P.length];\n\n    for (int i = 0;\n\n    i < P.length; i ++) {\n\n        X1 [i] = getMin (root, P [i], Q [i]);\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 82802, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    final char [] X1 = S.toCharArray ();\n\n    final int [] integerInput = new int [X1.length];\n\n    for (int counter = 0;\n\n    counter < X1.length; counter ++) {\n\n        integerInput [counter] = characterMapping.get (X1 [counter]);\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int index = 0;\n\n    index < P.length; index ++) {\n\n        if (P [index] == Q [index]) {\n\n            result [index] = integerInput [P [index]];\n\n            break;\n\n        }\n\n        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);\n\n        final int minimumValue = minimum (subArray);\n\n        result [index] = minimumValue;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82901, "func": "public static int [] solution (String S, int [] P, int [] Q) {\n\n    int [] arr = new int [S.length ()];\n\n    for (int X1 = 0;\n\n    X1 < S.length (); X1 ++) {\n\n        switch (S.charAt (X1)) {\n\n            case 'A' :\n\n                arr [X1] = 1;\n\n                break;\n\n            case 'C' :\n\n                arr [X1] = 2;\n\n                break;\n\n            case 'G' :\n\n                arr [X1] = 3;\n\n                break;\n\n            case 'T' :\n\n                arr [X1] = 4;\n\n                break;\n\n            default :\n\n                break;\n\n        }\n\n    }\n\n    segmentNode root = buildTree (arr, 0, S.length () - 1);\n\n    int [] result = new int [P.length];\n\n    for (int X1 = 0;\n\n    X1 < P.length; X1 ++) {\n\n        result [X1] = getMin (root, P [X1], Q [X1]);\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 82902, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int [] answer = new int [P.length];\n\n    char [] chars = S.toCharArray ();\n\n    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];\n\n    for (int X1 = 0;\n\n    X1 < chars.length; X1 ++) {\n\n        if (X1 > 0) {\n\n            for (int zzz = 0;\n\n            zzz < 4; zzz ++) {\n\n                cumulativeAnswers [zzz] [X1 + 1] = cumulativeAnswers [zzz] [X1];\n\n            }\n\n        }\n\n        switch (chars [X1]) {\n\n            case 'A' :\n\n                cumulativeAnswers [0] [X1 + 1] ++;\n\n                break;\n\n            case 'C' :\n\n                cumulativeAnswers [1] [X1 + 1] ++;\n\n                break;\n\n            case 'G' :\n\n                cumulativeAnswers [2] [X1 + 1] ++;\n\n                break;\n\n            case 'T' :\n\n                cumulativeAnswers [3] [X1 + 1] ++;\n\n                break;\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < P.length; X1 ++) {\n\n        for (int zzz = 0;\n\n        zzz < 4; zzz ++) {\n\n            if ((cumulativeAnswers [zzz] [Q [X1] + 1] - cumulativeAnswers [zzz] [P [X1]]) > 0) {\n\n                answer [X1] = zzz + 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 83001, "func": "public static int [] solution (String S, int [] P, int [] Q) {\n\n    int [] X1 = new int [S.length ()];\n\n    for (int i = 0;\n\n    i < S.length (); i ++) {\n\n        switch (S.charAt (i)) {\n\n            case 'A' :\n\n                X1 [i] = 1;\n\n                break;\n\n            case 'C' :\n\n                X1 [i] = 2;\n\n                break;\n\n            case 'G' :\n\n                X1 [i] = 3;\n\n                break;\n\n            case 'T' :\n\n                X1 [i] = 4;\n\n                break;\n\n            default :\n\n                break;\n\n        }\n\n    }\n\n    segmentNode root = buildTree (X1, 0, S.length () - 1);\n\n    int [] result = new int [P.length];\n\n    for (int i = 0;\n\n    i < P.length; i ++) {\n\n        result [i] = getMin (root, P [i], Q [i]);\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83002, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int N = S.length ();\n\n    int M = P.length;\n\n    int [] result = new int [M];\n\n    lastOccurrencesMap = new int [3] [N];\n\n    int X1 = - 1;\n\n    int lastC = - 1;\n\n    int lastG = - 1;\n\n    for (int i = 0;\n\n    i < N; i ++) {\n\n        char c = S.charAt (i);\n\n        if (c == 'A') {\n\n            X1 = i;\n\n        } else if (c == 'C') {\n\n            lastC = i;\n\n        } else if (c == 'G') {\n\n            lastG = i;\n\n        }\n\n        lastOccurrencesMap [0] [i] = X1;\n\n        lastOccurrencesMap [1] [i] = lastC;\n\n        lastOccurrencesMap [2] [i] = lastG;\n\n    }\n\n    for (int i = 0;\n\n    i < M; i ++) {\n\n        int startIndex = P [i];\n\n        int endIndex = Q [i];\n\n        int minimum = 4;\n\n        for (int n = 0;\n\n        n < 3; n ++) {\n\n            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);\n\n            if (lastOccurence != 0) {\n\n                minimum = n + 1;\n\n                break;\n\n            }\n\n        }\n\n        result [i] = minimum;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 8301, "func": "protected void paintComponent (Graphics g) {\n\n    int X1 = this.getWidth ();\n\n    int height = this.getHeight ();\n\n    if (activeRedraw) {\n\n        if (repaintBuffer1) {\n\n            Graphics g1 = buffer1.getGraphics ();\n\n            g1.clearRect (0, 0, X1, height);\n\n            g1.setColor (Color.green);\n\n            g1.drawRect (0, 0, X1 - 1, height - 1);\n\n            g.drawImage (buffer1, 0, 0, null);\n\n            repaintBuffer1 = false;\n\n        }\n\n        double time = 2 * Math.PI * (System.currentTimeMillis () % 5000) / 5000.;\n\n        g.setColor (Color.RED);\n\n        if (rect != null) {\n\n            g.drawImage (buffer1, rect.x, rect.y, rect.x + rect.X1, rect.y + rect.height, rect.x, rect.y, rect.x + rect.X1, rect.y + rect.height, this);\n\n        }\n\n        rect = new Rectangle ((int) (Math.sin (time) * X1 / 3 + X1 / 2 - 20), (int) (Math.cos (time) * height / 3 + height / 2) - 20, 40, 40);\n\n        g.fillRect (rect.x, rect.y, rect.X1, rect.height);\n\n        activeRedraw = false;\n\n    }\n\n}\n"}
{"idx": 8302, "func": "protected void paintComponent (Graphics g) {\n\n    long start = System.nanoTime ();\n\n    super.paintComponent (g);\n\n    int w = this.getWidth ();\n\n    int X1 = this.getHeight ();\n\n    g.drawImage (background, 0, 0, this);\n\n    double theta = 2 * Math.PI * index ++ / 64;\n\n    g.setColor (Color.blue);\n\n    rect.setRect ((int) (Math.sin (theta) * w / 3 + w / 2 - RADIUS), (int) (Math.cos (theta) * X1 / 3 + X1 / 2 - RADIUS), 2 * RADIUS, 2 * RADIUS);\n\n    g.fillOval (rect.x, rect.y, rect.width, rect.height);\n\n    g.setColor (Color.white);\n\n    if (frameCount == FRAMES) {\n\n        averageTime = totalTime / FRAMES;\n\n        totalTime = 0;\n\n        frameCount = 0;\n\n    } else {\n\n        totalTime += System.nanoTime () - start;\n\n        frameCount ++;\n\n    }\n\n    String s = String.format (\"%1$5.3f\", averageTime / 1000000d);\n\n    g.drawString (s, 5, 16);\n\n}\n"}
{"idx": 83101, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    final char [] characterInput = S.toCharArray ();\n\n    final int [] integerInput = new int [characterInput.length];\n\n    for (int X1 = 0;\n\n    X1 < characterInput.length; X1 ++) {\n\n        integerInput [X1] = characterMapping.get (characterInput [X1]);\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int index = 0;\n\n    index < P.length; index ++) {\n\n        if (P [index] == Q [index]) {\n\n            result [index] = integerInput [P [index]];\n\n            break;\n\n        }\n\n        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);\n\n        final int minimumValue = minimum (subArray);\n\n        result [index] = minimumValue;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83102, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int [] answer = new int [P.length];\n\n    char [] chars = S.toCharArray ();\n\n    int [] [] X1 = new int [4] [chars.length + 1];\n\n    for (int iii = 0;\n\n    iii < chars.length; iii ++) {\n\n        if (iii > 0) {\n\n            for (int zzz = 0;\n\n            zzz < 4; zzz ++) {\n\n                X1 [zzz] [iii + 1] = X1 [zzz] [iii];\n\n            }\n\n        }\n\n        switch (chars [iii]) {\n\n            case 'A' :\n\n                X1 [0] [iii + 1] ++;\n\n                break;\n\n            case 'C' :\n\n                X1 [1] [iii + 1] ++;\n\n                break;\n\n            case 'G' :\n\n                X1 [2] [iii + 1] ++;\n\n                break;\n\n            case 'T' :\n\n                X1 [3] [iii + 1] ++;\n\n                break;\n\n        }\n\n    }\n\n    for (int iii = 0;\n\n    iii < P.length; iii ++) {\n\n        for (int zzz = 0;\n\n        zzz < 4; zzz ++) {\n\n            if ((X1 [zzz] [Q [iii] + 1] - X1 [zzz] [P [iii]]) > 0) {\n\n                answer [iii] = zzz + 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 83201, "func": "public int [] solution (String S, int [] X1, int [] Q) {\n\n    final char [] characterInput = S.toCharArray ();\n\n    final int [] integerInput = new int [characterInput.length];\n\n    for (int counter = 0;\n\n    counter < characterInput.length; counter ++) {\n\n        integerInput [counter] = characterMapping.get (characterInput [counter]);\n\n    }\n\n    int [] result = new int [X1.length];\n\n    for (int index = 0;\n\n    index < X1.length; index ++) {\n\n        if (X1 [index] == Q [index]) {\n\n            result [index] = integerInput [X1 [index]];\n\n            break;\n\n        }\n\n        final int [] subArray = Arrays.copyOfRange (integerInput, X1 [index], Q [index] + 1);\n\n        final int minimumValue = minimum (subArray);\n\n        result [index] = minimumValue;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83202, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int [] result = new int [P.length];\n\n    int [] factor1 = new int [S.length ()];\n\n    int [] factor2 = new int [S.length ()];\n\n    int [] factor3 = new int [S.length ()];\n\n    int [] factor4 = new int [S.length ()];\n\n    int X1 = 0;\n\n    int factor2Sum = 0;\n\n    int factor3Sum = 0;\n\n    int factor4Sum = 0;\n\n    for (int i = 0;\n\n    i < S.length (); i ++) {\n\n        switch (S.charAt (i)) {\n\n            case 'A' :\n\n                X1 ++;\n\n                break;\n\n            case 'C' :\n\n                factor2Sum ++;\n\n                break;\n\n            case 'G' :\n\n                factor3Sum ++;\n\n                break;\n\n            case 'T' :\n\n                factor4Sum ++;\n\n                break;\n\n            default :\n\n                break;\n\n        }\n\n        factor1 [i] = X1;\n\n        factor2 [i] = factor2Sum;\n\n        factor3 [i] = factor3Sum;\n\n        factor4 [i] = factor4Sum;\n\n    }\n\n    for (int i = 0;\n\n    i < P.length; i ++) {\n\n        int start = P [i];\n\n        int end = Q [i];\n\n        if (start == 0) {\n\n            if (factor1 [end] > 0) {\n\n                result [i] = 1;\n\n            } else if (factor2 [end] > 0) {\n\n                result [i] = 2;\n\n            } else if (factor3 [end] > 0) {\n\n                result [i] = 3;\n\n            } else {\n\n                result [i] = 4;\n\n            }\n\n        } else {\n\n            if (factor1 [end] > factor1 [start - 1]) {\n\n                result [i] = 1;\n\n            } else if (factor2 [end] > factor2 [start - 1]) {\n\n                result [i] = 2;\n\n            } else if (factor3 [end] > factor3 [start - 1]) {\n\n                result [i] = 3;\n\n            } else {\n\n                result [i] = 4;\n\n            }\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83301, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    final char [] characterInput = S.toCharArray ();\n\n    final int [] integerInput = new int [characterInput.length];\n\n    for (int X1 = 0;\n\n    X1 < characterInput.length; X1 ++) {\n\n        integerInput [X1] = characterMapping.get (characterInput [X1]);\n\n    }\n\n    int [] result = new int [P.length];\n\n    for (int index = 0;\n\n    index < P.length; index ++) {\n\n        if (P [index] == Q [index]) {\n\n            result [index] = integerInput [P [index]];\n\n            break;\n\n        }\n\n        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);\n\n        final int minimumValue = minimum (subArray);\n\n        result [index] = minimumValue;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83302, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int N = S.length ();\n\n    int M = P.length;\n\n    int [] result = new int [M];\n\n    lastOccurrencesMap = new int [3] [N];\n\n    int lastA = - 1;\n\n    int lastC = - 1;\n\n    int X1 = - 1;\n\n    for (int i = 0;\n\n    i < N; i ++) {\n\n        char c = S.charAt (i);\n\n        if (c == 'A') {\n\n            lastA = i;\n\n        } else if (c == 'C') {\n\n            lastC = i;\n\n        } else if (c == 'G') {\n\n            X1 = i;\n\n        }\n\n        lastOccurrencesMap [0] [i] = lastA;\n\n        lastOccurrencesMap [1] [i] = lastC;\n\n        lastOccurrencesMap [2] [i] = X1;\n\n    }\n\n    for (int i = 0;\n\n    i < M; i ++) {\n\n        int startIndex = P [i];\n\n        int endIndex = Q [i];\n\n        int minimum = 4;\n\n        for (int n = 0;\n\n        n < 3; n ++) {\n\n            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);\n\n            if (lastOccurence != 0) {\n\n                minimum = n + 1;\n\n                break;\n\n            }\n\n        }\n\n        result [i] = minimum;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83401, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int [] answer = new int [P.length];\n\n    char [] chars = S.toCharArray ();\n\n    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];\n\n    for (int X1 = 0;\n\n    X1 < chars.length; X1 ++) {\n\n        if (X1 > 0) {\n\n            for (int zzz = 0;\n\n            zzz < 4; zzz ++) {\n\n                cumulativeAnswers [zzz] [X1 + 1] = cumulativeAnswers [zzz] [X1];\n\n            }\n\n        }\n\n        switch (chars [X1]) {\n\n            case 'A' :\n\n                cumulativeAnswers [0] [X1 + 1] ++;\n\n                break;\n\n            case 'C' :\n\n                cumulativeAnswers [1] [X1 + 1] ++;\n\n                break;\n\n            case 'G' :\n\n                cumulativeAnswers [2] [X1 + 1] ++;\n\n                break;\n\n            case 'T' :\n\n                cumulativeAnswers [3] [X1 + 1] ++;\n\n                break;\n\n        }\n\n    }\n\n    for (int X1 = 0;\n\n    X1 < P.length; X1 ++) {\n\n        for (int zzz = 0;\n\n        zzz < 4; zzz ++) {\n\n            if ((cumulativeAnswers [zzz] [Q [X1] + 1] - cumulativeAnswers [zzz] [P [X1]]) > 0) {\n\n                answer [X1] = zzz + 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 83402, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int [] result = new int [P.length];\n\n    int [] factor1 = new int [S.length ()];\n\n    int [] factor2 = new int [S.length ()];\n\n    int [] X1 = new int [S.length ()];\n\n    int [] factor4 = new int [S.length ()];\n\n    int factor1Sum = 0;\n\n    int factor2Sum = 0;\n\n    int factor3Sum = 0;\n\n    int factor4Sum = 0;\n\n    for (int i = 0;\n\n    i < S.length (); i ++) {\n\n        switch (S.charAt (i)) {\n\n            case 'A' :\n\n                factor1Sum ++;\n\n                break;\n\n            case 'C' :\n\n                factor2Sum ++;\n\n                break;\n\n            case 'G' :\n\n                factor3Sum ++;\n\n                break;\n\n            case 'T' :\n\n                factor4Sum ++;\n\n                break;\n\n            default :\n\n                break;\n\n        }\n\n        factor1 [i] = factor1Sum;\n\n        factor2 [i] = factor2Sum;\n\n        X1 [i] = factor3Sum;\n\n        factor4 [i] = factor4Sum;\n\n    }\n\n    for (int i = 0;\n\n    i < P.length; i ++) {\n\n        int start = P [i];\n\n        int end = Q [i];\n\n        if (start == 0) {\n\n            if (factor1 [end] > 0) {\n\n                result [i] = 1;\n\n            } else if (factor2 [end] > 0) {\n\n                result [i] = 2;\n\n            } else if (X1 [end] > 0) {\n\n                result [i] = 3;\n\n            } else {\n\n                result [i] = 4;\n\n            }\n\n        } else {\n\n            if (factor1 [end] > factor1 [start - 1]) {\n\n                result [i] = 1;\n\n            } else if (factor2 [end] > factor2 [start - 1]) {\n\n                result [i] = 2;\n\n            } else if (X1 [end] > X1 [start - 1]) {\n\n                result [i] = 3;\n\n            } else {\n\n                result [i] = 4;\n\n            }\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83501, "func": "public int [] solution (String S, int [] X1, int [] Q) {\n\n    int [] answer = new int [X1.length];\n\n    char [] chars = S.toCharArray ();\n\n    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];\n\n    for (int iii = 0;\n\n    iii < chars.length; iii ++) {\n\n        if (iii > 0) {\n\n            for (int zzz = 0;\n\n            zzz < 4; zzz ++) {\n\n                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];\n\n            }\n\n        }\n\n        switch (chars [iii]) {\n\n            case 'A' :\n\n                cumulativeAnswers [0] [iii + 1] ++;\n\n                break;\n\n            case 'C' :\n\n                cumulativeAnswers [1] [iii + 1] ++;\n\n                break;\n\n            case 'G' :\n\n                cumulativeAnswers [2] [iii + 1] ++;\n\n                break;\n\n            case 'T' :\n\n                cumulativeAnswers [3] [iii + 1] ++;\n\n                break;\n\n        }\n\n    }\n\n    for (int iii = 0;\n\n    iii < X1.length; iii ++) {\n\n        for (int zzz = 0;\n\n        zzz < 4; zzz ++) {\n\n            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [X1 [iii]]) > 0) {\n\n                answer [iii] = zzz + 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    return answer;\n\n}\n"}
{"idx": 83502, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int N = S.length ();\n\n    int M = P.length;\n\n    int [] result = new int [M];\n\n    lastOccurrencesMap = new int [3] [N];\n\n    int lastA = - 1;\n\n    int lastC = - 1;\n\n    int X1 = - 1;\n\n    for (int i = 0;\n\n    i < N; i ++) {\n\n        char c = S.charAt (i);\n\n        if (c == 'A') {\n\n            lastA = i;\n\n        } else if (c == 'C') {\n\n            lastC = i;\n\n        } else if (c == 'G') {\n\n            X1 = i;\n\n        }\n\n        lastOccurrencesMap [0] [i] = lastA;\n\n        lastOccurrencesMap [1] [i] = lastC;\n\n        lastOccurrencesMap [2] [i] = X1;\n\n    }\n\n    for (int i = 0;\n\n    i < M; i ++) {\n\n        int startIndex = P [i];\n\n        int endIndex = Q [i];\n\n        int minimum = 4;\n\n        for (int n = 0;\n\n        n < 3; n ++) {\n\n            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);\n\n            if (lastOccurence != 0) {\n\n                minimum = n + 1;\n\n                break;\n\n            }\n\n        }\n\n        result [i] = minimum;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83601, "func": "public int [] solution (String X1, int [] P, int [] Q) {\n\n    int [] result = new int [P.length];\n\n    int [] factor1 = new int [X1.length ()];\n\n    int [] factor2 = new int [X1.length ()];\n\n    int [] factor3 = new int [X1.length ()];\n\n    int [] factor4 = new int [X1.length ()];\n\n    int factor1Sum = 0;\n\n    int factor2Sum = 0;\n\n    int factor3Sum = 0;\n\n    int factor4Sum = 0;\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        switch (X1.charAt (i)) {\n\n            case 'A' :\n\n                factor1Sum ++;\n\n                break;\n\n            case 'C' :\n\n                factor2Sum ++;\n\n                break;\n\n            case 'G' :\n\n                factor3Sum ++;\n\n                break;\n\n            case 'T' :\n\n                factor4Sum ++;\n\n                break;\n\n            default :\n\n                break;\n\n        }\n\n        factor1 [i] = factor1Sum;\n\n        factor2 [i] = factor2Sum;\n\n        factor3 [i] = factor3Sum;\n\n        factor4 [i] = factor4Sum;\n\n    }\n\n    for (int i = 0;\n\n    i < P.length; i ++) {\n\n        int start = P [i];\n\n        int end = Q [i];\n\n        if (start == 0) {\n\n            if (factor1 [end] > 0) {\n\n                result [i] = 1;\n\n            } else if (factor2 [end] > 0) {\n\n                result [i] = 2;\n\n            } else if (factor3 [end] > 0) {\n\n                result [i] = 3;\n\n            } else {\n\n                result [i] = 4;\n\n            }\n\n        } else {\n\n            if (factor1 [end] > factor1 [start - 1]) {\n\n                result [i] = 1;\n\n            } else if (factor2 [end] > factor2 [start - 1]) {\n\n                result [i] = 2;\n\n            } else if (factor3 [end] > factor3 [start - 1]) {\n\n                result [i] = 3;\n\n            } else {\n\n                result [i] = 4;\n\n            }\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83602, "func": "public int [] solution (String S, int [] P, int [] Q) {\n\n    int N = S.length ();\n\n    int M = P.length;\n\n    int [] result = new int [M];\n\n    lastOccurrencesMap = new int [3] [N];\n\n    int lastA = - 1;\n\n    int lastC = - 1;\n\n    int lastG = - 1;\n\n    for (int i = 0;\n\n    i < N; i ++) {\n\n        char c = S.charAt (i);\n\n        if (c == 'A') {\n\n            lastA = i;\n\n        } else if (c == 'C') {\n\n            lastC = i;\n\n        } else if (c == 'G') {\n\n            lastG = i;\n\n        }\n\n        lastOccurrencesMap [0] [i] = lastA;\n\n        lastOccurrencesMap [1] [i] = lastC;\n\n        lastOccurrencesMap [2] [i] = lastG;\n\n    }\n\n    for (int i = 0;\n\n    i < M; i ++) {\n\n        int startIndex = P [i];\n\n        int endIndex = Q [i];\n\n        int minimum = 4;\n\n        for (int X1 = 0;\n\n        X1 < 3; X1 ++) {\n\n            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, X1);\n\n            if (lastOccurence != 0) {\n\n                minimum = X1 + 1;\n\n                break;\n\n            }\n\n        }\n\n        result [i] = minimum;\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 83701, "func": "public static boolean isPrime (int n) {\n\n    int X1;\n\n    for (X1 = 2; X1 * X1 <= n; X1 ++) {\n\n        if (n % X1 == 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 83702, "func": "bool isPrime (int number) {\n\n    if (number < 2) return false;\n\n    if (number == 2) return true;\n\n    if (number % 2 == 0) return false;\n\n    for (int X1 = 3;\n\n    (X1 * X1) <= number; X1 += 2) {\n\n        if (number % X1 == 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 83801, "func": "@Override\n\npublic void tick (float delta) {\n\n    for (Entity e : entities) {\n\n        if (color == Color.WHITE) {\n\n            if (X1 (- 32, - 32) != null && X1 (- 32, - 32).getColor () == Color.BLACK) {\n\n                if (X1 (- 32, - 32).getStrength () < strength) {\n\n                    X1 (- 32, - 32).setStrength (- 50);\n\n                }\n\n            }\n\n        }\n\n        if (! inGame.entities.isEmpty () && strength <= 0) {\n\n            inGame.entities.remove (this);\n\n        }\n\n    }\n\n}\n"}
{"idx": 83802, "func": "@Override\n\npublic void X1 (float delta) {\n\n    Entity removeEntity = null;\n\n    for (Entity e : entities) {\n\n        e.X1 (delta);\n\n        if (e.checkStrength ()) {\n\n            removeEntity = e;\n\n            break;\n\n        }\n\n    }\n\n    if (removeEntity != null) {\n\n        entities.remove (removeEntity);\n\n    }\n\n    player.X1 (delta);\n\n}\n"}
{"idx": 83901, "func": "public static void main (String [] args) {\n\n    System.out.X1 (\"Please enter the length of your picure in inches:\");\n\n    final double length = console.nextDouble ();\n\n    System.out.X1 (\"Please enter the width of your picure in inches: \");\n\n    final double width = console.nextDouble ();\n\n    System.out.X1 (\"Please enter the type of frame: R or r (Regular), F or f (Fancy). \");\n\n    final char typeOfFrame = console.next ().charAt (0);\n\n    FrameType frameType = FrameType.valueOf (\"\" + Character.toUpperCase (typeOfFrame));\n\n    System.out.X1 (\"Would you like to add color?: Y for (Yes), N for (No): \");\n\n    final char choiceOfColor = console.next ().charAt (0);\n\n    final boolean color = Character.toUpperCase (choiceOfColor) == 'Y';\n\n    System.out.X1 (\"Would you like to add crowns? Enter Y (Yes), or N (No): \");\n\n    final char choiceOfCrowns = console.next ().charAt (0);\n\n    final boolean crowns = Character.toUpperCase (choiceOfCrowns) == 'Y';\n\n    final double priceOfCrowns;\n\n    if (crowns) {\n\n        System.out.X1 (\"How many crowns would you like? \");\n\n        final int numberOfCrowns = console.nextInt ();\n\n        priceOfCrowns = (numberOfCrowns * CROWNS);\n\n    } else {\n\n        priceOfCrowns = 0.0;\n\n    }\n\n    final double grandTotalPrice = priceOfCrowns + areaPriceInDollars (frameType, length, width, color);\n\n    System.out.printf (\"Your total comes to: $%.2f%n\", grandTotalPrice);\n\n}\n"}
{"idx": 83902, "func": "public static void main (String [] args) {\n\n    final double length;\n\n    final double width;\n\n    final char typeOfFrame;\n\n    final char choiceOfColor;\n\n    System.out.println (\"Please enter the length of your picure in inches:\");\n\n    length = console.nextDouble ();\n\n    System.out.println (\"Please enter the width of your picure in inches: \");\n\n    width = console.nextDouble ();\n\n    System.out.println (\"Please enter the type of frame: R or r (Regular), F or f (Fancy). \");\n\n    typeOfFrame = console.next ().charAt (0);\n\n    System.out.println (\"Would you like to add color?: Y for (Yes), N for (No): \");\n\n    choiceOfColor = console.next ().charAt (0);\n\n    if (! (isFrameType (typeOfFrame))) {\n\n    } else {\n\n        final double area;\n\n        final double perimeter;\n\n        final double priceOfFrame;\n\n        final double priceOfCardboard;\n\n        final double priceOfGlass;\n\n        area = (length * width);\n\n        perimeter = (2 * length) + (2 * width);\n\n        priceOfFrame = (perimeter * REGULAR_FRAME);\n\n        priceOfCardboard = (area * CARDBOARD);\n\n        priceOfGlass = (area * GLASS);\n\n        if (isValidChoice (choiceOfColor)) {\n\n            final double priceOfColor;\n\n            final double finalPrice;\n\n            final char X1;\n\n            final double grandTotalPrice;\n\n            if (choiceOfColor == 'N') {\n\n                finalPrice = (priceOfFrame + priceOfCardboard + priceOfGlass);\n\n            } else {\n\n                priceOfColor = (area * COLOR);\n\n                finalPrice = (priceOfFrame + priceOfColor + priceOfCardboard + priceOfGlass);\n\n            }\n\n            System.out.println (\"Would you like to add crowns? Enter Y (Yes), or N (No): \");\n\n            X1 = console.next ().charAt (0);\n\n            if (isValidChoice (X1)) {\n\n                if (X1 == 'Y') {\n\n                    final double crownFinalPrice;\n\n                    final int numberOfCrowns;\n\n                    System.out.println (\"How many crowns would you like? \");\n\n                    numberOfCrowns = console.nextInt ();\n\n                    crownFinalPrice = (numberOfCrowns * CROWNS);\n\n                    grandTotalPrice = (crownFinalPrice + finalPrice);\n\n                } else {\n\n                    grandTotalPrice = finalPrice;\n\n                }\n\n                System.out.printf (\"Your total comes to: $%.2f%n\", grandTotalPrice);\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 84001, "func": "public static String join (String [] strings, int X1, String separator) {\n\n    StringBuffer sb = new StringBuffer ();\n\n    for (int i = X1;\n\n    i < strings.length; i ++) {\n\n        if (i != X1) sb.append (separator);\n\n        sb.append (strings [i]);\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 84002, "func": "public static String join (String separator, String...X1) {\n\n    if (X1.length == 0) return \"\";\n\n    char [] sep = separator.toCharArray ();\n\n    int totalSize = (X1.length - 1) * sep.length;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] == null) X1 [i] = \"\";\n\n        else totalSize += X1 [i].length ();\n\n    }\n\n    char [] joined = new char [totalSize];\n\n    int pos = 0;\n\n    for (int i = 0, end = X1.length - 1;\n\n    i < end; i ++) {\n\n        System.arraycopy (X1 [i].toCharArray (), 0, joined, pos, X1 [i].length ());\n\n        pos += X1 [i].length ();\n\n        System.arraycopy (sep, 0, joined, pos, sep.length);\n\n        pos += sep.length;\n\n    }\n\n    System.arraycopy (X1 [X1.length - 1].toCharArray (), 0, joined, pos, X1 [X1.length - 1].length ());\n\n    return new String (joined);\n\n}\n"}
{"idx": 8401, "func": "static int gcd (int a, int X1) {\n\n    if (a == 0 || X1 == 0) return 0;\n\n    if (a == X1) return a;\n\n    if (a > X1) return gcd (a - X1, X1);\n\n    return gcd (a, X1 - a);\n\n}\n"}
{"idx": 8402, "func": "public static final int gcd (int X1, int b) {\n\n    if (X1 == Integer.MIN_VALUE) {\n\n        if (b == Integer.MIN_VALUE) throw new IllegalArgumentException (\"gcd() is greater than Integer.MAX_VALUE\");\n\n        return 1 << Integer.numberOfTrailingZeros (Math.abs (b));\n\n    }\n\n    if (b == Integer.MIN_VALUE) return 1 << Integer.numberOfTrailingZeros (Math.abs (X1));\n\n    X1 = Math.abs (X1);\n\n    b = Math.abs (b);\n\n    if (X1 == 0) return b;\n\n    if (b == 0) return X1;\n\n    int factorsOfTwoInA = Integer.numberOfTrailingZeros (X1), factorsOfTwoInB = Integer.numberOfTrailingZeros (b), commonFactorsOfTwo = Math.min (factorsOfTwoInA, factorsOfTwoInB);\n\n    X1>>= factorsOfTwoInA;\n\n    b>>= factorsOfTwoInB;\n\n    while (X1 != b) {\n\n        if (X1 > b) {\n\n            X1 = (X1 - b);\n\n            X1>>= Integer.numberOfTrailingZeros (X1);\n\n        } else {\n\n            b = (b - X1);\n\n            b>>= Integer.numberOfTrailingZeros (b);\n\n        }\n\n    }\n\n    return X1 << commonFactorsOfTwo;\n\n}\n"}
{"idx": 84101, "func": "public static String join (String separator, String...values) {\n\n    StringBuilder sb = new StringBuilder (128);\n\n    int X1 = 0;\n\n    for (String s : values) {\n\n        if (s != null) {\n\n            sb.append (s);\n\n            X1 = sb.length ();\n\n            sb.append (separator);\n\n        }\n\n    }\n\n    return sb.substring (0, X1);\n\n}\n"}
{"idx": 84102, "func": "public static String join (String separator, String...values) {\n\n    if (values.length == 0) return \"\";\n\n    char [] X1 = separator.toCharArray ();\n\n    int totalSize = (values.length - 1) * X1.length;\n\n    for (int i = 0;\n\n    i < values.length; i ++) {\n\n        if (values [i] == null) values [i] = \"\";\n\n        else totalSize += values [i].length ();\n\n    }\n\n    char [] joined = new char [totalSize];\n\n    int pos = 0;\n\n    for (int i = 0, end = values.length - 1;\n\n    i < end; i ++) {\n\n        System.arraycopy (values [i].toCharArray (), 0, joined, pos, values [i].length ());\n\n        pos += values [i].length ();\n\n        System.arraycopy (X1, 0, joined, pos, X1.length);\n\n        pos += X1.length;\n\n    }\n\n    System.arraycopy (values [values.length - 1].toCharArray (), 0, joined, pos, values [values.length - 1].length ());\n\n    return new String (joined);\n\n}\n"}
{"idx": 84201, "func": "public static String sequenceNums (int [] nums) {\n\n    StringBuilder sb = new StringBuilder ();\n\n    int X1 = nums [0];\n\n    int previous = nums [0];\n\n    int current;\n\n    int expected = previous + 1;\n\n    int size = nums.length;\n\n    for (int i = 1;\n\n    i < size; i ++) {\n\n        current = nums [i];\n\n        expected = previous + 1;\n\n        if (current != expected) {\n\n            addRange (sb, X1, previous);\n\n            X1 = current;\n\n        }\n\n        previous = current;\n\n    }\n\n    addRange (sb, X1, nums [size - 1]);\n\n    return sb.toString ();\n\n}\n"}
{"idx": 84202, "func": "public static String sequenceNums (int [] X1) {\n\n    StringBuilder sb = new StringBuilder ();\n\n    int rangeStart = X1 [0];\n\n    int previous = X1 [0];\n\n    int current;\n\n    int expected = previous + 1;\n\n    for (int i = 1;\n\n    i < X1.length; i ++) {\n\n        current = X1 [i];\n\n        expected = previous + 1;\n\n        if (current != expected || i == (X1.length - 1)) {\n\n            if (current == rangeStart) {\n\n                sb.append (previous + \",\");\n\n            } else {\n\n                if (rangeStart != previous) {\n\n                    if (i == X1.length - 1) sb.append (rangeStart + \"-\" + current);\n\n                    else sb.append (rangeStart + \"-\" + previous + \",\");\n\n                } else {\n\n                    if (i == X1.length - 1) sb.append (rangeStart + \",\" + current);\n\n                    else sb.append (rangeStart + \",\");\n\n                }\n\n            }\n\n            rangeStart = current;\n\n        }\n\n        previous = current;\n\n    }\n\n    if (sb.charAt (sb.length () - 1) == ',') {\n\n        sb.deleteCharAt (sb.length () - 1);\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 84301, "func": "public static String sequenceNums (int [] nums) {\n\n    StringBuilder sb = new StringBuilder ();\n\n    int X1 = nums [0];\n\n    int previous = nums [0];\n\n    int current;\n\n    int expected = previous + 1;\n\n    int size = nums.length;\n\n    for (int i = 1;\n\n    i < size; i ++) {\n\n        current = nums [i];\n\n        expected = previous + 1;\n\n        if (current != expected) {\n\n            addRange (sb, X1, previous);\n\n            X1 = current;\n\n        }\n\n        previous = current;\n\n    }\n\n    addRange (sb, X1, nums [size - 1]);\n\n    return sb.toString ();\n\n}\n"}
{"idx": 84302, "func": "public static String sequenceNums (int [] nums) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    if (nums.length == 0) return X1.toString ();\n\n    int begin = nums [0], end = nums [0];\n\n    for (int cur : nums) if (cur - end <= 1) end = cur;\n\n    else {\n\n        appendRange (X1, begin, end);\n\n        begin = end = cur;\n\n    }\n\n    appendRange (X1, begin, end);\n\n    return X1.substring (1);\n\n}\n"}
{"idx": 84401, "func": "public static String sequenceNums (int [] X1) {\n\n    StringBuilder sb = new StringBuilder ();\n\n    int rangeStart = X1 [0];\n\n    int previous = X1 [0];\n\n    int current;\n\n    int expected = previous + 1;\n\n    for (int i = 1;\n\n    i < X1.length; i ++) {\n\n        current = X1 [i];\n\n        expected = previous + 1;\n\n        if (current != expected || i == (X1.length - 1)) {\n\n            if (current == rangeStart) {\n\n                sb.append (previous + \",\");\n\n            } else {\n\n                if (rangeStart != previous) {\n\n                    if (i == X1.length - 1) sb.append (rangeStart + \"-\" + current);\n\n                    else sb.append (rangeStart + \"-\" + previous + \",\");\n\n                } else {\n\n                    if (i == X1.length - 1) sb.append (rangeStart + \",\" + current);\n\n                    else sb.append (rangeStart + \",\");\n\n                }\n\n            }\n\n            rangeStart = current;\n\n        }\n\n        previous = current;\n\n    }\n\n    if (sb.charAt (sb.length () - 1) == ',') {\n\n        sb.deleteCharAt (sb.length () - 1);\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 84402, "func": "public static String sequenceNums (int [] nums) {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    if (nums.length == 0) return X1.toString ();\n\n    int begin = nums [0], end = nums [0];\n\n    for (int cur : nums) if (cur - end <= 1) end = cur;\n\n    else {\n\n        appendRange (X1, begin, end);\n\n        begin = end = cur;\n\n    }\n\n    appendRange (X1, begin, end);\n\n    return X1.substring (1);\n\n}\n"}
{"idx": 84501, "func": "public int tortoiseMoves () {\n\n    int i = tGen ();\n\n    if (i >= 1 && i <= 5) {\n\n        int X1 = 3;\n\n        return X1;\n\n    } else if (i >= 6 && i <= 8) {\n\n        int slowplod = 1;\n\n        return slowplod;\n\n    } else if (i >= 9 && i <= 10) {\n\n        int slip = - 6;\n\n        return slip;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n"}
{"idx": 84502, "func": "public int tortoiseMoves () {\n\n    int i = tGen ();\n\n    if (i >= 1 && i <= 5) {\n\n        int X1 = 3;\n\n        return X1;\n\n    } else if (i >= 6 && i <= 8) {\n\n        int slowplod = 1;\n\n        return slowplod;\n\n    } else if (i >= 9 && i <= 10) {\n\n        int slip = - 6;\n\n        return slip;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n"}
{"idx": 84601, "func": "public int tortoiseMoves () {\n\n    int i = tGen ();\n\n    if (i >= 1 && i <= 5) {\n\n        int fastplod = 3;\n\n        return fastplod;\n\n    }\n\n    if (i >= 6 && i <= 8) {\n\n        int X1 = 1;\n\n        return X1;\n\n    }\n\n    if (i >= 9 && i <= 10) {\n\n        int slip = - 6;\n\n        return slip;\n\n    }\n\n    return someDefaultValue;\n\n}\n"}
{"idx": 84602, "func": "public int tortoiseMoves () {\n\n    int i = tGen ();\n\n    if (i >= 1 && i <= 5) {\n\n        int fastplod = 3;\n\n        return fastplod;\n\n    }\n\n    if (i >= 6 && i <= 8) {\n\n        int X1 = 1;\n\n        return X1;\n\n    }\n\n    if (i >= 9 && i <= 10) {\n\n        int slip = - 6;\n\n        return slip;\n\n    }\n\n    return someDefaultValue;\n\n}\n"}
{"idx": 84701, "func": "public static void main (String args []) {\n\n    int a;\n\n    float b;\n\n    String s;\n\n    Scanner in = new Scanner (System.in);\n\n    System.X1.println (\"Enter a string\");\n\n    s = in.nextLine ();\n\n    System.X1.println (\"You entered string \" + s);\n\n    System.X1.println (\"Enter an integer\");\n\n    a = in.nextInt ();\n\n    System.X1.println (\"You entered integer \" + a);\n\n    System.X1.println (\"Enter a float\");\n\n    b = in.nextFloat ();\n\n    System.X1.println (\"You entered float \" + b);\n\n}\n"}
{"idx": 84702, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    final int valid = 6;\n\n    Scanner one = new Scanner (System.in);\n\n    System.out.println (\"Enter your username: \");\n\n    String s = one.nextLine ();\n\n    if (s.length () < valid) {\n\n        System.out.println (\"Enter a valid username\");\n\n        System.out.println (\"User name must contain \" + valid + \" characters\");\n\n        System.out.println (\"Enter again: \");\n\n        s = one.nextLine ();\n\n    }\n\n    System.out.println (\"Username accepted: \" + s);\n\n    Scanner two = new Scanner (System.in);\n\n    System.out.println (\"Enter your age: \");\n\n    int X1 = two.nextInt ();\n\n    System.out.println (\"Age accepted: \" + X1);\n\n    Scanner three = new Scanner (System.in);\n\n    System.out.println (\"Enter your sex: \");\n\n    String sex = three.nextLine ();\n\n    System.out.println (\"Sex accepted: \" + sex);\n\n}\n"}
{"idx": 84801, "func": "public static void main (String [] arguments) {\n\n    Scanner input = new Scanner (System.in);\n\n    String username;\n\n    double age;\n\n    String gender;\n\n    String marital_status;\n\n    int telephone_number;\n\n    Scanner one = new Scanner (System.in);\n\n    System.out.X1 (\"Enter Name:\");\n\n    username = one.next ();\n\n    System.out.X1 (\"Name accepted \" + username);\n\n    Scanner two = new Scanner (System.in);\n\n    System.out.X1 (\"Enter Age:\");\n\n    age = two.nextDouble ();\n\n    System.out.X1 (\"Age accepted \" + age);\n\n    Scanner three = new Scanner (System.in);\n\n    System.out.X1 (\"Enter Gender:\");\n\n    gender = three.next ();\n\n    System.out.X1 (\"Gender accepted \" + gender);\n\n    Scanner four = new Scanner (System.in);\n\n    System.out.X1 (\"Enter Marital status:\");\n\n    marital_status = four.next ();\n\n    System.out.X1 (\"Marital status accepted \" + marital_status);\n\n    Scanner five = new Scanner (System.in);\n\n    System.out.X1 (\"Enter Telephone number:\");\n\n    telephone_number = five.nextInt ();\n\n    System.out.X1 (\"Telephone number accepted \" + telephone_number);\n\n}\n"}
{"idx": 84802, "func": "public static void main (X1 [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    final int valid = 6;\n\n    Scanner one = new Scanner (System.in);\n\n    System.out.println (\"Enter your username: \");\n\n    X1 s = one.nextLine ();\n\n    if (s.length () < valid) {\n\n        System.out.println (\"Enter a valid username\");\n\n        System.out.println (\"User name must contain \" + valid + \" characters\");\n\n        System.out.println (\"Enter again: \");\n\n        s = one.nextLine ();\n\n    }\n\n    System.out.println (\"Username accepted: \" + s);\n\n    Scanner two = new Scanner (System.in);\n\n    System.out.println (\"Enter your age: \");\n\n    int a = two.nextInt ();\n\n    System.out.println (\"Age accepted: \" + a);\n\n    Scanner three = new Scanner (System.in);\n\n    System.out.println (\"Enter your sex: \");\n\n    X1 sex = three.nextLine ();\n\n    System.out.println (\"Sex accepted: \" + sex);\n\n}\n"}
{"idx": 84901, "func": "public static void main (String [] args) {\n\n    int number1, number2, sum;\n\n    Scanner X1 = new Scanner (System.in);\n\n    System.out.println (\"Enter First multiple\");\n\n    number1 = X1.nextInt ();\n\n    System.out.println (\"Enter second multiple\");\n\n    number2 = X1.nextInt ();\n\n    sum = number1 * number2;\n\n    System.out.printf (\"The product of both number is %d\", sum);\n\n}\n"}
{"idx": 84902, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.X1);\n\n    final int valid = 6;\n\n    Scanner one = new Scanner (System.X1);\n\n    System.out.println (\"Enter your username: \");\n\n    String s = one.nextLine ();\n\n    if (s.length () < valid) {\n\n        System.out.println (\"Enter a valid username\");\n\n        System.out.println (\"User name must contain \" + valid + \" characters\");\n\n        System.out.println (\"Enter again: \");\n\n        s = one.nextLine ();\n\n    }\n\n    System.out.println (\"Username accepted: \" + s);\n\n    Scanner two = new Scanner (System.X1);\n\n    System.out.println (\"Enter your age: \");\n\n    int a = two.nextInt ();\n\n    System.out.println (\"Age accepted: \" + a);\n\n    Scanner three = new Scanner (System.X1);\n\n    System.out.println (\"Enter your sex: \");\n\n    String sex = three.nextLine ();\n\n    System.out.println (\"Sex accepted: \" + sex);\n\n}\n"}
{"idx": 85001, "func": "private static int countZeros (int [] f) {\n\n    for (int X1 = f.length - 1;\n\n    X1 >= 0; X1 --) {\n\n        if (f [X1] != 0 && X1 > 0 && f [X1 - 1] == 0) {\n\n            X1 --;\n\n            int count = 0;\n\n            while (X1 >= 0 && f [X1] == 0) {\n\n                X1 --;\n\n                count ++;\n\n            }\n\n            if (X1 == 0) return null;\n\n            else return count;\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 85002, "func": "private static int countZeros (int [] f) {\n\n    int start = 0, end = 0, X1 = 0;\n\n    for (int i = 1;\n\n    i < f.length; i ++) {\n\n        if (f [i - 1] != 0 && f [i] == 0) {\n\n            start = i;\n\n        } else if (f [i - 1] == 0 && f [i] != 0 && start > 0) {\n\n            end = i;\n\n            X1 += end - start;\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 8501, "func": "public void start (Stage stage) {\n\n    final HTMLEditor X1 = new HTMLEditor ();\n\n    stage.setScene (new Scene (X1));\n\n    stage.setWidth (300);\n\n    stage.setHeight (200);\n\n    stage.show ();\n\n    addCustomToolBarTo (X1);\n\n    printChildren (X1, 20);\n\n    moveFromTo (X1, \"PopupButton\", 0, \"ToolBar\", 2);\n\n    moveFromTo (X1, \"PopupButton\", 1, \"ToolBar\", 2);\n\n    moveFromTo (X1, \"Separator\", 4, \"ToolBar\", 2);\n\n    moveFromTo (X1, \"ComboBox\", 2, \"ToolBar\", 2);\n\n    moveFromTo (X1, \"Separator\", 5, \"ToolBar\", 2);\n\n    moveFromTo (X1, \"ToggleButton\", 6, \"ToolBar\", 2);\n\n    moveFromTo (X1, \"ToggleButton\", 7, \"ToolBar\", 2);\n\n    moveFromTo (X1, \"ToggleButton\", 8, \"ToolBar\", 2);\n\n    removeFrom (X1, \"ToolBar\", 1);\n\n    removeFrom (X1, \"ToolBar\", 0);\n\n}\n"}
{"idx": 8502, "func": "public void start (Stage primaryStage) {\n\n    final HTMLEditor htmlEditor = new HTMLEditor ();\n\n    primaryStage.setScene (new Scene (htmlEditor));\n\n    primaryStage.show ();\n\n    for (Node X1 = htmlEditor.lookup (\".tool-bar\");\n\n    X1 != null; X1 = htmlEditor.lookup (\".tool-bar\")) {\n\n        ((Pane) X1.getParent ()).getChildren ().remove (X1);\n\n    }\n\n}\n"}
{"idx": 85101, "func": "public static double [] [] amountOTP (double [] [] a, int x) {\n\n    if (x > a.length) return a;\n\n    for (double [] arr : a) if (arr.length < x) return a;\n\n    double [] [] newArray = new double [x] [x];\n\n    for (int X1 = 0;\n\n    X1 < x; X1 ++) for (int j = 0;\n\n    j < x; j ++) newArray [X1] [j] = a [X1] [j];\n\n    return newArray;\n\n}\n"}
{"idx": 85102, "func": "public static double [] [] amountOTP (double [] [] X1, int x) {\n\n    double [] [] b = new double [x] [x];\n\n    x = Math.min (x, X1.length);\n\n    for (int i = 0;\n\n    i < x; i ++) for (int j = 0;\n\n    j < x; j ++) b [i] [j] = X1 [i] [j];\n\n    return b;\n\n}\n"}
{"idx": 85201, "func": "public static void main (String [] args) throws Exception {\n\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();\n\n    DocumentBuilder X1 = dbf.newDocumentBuilder ();\n\n    Document document = X1.parse (new File (\"input.xml\"));\n\n    NodeList nodeList = document.getElementsByTagName (\"Item\");\n\n    for (int x = 0, size = nodeList.getLength ();\n\n    x < size; x ++) {\n\n        System.out.println (nodeList.item (x).getAttributes ().getNamedItem (\"name\").getNodeValue ());\n\n    }\n\n}\n"}
{"idx": 85202, "func": "public static void main (String [] s) throws VTDException {\n\n    VTDGen vg = new VTDGen ();\n\n    if (! vg.parseFile (\"input.xml\", false)) return;\n\n    VTDNav X1 = vg.getNav ();\n\n    AutoPilot ap = new AutoPilot (X1);\n\n    ap.selectXPath (\"/xml/item/@name\");\n\n    int i = 0;\n\n    while ((i = ap.evalXPath ()) != - 1) {\n\n        System.out.println (\" item name is ===>\" + X1.toString (i + 1));\n\n    }\n\n}\n"}
{"idx": 85301, "func": "public static int [] createArray (int size) {\n\n    int [] array = new int [size];\n\n    int half = (size / 2) + (size % 2);\n\n    int index = half;\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < size; i ++) {\n\n        if (i == index) {\n\n            half = (half / 2) + (half % 2);\n\n            index += half;\n\n            X1 ++;\n\n        }\n\n        array [i] = X1;\n\n    }\n\n    return array;\n\n}\n"}
{"idx": 85302, "func": "static int [] createArray (int size) {\n\n    int [] result = new int [size];\n\n    int X1 = (size + 1) / 2;\n\n    int start = 0, value = 0, idx = 0;\n\n    do {\n\n        for (int i = start;\n\n        i < start + X1 && idx < size; ++ i) result [idx ++] = value;\n\n        start += X1;\n\n        X1 = (X1 + 1) / 2;\n\n        ++ value;\n\n    } while (idx < size);\n\n    return result;\n\n}\n"}
{"idx": 85401, "func": "public static void main (String [] args) {\n\n    WSObject wsObject = new WSObject (new Foo (new Bar (new Baz (241))));\n\n    WSObject wsObjectNull = new WSObject (new Foo (null));\n\n    GetterResult < Integer > intResult = getterChain (wsObject, WSObject :: getFoo, Foo :: getBar, Bar :: getBar, Baz :: getInt);\n\n    GetterResult < Integer > intResult2 = getterChain (wsObjectNull, WSObject :: getFoo, Foo :: getBar, Bar :: getBar, Baz :: getInt);\n\n    System.X1.println (intResult.result);\n\n    System.X1.println (intResult.lastIndex);\n\n    System.X1.println ();\n\n    System.X1.println (intResult2.result);\n\n    System.X1.println (intResult2.lastIndex);\n\n}\n"}
{"idx": 85402, "func": "public static void main (String [] args) {\n\n    Address address = new Address ();\n\n    address.setSomeCrap (null);\n\n    Person person = new Person ();\n\n    person.setAddress (address);\n\n    long startTime = X1.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < 1000000; i ++) {\n\n        try {\n\n            X1.out.println (person.getAddress ().getSomeCrap ().getCrap ());\n\n        } catch (NullPointerException npe) {\n\n        }\n\n    }\n\n    long endTime = X1.currentTimeMillis ();\n\n    X1.out.println ((endTime - startTime) / 1000F);\n\n    long startTime1 = X1.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < 1000000; i ++) {\n\n        if (person != null) {\n\n            Address address1 = person.getAddress ();\n\n            if (address1 != null) {\n\n                SomeCrap someCrap2 = address1.getSomeCrap ();\n\n                if (someCrap2 != null) {\n\n                    X1.out.println (someCrap2.getCrap ());\n\n                }\n\n            }\n\n        }\n\n    }\n\n    long endTime1 = X1.currentTimeMillis ();\n\n    X1.out.println ((endTime1 - startTime1) / 1000F);\n\n}\n"}
{"idx": 85501, "func": "public static void main (String [] args) {\n\n    int X1 [] [] = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}};\n\n    int multiplier = 1;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        multiplier = multiplier * X1 [i] [i];\n\n    }\n\n    System.out.println (multiplier);\n\n}\n"}
{"idx": 85502, "func": "public static void main (String [] args) throws Exception {\n\n    int [] [] matrix = new int [3] [];\n\n    matrix [0] = new int [] {1, 2, 2};\n\n    matrix [1] = new int [] {2, 2, 3};\n\n    matrix [2] = new int [] {0, 1, 2};\n\n    int X1 = 1;\n\n    int resultR2L = 1;\n\n    for (int i = 0;\n\n    i < matrix.length; i ++) {\n\n        X1 *= matrix [i] [i];\n\n        resultR2L *= matrix [i] [matrix.length - 1 - i];\n\n    }\n\n    System.out.println (\"left-to-right: \" + X1);\n\n    System.out.println (\"right-to-left: \" + resultR2L);\n\n}\n"}
{"idx": 85601, "func": "public static void main (String [] args) throws Exception {\n\n    int [] [] matrix = new int [3] [];\n\n    matrix [0] = new int [] {1, 2, 2};\n\n    matrix [1] = new int [] {2, 2, 3};\n\n    matrix [2] = new int [] {0, 1, 2};\n\n    int resultL2R = 1;\n\n    int resultR2L = 1;\n\n    for (int i = 0;\n\n    i < matrix.length; i ++) {\n\n        resultL2R *= matrix [i] [i];\n\n        resultR2L *= matrix [i] [matrix.length - 1 - i];\n\n    }\n\n    System.out.X1 (\"left-to-right: \" + resultL2R);\n\n    System.out.X1 (\"right-to-left: \" + resultR2L);\n\n}\n"}
{"idx": 85602, "func": "public static void main (String [] args) {\n\n    int [] [] matrix = new int [] [] {{1, 2, 2}, {2, 2, 3}, {0, 1, 2}};\n\n    int result = 1;\n\n    for (int X1 = 0;\n\n    X1 < matrix.length; X1 ++) {\n\n        result = result * matrix [X1] [X1];\n\n    }\n\n    System.out.println (\"Result: \" + result);\n\n}\n"}
{"idx": 85701, "func": "public static int binarySearch (int [] a, int start, int end, int X1) {\n\n    int middle = (start + end) / 2;\n\n    if (end < start) {\n\n        return - 1;\n\n    }\n\n    if (X1 == a [middle]) {\n\n        return middle;\n\n    } else if (X1 < a [middle]) {\n\n        return binarySearch (a, start, middle - 1, X1);\n\n    } else {\n\n        return binarySearch (a, middle + 1, end, X1);\n\n    }\n\n}\n"}
{"idx": 85702, "func": "public static int binarySearch (int X1, int [] sortedArray) {\n\n    int lower = 0;\n\n    int upper = sortedArray.length - 1;\n\n    while (lower <= upper) {\n\n        int mid = lower + (upper - lower) / 2;\n\n        if (X1 < sortedArray [mid]) upper = mid - 1;\n\n        else if (X1 > sortedArray [mid]) lower = mid + 1;\n\n        else return mid;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 85801, "func": "private int binarySearch (int [] a, int X1, int low, int high) {\n\n    if (low > high) return - 1;\n\n    int mid = (low + high) / 2;\n\n    if (a [mid] == X1) return mid;\n\n    else if (a [mid] < X1) return binarySearch (a, X1, mid + 1, high);\n\n    else return binarySearch (a, X1, low, mid - 1);\n\n}\n"}
{"idx": 85802, "func": "public static int binarySearch (int intToSearch, int [] sortedArray) {\n\n    int lower = 0;\n\n    int upper = sortedArray.length - 1;\n\n    while (lower <= upper) {\n\n        int X1 = lower + (upper - lower) / 2;\n\n        if (intToSearch < sortedArray [X1]) upper = X1 - 1;\n\n        else if (intToSearch > sortedArray [X1]) lower = X1 + 1;\n\n        else return X1;\n\n    }\n\n    return - 1;\n\n}\n"}
{"idx": 85901, "func": "private static int score (char [] a, char [] b, int X1, int j) {\n\n    if (X1 == a.length || j == b.length) {\n\n        return 0;\n\n    } else if (a [X1] == b [j]) {\n\n        return 1 + score (a, b, X1 + 1, j + 1);\n\n    } else {\n\n        return max (score (a, b, X1 + 1, j), score (a, b, X1, j + 1));\n\n    }\n\n}\n"}
{"idx": 85902, "func": "public static int score (final X1 gene1, final X1 gene2) {\n\n    final char [] a;\n\n    final char [] b;\n\n    final int s;\n\n    a = gene1.toCharArray ();\n\n    b = gene2.toCharArray ();\n\n    s = score (a, b, 0, 0);\n\n    return (s);\n\n}\n"}
{"idx": 86001, "func": "public static int score (final String gene1, final String gene2) {\n\n    final char [] a;\n\n    final char [] b;\n\n    final int X1;\n\n    a = gene1.toCharArray ();\n\n    b = gene2.toCharArray ();\n\n    X1 = score (a, b, 0, 0);\n\n    return (X1);\n\n}\n"}
{"idx": 86002, "func": "private static int score (final char [] X1, final char [] b, final int idxA, final int idxB) {\n\n    final int value;\n\n    if (idxA >= X1.length || idxB >= b.length) {\n\n        value = 0;\n\n    } else if (X1 [idxA] == b [idxB]) {\n\n        value = 1 + score (X1, b, idxA + 1, idxB + 1);\n\n    } else {\n\n        final int x;\n\n        final int y;\n\n        x = score (X1, b, idxA + 1, idxB);\n\n        y = score (X1, b, idxB, idxB + 1);\n\n        value = max (x, y);\n\n    }\n\n    return (value);\n\n}\n"}
{"idx": 8601, "func": "public void start (Stage stage) {\n\n    final HTMLEditor htmlEditor = new HTMLEditor ();\n\n    stage.setScene (new Scene (htmlEditor));\n\n    stage.show ();\n\n    hideImageNodesMatching (htmlEditor, Pattern.compile (\".*(Cut|Copy|Paste).*\"), 0);\n\n    Node X1 = htmlEditor.lookup (\".separator\");\n\n    X1.setVisible (false);\n\n    X1.setManaged (false);\n\n}\n"}
{"idx": 8602, "func": "public void start (Stage primaryStage) {\n\n    final HTMLEditor htmlEditor = new HTMLEditor ();\n\n    primaryStage.setScene (new Scene (htmlEditor));\n\n    primaryStage.show ();\n\n    for (Node X1 = htmlEditor.lookup (\".tool-bar\");\n\n    X1 != null; X1 = htmlEditor.lookup (\".tool-bar\")) {\n\n        ((Pane) X1.getParent ()).getChildren ().remove (X1);\n\n    }\n\n}\n"}
{"idx": 86101, "func": "public static void main (String [] arguments) {\n\n    System.out.X1 (\"Type in any integer\");\n\n    Scanner inputChar = new Scanner (System.in);\n\n    int i;\n\n    if (! inputChar.hasNextInt ()) System.out.X1 (\"Not a number\");\n\n    else {\n\n        i = inputChar.nextInt ();\n\n        if (i != 0) {\n\n            if (i % 2 == 0) System.out.X1 (i + \" is even\");\n\n            else {\n\n                System.out.X1 (i + \" is odd\");\n\n            }\n\n        } else {\n\n            System.out.X1 (\"Zeros are not allowed, bye!\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 86102, "func": "public static void main (String [] arguments) {\n\n    Scanner inputChar = new Scanner (System.in);\n\n    int i;\n\n    while (true) {\n\n        System.out.X1 (\"Type in any integer:\");\n\n        if (! inputChar.hasNextInt ()) {\n\n            System.out.X1 (\"Not a number\");\n\n            inputChar.next ();\n\n        } else {\n\n            i = inputChar.nextInt ();\n\n            if (i != 0) {\n\n                if (i % 2 == 0) System.out.X1 (i + \" is even\");\n\n                else {\n\n                    System.out.X1 (i + \" is odd\");\n\n                }\n\n            } else {\n\n                System.out.X1 (\"Zeros are not allowed, bye!\");\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 86201, "func": "public String GetFodlerSize () {\n\n    String str = \"\";\n\n    int Finalsize = 0;\n\n    AWSCredentials credentials = new BasicAWSCredentials (accesskey, secretkey);\n\n    AmazonS3 conn = new AmazonS3Client (credentials);\n\n    ListObjectsRequest listObjectsRequest = new ListObjectsRequest ().withBucketName (BucketName).withPrefix (FolderName);\n\n    ObjectListing X1;\n\n    do {\n\n        X1 = conn.listObjects (listObjectsRequest);\n\n        for (S3ObjectSummary objectSummary : X1.getObjectSummaries ()) {\n\n            str = (objectSummary.getSize () + \"\");\n\n            int size = Integer.parseInt (str);\n\n            Finalsize = Finalsize + size;\n\n        }\n\n        listObjectsRequest.setMarker (X1.getNextMarker ());\n\n    } while (X1.isTruncated ());\n\n    return FolderSize;\n\n}\n"}
{"idx": 86202, "func": "public void GetFodlerSize (Context context) {\n\n    AmazonS3Client s3 = util.getS3Client (context);\n\n    int X1 = 0;\n\n    new AsyncTask < Void, Void, String > () {\n\n        String str = \"\";\n\n        int X1 = 0;\n\n        @Override\n\n        protected void onPreExecute () {\n\n            dialog = ProgressDialog.show (context, \"Loading\", \"wait\");\n\n        }@Override\n\n        protected String doInBackground (Void...inputs) {\n\n            ListObjectsRequest listObjectsRequest = new ListObjectsRequest ().withBucketName (Constants.BUCKET_NAME).withPrefix (NAME_OF_FOLDER_YOU_WANT_TO_GET_SIZE);\n\n            ObjectListing objects = s3.listObjects (listObjectsRequest);\n\n            for (S3ObjectSummary objectSummary : objects.getObjectSummaries ()) {\n\n                str = (objectSummary.getSize () + \"\");\n\n                int size = Integer.parseInt (str);\n\n                X1 = X1 + size;\n\n                objects = s3.listNextBatchOfObjects (objects);\n\n            }\n\n            String sizeString = null;\n\n            if (X1 > 1024) {\n\n                X1 = X1 / 1024;\n\n                sizeString = \" KB\";\n\n            }\n\n            if (X1 > 1024) {\n\n                X1 = X1 / 1024;\n\n                sizeString = \" MB\";\n\n            }\n\n            if (X1 > 1024) {\n\n                X1 = X1 / 1024;\n\n                sizeString = \" GB\";\n\n            }\n\n            return \"\" + X1 + sizeString;\n\n        }@Override\n\n        protected void onPostExecute (String result) {\n\n            dialog.dismiss ();\n\n        }}\n\n    .execute ();\n\n}\n"}
{"idx": 86301, "func": "public static void main (String...argv) throws Exception {\n\n    FileChannel fc = new FileInputStream (argv [0]).getChannel ();\n\n    ByteBuffer bb = fc.map (FileChannel.MapMode.READ_ONLY, 0, fc.size ());\n\n    CharBuffer cb = Charset.defaultCharset ().decode (bb);\n\n    Pattern p = Pattern.compile (\"[^ \\t\\r\\n\\f.,!?:;\\\"()']+\");\n\n    Map < String, Integer > counts = new TreeMap < String, Integer > ();\n\n    Matcher X1 = p.matcher (cb);\n\n    while (X1.find ()) {\n\n        String word = X1.group ();\n\n        Integer count = counts.get (word);\n\n        count = (count == null) ? 1 : count + 1;\n\n        counts.put (word, count);\n\n    }\n\n    fc.close ();\n\n    for (Map.Entry < String, Integer > e : counts.entrySet ()) {\n\n        System.out.printf (\"%s: %d%n\", e.getKey (), e.getValue ());\n\n    }\n\n}\n"}
{"idx": 86302, "func": "public static void main (String args []) {\n\n    Map < String, Integer > tm = new TreeMap < String, Integer > ();\n\n    try {\n\n        FileInputStream fis = new FileInputStream (\"Test.txt\");\n\n        DataInputStream in = new DataInputStream (fis);\n\n        BufferedReader br = new BufferedReader (new InputStreamReader (in));\n\n        String line;\n\n        int countValue = 1;\n\n        while ((line = br.readLine ()) != null) {\n\n            line = line.replaceAll (\"[-+.^:;,()\\\"\\\\[\\\\]]\", \"\");\n\n            StringTokenizer st = new StringTokenizer (line, \" \");\n\n            while (st.hasMoreTokens ()) {\n\n                String nextElement = (String) st.nextElement ();\n\n                if (tm.size () > 0 && tm.containsKey (nextElement)) {\n\n                    int val = 0;\n\n                    if (tm.get (nextElement) != null) {\n\n                        val = (Integer) tm.get (nextElement);\n\n                        val = val + 1;\n\n                    }\n\n                    tm.put (nextElement, val);\n\n                } else {\n\n                    tm.put (nextElement, 1);\n\n                }\n\n            }\n\n        }\n\n        for (Map.Entry < String, Integer > entry : tm.entrySet ()) {\n\n            System.out.println (entry.getKey () + \" : \" + entry.getValue ());\n\n        }\n\n    } catch (FileNotFoundException e) {\n\n        e.X1 ();\n\n    } catch (IOException e) {\n\n        e.X1 ();\n\n    }\n\n}\n"}
{"idx": 86401, "func": "@Override\n\npublic View getView (final int position, View convertView, ViewGroup parent) {\n\n    final ViewHolder X1;\n\n    if (convertView == null) {\n\n        X1 = new ViewHolder ();\n\n        convertView = inflater.inflate (R.layout.row1, null);\n\n        X1.checkbox = (CheckBox) convertView.findViewById (R.id.add_food_item);\n\n        convertView.setTag (X1);\n\n    } else {\n\n        X1 = (ViewHolder) convertView.getTag ();\n\n    }\n\n    final ItemInList element = list.get (position);\n\n    X1.checkbox.setChecked (element.isSelected ());\n\n    X1.checkbox.setOnCheckedChangeListener (new CompoundButton.OnCheckedChangeListener () {\n\n        @Override\n\n        public void onCheckedChanged (CompoundButton buttonView, boolean isChecked) {\n\n            element.setSelected (buttonView.isChecked ());\n\n            if (element.isSelected ()) {\n\n                array.add (element.getName ());\n\n            } else {\n\n                if (position < array.size ()) array.remove (position);\n\n            }\n\n        }}\n\n    );\n\n    return convertView;\n\n}\n"}
{"idx": 86402, "func": "public X1 getView (final int position, X1 convertview, ViewGroup parent) {\n\n    X1 v = convertview;\n\n    LayoutInflater vi = (LayoutInflater) getSystemService (Context.LAYOUT_INFLATER_SERVICE);\n\n    v = vi.inflate (R.layout.row_layout, null);\n\n    final x obj = items.get (position);\n\n    TextView txt_name = (TextView) v.findViewById (R.id.txt_name);\n\n    CheckBox checkBox1 = (CheckBox) findViewById (R.id.checkBox1);\n\n    if (checkBox1.isChecked ()) {\n\n        new_al.add (x_list.get (position));\n\n    }\n\n    btn_clear.setOnItemClickListener (new Listener () {\n\n        public void onClick (X1 v) {\n\n            x_list.clear ();\n\n            x_list.add (new_al);\n\n        }}\n\n    );\n\n    notifyDataSetChanged ();\n\n    return v;\n\n}\n"}
{"idx": 86501, "func": "public static int findArray (int [] array, int [] subArray) {\n\n    int count = 0;\n\n    for (int i = 0;\n\n    i < array.length; i ++) {\n\n        for (int X1 = 0;\n\n        X1 < subArray.length; X1 ++) {\n\n            if (array [i] == subArray [X1]) {\n\n                if (array.length > (i + 1) && subArray.length > (X1 + 1)) {\n\n                    if (array [i + 1] == subArray [X1 + 1]) {\n\n                        count += 1;\n\n                        continue;\n\n                    }\n\n                } else if (subArray.length == X1 + 1) {\n\n                    count += 1;\n\n                    continue;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    if (count < subArray.length) {\n\n        return - 1;\n\n    }\n\n    return count;\n\n}\n"}
{"idx": 86502, "func": "public static int findArray (int [] X1, int [] subArray) {\n\n    int index = - 1;\n\n    arrayLoop : for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if (X1 [i] == subArray [0]) {\n\n            for (int j = 1;\n\n            j < subArray.length; j ++) {\n\n                if (i + j > X1.length - 1 || X1 [i + j] != subArray [j]) continue arrayLoop;\n\n            }\n\n            index = i;\n\n        }\n\n    }\n\n    return index;\n\n}\n"}
{"idx": 86601, "func": "public X1 put (K key, X1 value) {\n\n    readWriteLock.writeLock ().lock ();\n\n    X1 old;\n\n    try {\n\n        old = super.put (key, value);\n\n    } finally {\n\n        readWriteLock.writeLock ().unlock ();\n\n    }\n\n    return old;\n\n}\n"}
{"idx": 86602, "func": "public void put (K key, V X1) {\n\n    while (currentSize >= maxSize) {\n\n        freeSpace ();\n\n    }\n\n    if (map.containsKey (key)) {\n\n        get (key);\n\n        return;\n\n    }\n\n    ListNode < K > ln = queue.add (key);\n\n    ValueHolder < K, V > rv = new ValueHolder < K, V > (X1, ln);\n\n    map.put (key, rv);\n\n    currentSize ++;\n\n}\n"}
{"idx": 86701, "func": "public V put (K key, V X1) {\n\n    readWriteLock.writeLock ().lock ();\n\n    V old;\n\n    try {\n\n        old = super.put (key, X1);\n\n    } finally {\n\n        readWriteLock.writeLock ().unlock ();\n\n    }\n\n    return old;\n\n}\n"}
{"idx": 86702, "func": "public void X1 (Key key, Value val) {\n\n    if (map.containsKey (key)) {\n\n        X1 (key, val);\n\n        return;\n\n    }\n\n    while (currentSize >= maxSize) {\n\n        freeSpace ();\n\n    }\n\n    synchronized (this) {\n\n        queue.add (key);\n\n        map.X1 (key, val);\n\n        currentSize ++;\n\n    }\n\n}\n"}
{"idx": 86801, "func": "public X1 remove (Object key) {\n\n    readWriteLock.writeLock ().lock ();\n\n    X1 value;\n\n    try {\n\n        value = super.remove (key);\n\n    } finally {\n\n        readWriteLock.writeLock ().unlock ();\n\n    }\n\n    return value;\n\n}\n"}
{"idx": 86802, "func": "public VV remove (String key) {\n\n    synchronized (lock) {\n\n        Item < VV > X1 = cache.remove (key);\n\n        if (X1 != null) {\n\n            return X1.payload;\n\n        } else {\n\n            return null;\n\n        }\n\n    }\n\n}\n"}
{"idx": 86901, "func": "public V remove (Object key) {\n\n    X1.writeLock ().lock ();\n\n    V value;\n\n    try {\n\n        value = super.remove (key);\n\n    } finally {\n\n        X1.writeLock ().unlock ();\n\n    }\n\n    return value;\n\n}\n"}
{"idx": 86902, "func": "public K remove () {\n\n    if (head == null) return null;\n\n    K X1 = head.value;\n\n    if (head.next == null) {\n\n        head = null;\n\n        tail = null;\n\n    } else {\n\n        head = head.next;\n\n        head.prev = null;\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 87001, "func": "public VV remove (String key) {\n\n    synchronized (lock) {\n\n        Item < VV > X1 = cache.remove (key);\n\n        if (X1 != null) {\n\n            return X1.payload;\n\n        } else {\n\n            return null;\n\n        }\n\n    }\n\n}\n"}
{"idx": 87002, "func": "public K remove () {\n\n    if (X1 == null) return null;\n\n    K val = X1.value;\n\n    if (X1.next == null) {\n\n        X1 = null;\n\n        tail = null;\n\n    } else {\n\n        X1 = X1.next;\n\n        X1.prev = null;\n\n    }\n\n    return val;\n\n}\n"}
{"idx": 8701, "func": "public void type (char X1) {\n\n    keyPress (VK_ALT);\n\n    keyPress (VK_NUMPAD0);\n\n    keyRelease (VK_NUMPAD0);\n\n    String altCode = Integer.toString (X1);\n\n    for (int i = 0;\n\n    i < altCode.length (); i ++) {\n\n        X1 = (char) (altCode.charAt (i) + '0');\n\n        keyPress (X1);\n\n        keyRelease (X1);\n\n    }\n\n    keyRelease (VK_ALT);\n\n}\n"}
{"idx": 8702, "func": "public static void type (String characters) {\n\n    Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n\n    StringSelection stringSelection = new StringSelection (characters);\n\n    clipboard.setContents (stringSelection, clipboardOwner);\n\n    robot.X1 (KeyEvent.VK_CONTROL);\n\n    robot.X1 (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_CONTROL);\n\n}\n"}
{"idx": 87101, "func": "public void put (K key, V val) {\n\n    while (currentSize >= maxSize) {\n\n        freeSpace ();\n\n    }\n\n    if (map.containsKey (key)) {\n\n        get (key);\n\n        return;\n\n    }\n\n    ListNode < K > X1 = queue.add (key);\n\n    ValueHolder < K, V > rv = new ValueHolder < K, V > (val, X1);\n\n    map.put (key, rv);\n\n    currentSize ++;\n\n}\n"}
{"idx": 87102, "func": "public void X1 (Key key, Value val) {\n\n    if (map.containsKey (key)) {\n\n        X1 (key, val);\n\n        return;\n\n    }\n\n    while (currentSize >= maxSize) {\n\n        freeSpace ();\n\n    }\n\n    synchronized (this) {\n\n        queue.add (key);\n\n        map.X1 (key, val);\n\n        currentSize ++;\n\n    }\n\n}\n"}
{"idx": 87201, "func": "public static void main (String [] args) {\n\n    String pass = \"admin\";\n\n    Scanner input = new Scanner (X1.in);\n\n    for (int i = 0;\n\n    i < 3; i ++) {\n\n        X1.out.print (\"Insert the admin pass: \");\n\n        String test = input.nextLine ();\n\n        if (pass.equals (test)) {\n\n            X1.out.print (\"Access granted\");\n\n            i = 3;\n\n        } else {\n\n            X1.out.println (\"Incorrect password, you have \" + (2 - i) + \" attempts remaining\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 87202, "func": "public static void main (String [] args) {\n\n    String pass = \"admin\";\n\n    int maxTry = 3;\n\n    boolean success = false;\n\n    Scanner input = new Scanner (X1.in);\n\n    X1.out.print (\"Insert the admin pass: \");\n\n    String test = input.nextLine ();\n\n    while (maxTry > 0) {\n\n        maxTry --;\n\n        if (! pass.equals (test)) {\n\n            X1.out.print (\"You have \" + maxTry + \" try(es): \");\n\n            test = input.nextLine ();\n\n        } else {\n\n            success = true;\n\n            break;\n\n        }\n\n    }\n\n    if (success) {\n\n        X1.out.println (\"Access granted\");\n\n    } else {\n\n        X1.out.println (\"Access denied\");\n\n    }\n\n}\n"}
{"idx": 87301, "func": "public static void main (String [] args) {\n\n    String pass = \"admin\";\n\n    Scanner input = new Scanner (System.in);\n\n    for (int i = 0;\n\n    i < 3; i ++) {\n\n        System.out.print (\"Insert the admin pass: \");\n\n        String X1 = input.nextLine ();\n\n        if (pass.equals (X1)) {\n\n            System.out.print (\"Access granted\");\n\n            i = 3;\n\n        } else {\n\n            System.out.println (\"Incorrect password, you have \" + (2 - i) + \" attempts remaining\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 87302, "func": "public static void main (String [] args) {\n\n    String pass = \"admin\";\n\n    Scanner X1 = new Scanner (System.in);\n\n    System.out.print (\"Insert the admin pass: \");\n\n    String test = X1.nextLine ();\n\n    if (pass.equals (test)) {\n\n        System.out.print (\"Access granted\");\n\n    } else {\n\n        for (int i = 1;\n\n        i < 3; i ++) {\n\n            System.out.print (\"You have \" + i + \" try(es): \");\n\n            test = X1.nextLine ();\n\n            if (pass.equals (test)) {\n\n                System.out.print (\"Access granted\");\n\n                break;\n\n            } else if (i == 2) {\n\n                System.out.print (\"Access denied\");\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 87401, "func": "public static void main (String [] args) {\n\n    String pass = \"admin\";\n\n    int maxTry = 3;\n\n    boolean success = false;\n\n    Scanner input = new Scanner (X1.in);\n\n    X1.out.print (\"Insert the admin pass: \");\n\n    String test = input.nextLine ();\n\n    while (maxTry > 0) {\n\n        maxTry --;\n\n        if (! pass.equals (test)) {\n\n            X1.out.print (\"You have \" + maxTry + \" try(es): \");\n\n            test = input.nextLine ();\n\n        } else {\n\n            success = true;\n\n            break;\n\n        }\n\n    }\n\n    if (success) {\n\n        X1.out.println (\"Access granted\");\n\n    } else {\n\n        X1.out.println (\"Access denied\");\n\n    }\n\n}\n"}
{"idx": 87402, "func": "public static void main (X1 [] args) {\n\n    X1 pass = \"admin\";\n\n    Scanner input = new Scanner (System.in);\n\n    System.out.print (\"Insert the admin pass: \");\n\n    X1 test = input.nextLine ();\n\n    if (pass.equals (test)) {\n\n        System.out.print (\"Access granted\");\n\n    } else {\n\n        for (int i = 1;\n\n        i < 3; i ++) {\n\n            System.out.print (\"You have \" + i + \" try(es): \");\n\n            test = input.nextLine ();\n\n            if (pass.equals (test)) {\n\n                System.out.print (\"Access granted\");\n\n                break;\n\n            } else if (i == 2) {\n\n                System.out.print (\"Access denied\");\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 87501, "func": "public void duplication () {\n\n    int max = 100;\n\n    int min = 1;\n\n    boolean duplicate = false;\n\n    Random rand = new Random ();\n\n    int [] X1 = new int [20];\n\n    for (int x = 0;\n\n    x < 20; x ++) {\n\n        duplicate = false;\n\n        int randomNum = rand.nextInt ((max - min) + 1) + min;\n\n        for (int i : X1) {\n\n            if (i == randomNum) {\n\n                duplicate = true;\n\n                break;\n\n            }\n\n        }\n\n        if (duplicate) {\n\n            x --;\n\n        } else {\n\n            X1 [x] = randomNum;\n\n        }\n\n    }\n\n}\n"}
{"idx": 87502, "func": "public static void duplication () {\n\n    int max = 100;\n\n    int min = 1;\n\n    X1 rand = new X1 ();\n\n    int index = 0;\n\n    int [] all = new int [20];\n\n    while (index < 20) {\n\n        boolean duplicate = false;\n\n        int randomNum = rand.nextInt ((max - min) + 1) + min;\n\n        for (int i = 0;\n\n        i < all.length; i ++) {\n\n            if (all [i] == randomNum) {\n\n                duplicate = true;\n\n                break;\n\n            }\n\n        }\n\n        if (! duplicate) {\n\n            all [index ++] = randomNum;\n\n        }\n\n    }\n\n}\n"}
{"idx": 87601, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String permissions [], int [] grantResults) {\n\n    Log.d (TAG, \"Permission callback called-------\");\n\n    switch (requestCode) {\n\n        case REQUEST_ID_MULTIPLE_PERMISSIONS :\n\n            {\n\n                Map < String, Integer > perms = new HashMap < > ();\n\n                perms.put (Manifest.permission.X1, PackageManager.PERMISSION_GRANTED);\n\n                perms.put (Manifest.permission.ACCESS_FINE_LOCATION, PackageManager.PERMISSION_GRANTED);\n\n                if (grantResults.length > 0) {\n\n                    for (int i = 0;\n\n                    i < permissions.length; i ++) perms.put (permissions [i], grantResults [i]);\n\n                    if (perms.get (Manifest.permission.X1) == PackageManager.PERMISSION_GRANTED && perms.get (Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n\n                        Log.d (TAG, \"sms & location services permission granted\");\n\n                    } else {\n\n                        Log.d (TAG, \"Some permissions are not granted ask again \");\n\n                        if (ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.permission.X1) || ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.permission.ACCESS_FINE_LOCATION)) {\n\n                            showDialogOK (\"SMS and Location Services Permission required for this app\", new DialogInterface.OnClickListener () {\n\n                                @Override\n\n                                public void onClick (DialogInterface dialog, int which) {\n\n                                    switch (which) {\n\n                                        case DialogInterface.BUTTON_POSITIVE :\n\n                                            checkAndRequestPermissions ();\n\n                                            break;\n\n                                        case DialogInterface.BUTTON_NEGATIVE :\n\n                                            break;\n\n                                    }\n\n                                }}\n\n                            );\n\n                        } else {\n\n                            Toast.makeText (this, \"Go to settings and enable permissions\", Toast.LENGTH_LONG).show ();\n\n                        }\n\n                    }\n\n                }\n\n            }}\n\n}\n"}
{"idx": 87602, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String permissions [], int [] X1) {\n\n    super.onRequestPermissionsResult (requestCode, permissions, X1);\n\n    if (X1.length == 0 || X1 == null) {\n\n    } else if (X1 [0] == PackageManager.PERMISSION_GRANTED) {\n\n    } else if (X1 [0] == PackageManager.PERMISSION_DENIED) {\n\n    }\n\n}\n"}
{"idx": 87701, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String permissions [], int [] grantResults) {\n\n    Log.d (TAG, \"Permission callback called-------\");\n\n    switch (requestCode) {\n\n        case REQUEST_ID_MULTIPLE_PERMISSIONS :\n\n            {\n\n                Map < String, Integer > perms = new HashMap < > ();\n\n                perms.put (Manifest.permission.SEND_SMS, PackageManager.PERMISSION_GRANTED);\n\n                perms.put (Manifest.permission.ACCESS_FINE_LOCATION, PackageManager.PERMISSION_GRANTED);\n\n                if (grantResults.length > 0) {\n\n                    for (int i = 0;\n\n                    i < permissions.length; i ++) perms.put (permissions [i], grantResults [i]);\n\n                    if (perms.get (Manifest.permission.SEND_SMS) == PackageManager.PERMISSION_GRANTED && perms.get (Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n\n                        Log.d (TAG, \"sms & location services permission granted\");\n\n                    } else {\n\n                        Log.d (TAG, \"Some permissions are not granted ask again \");\n\n                        if (ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.permission.SEND_SMS) || ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.permission.ACCESS_FINE_LOCATION)) {\n\n                            showDialogOK (\"SMS and Location Services Permission required for this app\", new DialogInterface.OnClickListener () {\n\n                                @Override\n\n                                public void onClick (DialogInterface dialog, int X1) {\n\n                                    switch (X1) {\n\n                                        case DialogInterface.BUTTON_POSITIVE :\n\n                                            checkAndRequestPermissions ();\n\n                                            break;\n\n                                        case DialogInterface.BUTTON_NEGATIVE :\n\n                                            break;\n\n                                    }\n\n                                }}\n\n                            );\n\n                        } else {\n\n                            Toast.makeText (this, \"Go to settings and enable permissions\", Toast.LENGTH_LONG).show ();\n\n                        }\n\n                    }\n\n                }\n\n            }}\n\n}\n"}
{"idx": 87702, "func": "public void onRequestPermissionsResult (int X1,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    if (X1 == mRequestCode) {\n\n        if (grantResults.length > 0) {\n\n            for (int grantResult : grantResults) {\n\n                if (grantResult != PackageManager.PERMISSION_GRANTED) {\n\n                    mRequestPermissionListener.onFailed ();\n\n                    return;\n\n                }\n\n            }\n\n            mRequestPermissionListener.onSuccess ();\n\n        } else {\n\n            mRequestPermissionListener.onFailed ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 87801, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String permissions [], int [] grantResults) {\n\n    Log.d (TAG, \"Permission callback called-------\");\n\n    switch (requestCode) {\n\n        case REQUEST_ID_MULTIPLE_PERMISSIONS :\n\n            {\n\n                Map < String, Integer > perms = new HashMap < > ();\n\n                perms.put (Manifest.X1.SEND_SMS, PackageManager.PERMISSION_GRANTED);\n\n                perms.put (Manifest.X1.ACCESS_FINE_LOCATION, PackageManager.PERMISSION_GRANTED);\n\n                if (grantResults.length > 0) {\n\n                    for (int i = 0;\n\n                    i < permissions.length; i ++) perms.put (permissions [i], grantResults [i]);\n\n                    if (perms.get (Manifest.X1.SEND_SMS) == PackageManager.PERMISSION_GRANTED && perms.get (Manifest.X1.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n\n                        Log.d (TAG, \"sms & location services permission granted\");\n\n                    } else {\n\n                        Log.d (TAG, \"Some permissions are not granted ask again \");\n\n                        if (ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.X1.SEND_SMS) || ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.X1.ACCESS_FINE_LOCATION)) {\n\n                            showDialogOK (\"SMS and Location Services Permission required for this app\", new DialogInterface.OnClickListener () {\n\n                                @Override\n\n                                public void onClick (DialogInterface dialog, int which) {\n\n                                    switch (which) {\n\n                                        case DialogInterface.BUTTON_POSITIVE :\n\n                                            checkAndRequestPermissions ();\n\n                                            break;\n\n                                        case DialogInterface.BUTTON_NEGATIVE :\n\n                                            break;\n\n                                    }\n\n                                }}\n\n                            );\n\n                        } else {\n\n                            Toast.makeText (this, \"Go to settings and enable permissions\", Toast.LENGTH_LONG).show ();\n\n                        }\n\n                    }\n\n                }\n\n            }}\n\n}\n"}
{"idx": 87802, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    super.onRequestPermissionsResult (requestCode, permissions, grantResults);\n\n    switch (requestCode) {\n\n        case PermissionsUtil.PERMISSION_ALL :\n\n            {\n\n                if (grantResults.length > 0) {\n\n                    List < Integer > indexesOfPermissionsNeededToShow = new ArrayList < > ();\n\n                    for (int i = 0;\n\n                    i < permissions.length; ++ i) {\n\n                        if (ActivityCompat.shouldShowRequestPermissionRationale (this, permissions [i])) {\n\n                            indexesOfPermissionsNeededToShow.add (i);\n\n                        }\n\n                    }\n\n                    int X1 = indexesOfPermissionsNeededToShow.X1 ();\n\n                    if (X1 != 0) {\n\n                        int i = 0;\n\n                        boolean isPermissionGranted = true;\n\n                        while (i < X1 && isPermissionGranted) {\n\n                            isPermissionGranted = grantResults [indexesOfPermissionsNeededToShow.get (i)] == PackageManager.PERMISSION_GRANTED;\n\n                            i ++;\n\n                        }\n\n                        if (! isPermissionGranted) {\n\n                            showDialogNotCancelable (\"Permissions mandatory\", \"All the permissions are required for this app\", new DialogInterface.OnClickListener () {\n\n                                @Override\n\n                                public void onClick (DialogInterface dialogInterface, int i) {\n\n                                    checkPermissions ();\n\n                                }}\n\n                            );\n\n                        }\n\n                    }\n\n                }\n\n            }}\n\n}\n"}
{"idx": 87901, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String permissions [], int [] grantResults) {\n\n    Log.d (TAG, \"Permission callback called-------\");\n\n    switch (requestCode) {\n\n        case REQUEST_ID_MULTIPLE_PERMISSIONS :\n\n            {\n\n                Map < String, Integer > perms = new HashMap < > ();\n\n                perms.put (Manifest.permission.SEND_SMS, PackageManager.X1);\n\n                perms.put (Manifest.permission.ACCESS_FINE_LOCATION, PackageManager.X1);\n\n                if (grantResults.length > 0) {\n\n                    for (int i = 0;\n\n                    i < permissions.length; i ++) perms.put (permissions [i], grantResults [i]);\n\n                    if (perms.get (Manifest.permission.SEND_SMS) == PackageManager.X1 && perms.get (Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.X1) {\n\n                        Log.d (TAG, \"sms & location services permission granted\");\n\n                    } else {\n\n                        Log.d (TAG, \"Some permissions are not granted ask again \");\n\n                        if (ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.permission.SEND_SMS) || ActivityCompat.shouldShowRequestPermissionRationale (this, Manifest.permission.ACCESS_FINE_LOCATION)) {\n\n                            showDialogOK (\"SMS and Location Services Permission required for this app\", new DialogInterface.OnClickListener () {\n\n                                @Override\n\n                                public void onClick (DialogInterface dialog, int which) {\n\n                                    switch (which) {\n\n                                        case DialogInterface.BUTTON_POSITIVE :\n\n                                            checkAndRequestPermissions ();\n\n                                            break;\n\n                                        case DialogInterface.BUTTON_NEGATIVE :\n\n                                            break;\n\n                                    }\n\n                                }}\n\n                            );\n\n                        } else {\n\n                            Toast.makeText (this, \"Go to settings and enable permissions\", Toast.LENGTH_LONG).show ();\n\n                        }\n\n                    }\n\n                }\n\n            }}\n\n}\n"}
{"idx": 87902, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String [] permissions, int [] grantResults) {\n\n    super.onRequestPermissionsResult (requestCode, permissions, grantResults);\n\n    switch (requestCode) {\n\n        case REQUEST_READ_PHONE_STATE :\n\n            {\n\n                if (grantResults.length > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.X1, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.X1, \"The app was not allowed to get your phone state. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            } case REQUEST_ACCESS_FINE_LOCATION :\n\n            {\n\n                if (grantResults.length > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.X1, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.X1, \"The app was not allowed to get your location. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            } case REQUEST_WRITE_STORAGE :\n\n            {\n\n                if (grantResults.length > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.X1, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.X1, \"The app was not allowed to write to your storage. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            }}\n\n}\n"}
{"idx": 88001, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String permissions [], int [] X1) {\n\n    super.onRequestPermissionsResult (requestCode, permissions, X1);\n\n    if (X1.length == 0 || X1 == null) {\n\n    } else if (X1 [0] == PackageManager.PERMISSION_GRANTED) {\n\n    } else if (X1 [0] == PackageManager.PERMISSION_DENIED) {\n\n    }\n\n}\n"}
{"idx": 88002, "func": "public void onRequestPermissionsResult (int requestCode,@X1\n\nString [] permissions,@X1\n\nint [] grantResults) {\n\n    if (requestCode == mRequestCode) {\n\n        if (grantResults.length > 0) {\n\n            for (int grantResult : grantResults) {\n\n                if (grantResult != PackageManager.PERMISSION_GRANTED) {\n\n                    mRequestPermissionListener.onFailed ();\n\n                    return;\n\n                }\n\n            }\n\n            mRequestPermissionListener.onSuccess ();\n\n        } else {\n\n            mRequestPermissionListener.onFailed ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 8801, "func": "public void type (char X1) {\n\n    keyPress (VK_ALT);\n\n    keyPress (VK_NUMPAD0);\n\n    keyRelease (VK_NUMPAD0);\n\n    String altCode = Integer.toString (X1);\n\n    for (int i = 0;\n\n    i < altCode.length (); i ++) {\n\n        X1 = (char) (altCode.charAt (i) + '0');\n\n        keyPress (X1);\n\n        keyRelease (X1);\n\n    }\n\n    keyRelease (VK_ALT);\n\n}\n"}
{"idx": 8802, "func": "public void type (CharSequence chars, int ms) {\n\n    ms = ms > 0 ? ms : 0;\n\n    for (int X1 = 0, len = chars.length ();\n\n    X1 < len; X1 ++) {\n\n        char c = chars.charAt (X1);\n\n        AWTKeyStroke keyStroke = getKeyStroke (c);\n\n        int keyCode = keyStroke.getKeyCode ();\n\n        boolean shift = Character.isUpperCase (c) || keyStroke.getModifiers () == (SHIFT_DOWN_MASK + 1);\n\n        if (shift) {\n\n            robot.keyPress (KeyEvent.VK_SHIFT);\n\n        }\n\n        robot.keyPress (keyCode);\n\n        robot.keyRelease (keyCode);\n\n        if (shift) {\n\n            robot.keyRelease (KeyEvent.VK_SHIFT);\n\n        }\n\n        if (ms > 0) {\n\n            robot.delay (ms);\n\n        }\n\n    }\n\n}\n"}
{"idx": 88101, "func": "public void onRequestPermissionsResult (int X1,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    if (X1 == mRequestCode) {\n\n        if (grantResults.length > 0) {\n\n            for (int grantResult : grantResults) {\n\n                if (grantResult != PackageManager.PERMISSION_GRANTED) {\n\n                    mRequestPermissionListener.onFailed ();\n\n                    return;\n\n                }\n\n            }\n\n            mRequestPermissionListener.onSuccess ();\n\n        } else {\n\n            mRequestPermissionListener.onFailed ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 88102, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    super.onRequestPermissionsResult (requestCode, permissions, grantResults);\n\n    switch (requestCode) {\n\n        case PermissionsUtil.PERMISSION_ALL :\n\n            {\n\n                if (grantResults.X1 > 0) {\n\n                    List < Integer > indexesOfPermissionsNeededToShow = new ArrayList < > ();\n\n                    for (int i = 0;\n\n                    i < permissions.X1; ++ i) {\n\n                        if (ActivityCompat.shouldShowRequestPermissionRationale (this, permissions [i])) {\n\n                            indexesOfPermissionsNeededToShow.add (i);\n\n                        }\n\n                    }\n\n                    int size = indexesOfPermissionsNeededToShow.size ();\n\n                    if (size != 0) {\n\n                        int i = 0;\n\n                        boolean isPermissionGranted = true;\n\n                        while (i < size && isPermissionGranted) {\n\n                            isPermissionGranted = grantResults [indexesOfPermissionsNeededToShow.get (i)] == PackageManager.PERMISSION_GRANTED;\n\n                            i ++;\n\n                        }\n\n                        if (! isPermissionGranted) {\n\n                            showDialogNotCancelable (\"Permissions mandatory\", \"All the permissions are required for this app\", new DialogInterface.OnClickListener () {\n\n                                @Override\n\n                                public void onClick (DialogInterface dialogInterface, int i) {\n\n                                    checkPermissions ();\n\n                                }}\n\n                            );\n\n                        }\n\n                    }\n\n                }\n\n            }}\n\n}\n"}
{"idx": 88201, "func": "public void onRequestPermissionsResult (int requestCode,@NonNull\n\nString [] permissions,@NonNull\n\nint [] X1) {\n\n    if (requestCode == mRequestCode) {\n\n        if (X1.length > 0) {\n\n            for (int grantResult : X1) {\n\n                if (grantResult != PackageManager.PERMISSION_GRANTED) {\n\n                    mRequestPermissionListener.onFailed ();\n\n                    return;\n\n                }\n\n            }\n\n            mRequestPermissionListener.onSuccess ();\n\n        } else {\n\n            mRequestPermissionListener.onFailed ();\n\n        }\n\n    }\n\n}\n"}
{"idx": 88202, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode, String [] permissions, int [] grantResults) {\n\n    super.onRequestPermissionsResult (requestCode, permissions, grantResults);\n\n    switch (requestCode) {\n\n        case REQUEST_READ_PHONE_STATE :\n\n            {\n\n                if (grantResults.X1 > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.this, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.this, \"The app was not allowed to get your phone state. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            } case REQUEST_ACCESS_FINE_LOCATION :\n\n            {\n\n                if (grantResults.X1 > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.this, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.this, \"The app was not allowed to get your location. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            } case REQUEST_WRITE_STORAGE :\n\n            {\n\n                if (grantResults.X1 > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.this, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.this, \"The app was not allowed to write to your storage. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            }}\n\n}\n"}
{"idx": 88301, "func": "@Override\n\npublic void onRequestPermissionsResult (int requestCode,@NonNull\n\nString [] permissions,@NonNull\n\nint [] grantResults) {\n\n    super.onRequestPermissionsResult (requestCode, permissions, grantResults);\n\n    switch (requestCode) {\n\n        case PermissionsUtil.PERMISSION_ALL :\n\n            {\n\n                if (grantResults.length > 0) {\n\n                    List < Integer > indexesOfPermissionsNeededToShow = new ArrayList < > ();\n\n                    for (int X1 = 0;\n\n                    X1 < permissions.length; ++ X1) {\n\n                        if (ActivityCompat.shouldShowRequestPermissionRationale (this, permissions [X1])) {\n\n                            indexesOfPermissionsNeededToShow.add (X1);\n\n                        }\n\n                    }\n\n                    int size = indexesOfPermissionsNeededToShow.size ();\n\n                    if (size != 0) {\n\n                        int X1 = 0;\n\n                        boolean isPermissionGranted = true;\n\n                        while (X1 < size && isPermissionGranted) {\n\n                            isPermissionGranted = grantResults [indexesOfPermissionsNeededToShow.get (X1)] == PackageManager.PERMISSION_GRANTED;\n\n                            X1 ++;\n\n                        }\n\n                        if (! isPermissionGranted) {\n\n                            showDialogNotCancelable (\"Permissions mandatory\", \"All the permissions are required for this app\", new DialogInterface.OnClickListener () {\n\n                                @Override\n\n                                public void onClick (DialogInterface dialogInterface, int X1) {\n\n                                    checkPermissions ();\n\n                                }}\n\n                            );\n\n                        }\n\n                    }\n\n                }\n\n            }}\n\n}\n"}
{"idx": 88302, "func": "@Override\n\npublic void X1 (int requestCode, String [] permissions, int [] grantResults) {\n\n    super.X1 (requestCode, permissions, grantResults);\n\n    switch (requestCode) {\n\n        case REQUEST_READ_PHONE_STATE :\n\n            {\n\n                if (grantResults.length > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.this, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.this, \"The app was not allowed to get your phone state. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            } case REQUEST_ACCESS_FINE_LOCATION :\n\n            {\n\n                if (grantResults.length > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.this, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.this, \"The app was not allowed to get your location. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            } case REQUEST_WRITE_STORAGE :\n\n            {\n\n                if (grantResults.length > 0 && grantResults [0] == PackageManager.PERMISSION_GRANTED) {\n\n                    Toast.makeText (LoginActivity.this, \"Permission granted.\", Toast.LENGTH_SHORT).show ();\n\n                    finish ();\n\n                    startActivity (getIntent ());\n\n                } else {\n\n                    Toast.makeText (LoginActivity.this, \"The app was not allowed to write to your storage. Hence, it cannot function properly. Please consider granting it this permission\", Toast.LENGTH_LONG).show ();\n\n                }\n\n            }}\n\n}\n"}
{"idx": 88401, "func": "static void test_02 () throws FileNotFoundException {\n\n    final File X1 = new File (\"43620487.txt\");\n\n    final Scanner scanner = new Scanner (X1);\n\n    int [] houseLocations = new int [73382];\n\n    for (int counter = 0;\n\n    counter < 73382; counter ++) {\n\n        houseLocations [counter] = scanner.nextInt ();\n\n    }\n\n    final int [] uniqueHouseLocationsSorted = uniqueHouseLocationsSorted (houseLocations);\n\n    final Random random = new Random (0);\n\n    long sum = 0;\n\n    for (int i = 0;\n\n    i < 100; i ++) {\n\n        final int transmitterRange = random.nextInt (70000) + 1;\n\n        final int minNumOfTransmitters = minNumOfTransmitters (uniqueHouseLocationsSorted, transmitterRange);\n\n        sum += minNumOfTransmitters;\n\n    }\n\n    final long start = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < 4000; i ++) {\n\n        final int transmitterRange = random.nextInt (70000) + 1;\n\n        final int minNumOfTransmitters = minNumOfTransmitters (uniqueHouseLocationsSorted, transmitterRange);\n\n        sum += minNumOfTransmitters;\n\n    }\n\n    final long end = System.currentTimeMillis ();\n\n    System.out.println (\"Took: \" + (end - start) + \" milliseconds. Sum = \" + sum);\n\n}\n"}
{"idx": 88402, "func": "static void test_02 () throws FileNotFoundException {\n\n    final File X1 = new File (\"input.txt\");\n\n    final Scanner scanner = new Scanner (X1);\n\n    int [] houseLocations = new int [73382];\n\n    for (int counter = 0;\n\n    counter < 73382; counter ++) {\n\n        houseLocations [counter] = scanner.nextInt ();\n\n    }\n\n    scanner.close ();\n\n    final int rounds = 400;\n\n    final int [] uniqueHouseLocationsSorted = uniqueHouseLocationsSorted (houseLocations);\n\n    final int transmitterRange = 73381;\n\n    final long start = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < rounds; i ++) {\n\n        final int minNumOfTransmitters = minNumOfTransmitters (uniqueHouseLocationsSorted, transmitterRange);\n\n    }\n\n    final long end = System.currentTimeMillis ();\n\n    System.out.println (\"Took: \" + (end - start) + \" milliseconds..\");\n\n}\n"}
{"idx": 88501, "func": "public void paintComponent (Graphics g) {\n\n    Graphics2D g2d = (Graphics2D) g;\n\n    RenderingHints rh = new RenderingHints (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    rh.put (RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n\n    g2d.setRenderingHints (rh);\n\n    double w = getWidth ();\n\n    double m = w / 12;\n\n    double dx = w / 7;\n\n    double dy = w / 8;\n\n    double x = m;\n\n    double y = .7 * m;\n\n    double r = w / 4;\n\n    int fwdStart = - 30;\n\n    int topStart = 90 - 30;\n\n    float rw = (float) w / 40;\n\n    BasicStroke bs = new BasicStroke (rw * 1.5f);\n\n    BasicStroke fs = new BasicStroke (rw);\n\n    X1 blue = new X1 (0, 133, 199);\n\n    X1 gold = new X1 (244, 195, 0);\n\n    X1 black = X1.black;\n\n    X1 green = new X1 (0, 159, 61);\n\n    X1 red = new X1 (223, 0, 36);\n\n    paintRing (g2d, fs, bs, x, y, r, rw, blue, 0, 360);\n\n    paintRing (g2d, fs, bs, x + dx, y + dy, r, rw, gold, 0, 360);\n\n    paintRing (g2d, fs, bs, x + 2 * dx, y, r, rw, black, 0, 360);\n\n    paintRing (g2d, fs, bs, x + dx, y + dy, r, rw, gold, topStart, 60);\n\n    paintRing (g2d, fs, bs, x, y, r, rw, blue, fwdStart, 60);\n\n    paintRing (g2d, fs, bs, x + 3 * dx, y + dy, r, rw, green, 0, 360);\n\n    paintRing (g2d, fs, bs, x + 4 * dx, y, r, rw, red, 0, 360);\n\n    paintRing (g2d, fs, bs, x + 3 * dx, y + dy, r, rw, green, topStart, 60);\n\n    paintRing (g2d, fs, bs, x + 2 * dx, y, r, rw, black, fwdStart, 60);\n\n}\n"}
{"idx": 88502, "func": "protected void paintComponent (Graphics g) {\n\n    super.paintComponent (g);\n\n    Graphics2D g2 = (Graphics2D) g.create ();\n\n    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    int x = X_START;\n\n    int y = Y_START;\n\n    myDrawOval (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, Color.BLUE, OVAL_WIDTH);\n\n    x += DELTA_X;\n\n    y += DELTA_Y;\n\n    myDrawOval (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, X1, OVAL_WIDTH);\n\n    x += DELTA_X;\n\n    y -= DELTA_Y;\n\n    myDrawOval (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, Color.BLACK, OVAL_WIDTH);\n\n    x += DELTA_X;\n\n    y += DELTA_Y;\n\n    myDrawOval (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, Color.GREEN.darker (), OVAL_WIDTH);\n\n    x += DELTA_X;\n\n    y -= DELTA_Y;\n\n    myDrawOval (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, Color.RED, OVAL_WIDTH);\n\n    x = X_START;\n\n    y = Y_START;\n\n    int angle = CIRCLE_DEGREES - ARC_LENGTH;\n\n    myDrawArc (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, Color.BLUE, OVAL_WIDTH, angle, ARC_LENGTH);\n\n    x += DELTA_X;\n\n    y += DELTA_Y;\n\n    myDrawArc (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, X1, OVAL_WIDTH, 0, ARC_LENGTH);\n\n    x += DELTA_X;\n\n    y -= DELTA_Y;\n\n    myDrawArc (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, Color.BLACK, OVAL_WIDTH, angle, ARC_LENGTH);\n\n    x += DELTA_X;\n\n    y += DELTA_Y;\n\n    myDrawArc (g2, INNER_STROKE, OUTER_STROKE, x, y, BG, Color.GREEN.darker (), OVAL_WIDTH, 0, ARC_LENGTH);\n\n    g2.dispose ();\n\n}\n"}
{"idx": 88601, "func": "public static void main (X1 [] args) {\n\n    X1 s = \"a a a A A\";\n\n    X1 [] splitedString = s.split (\" \");\n\n    Map m = new HashMap ();\n\n    int count = 1;\n\n    for (X1 s1 : splitedString) {\n\n        count = m.containsKey (s1) ? count + 1 : 1;\n\n        m.put (s1, count);\n\n    }\n\n    Iterator < StringToword > itr = m.entrySet ().iterator ();\n\n    while (itr.hasNext ()) {\n\n        System.out.println (itr.next ());\n\n    }\n\n}\n"}
{"idx": 88602, "func": "public static void main (String [] args) {\n\n    X1.out.println (\"Please enter the String\");\n\n    Scanner input = new Scanner (X1.in);\n\n    String userInput = input.nextLine ().trim ();\n\n    int numOfWords = getNumberOfWords (userInput);\n\n    char words [] [] = new char [numOfWords + 1] [];\n\n    words = getWordsFromString (userInput);\n\n    X1.out.println (\"Total number of words found in the String is \" + (numOfWords));\n\n    for (int i = 0;\n\n    i < numOfWords; i ++) {\n\n        X1.out.println (\" \");\n\n        for (int j = 0;\n\n        j < words [i].length; j ++) {\n\n            X1.out.print (words [i] [j]);\n\n        }\n\n    }\n\n}\n"}
{"idx": 88701, "func": "public static void main (String args []) {\n\n    String s1 = \"a b c\";\n\n    int X1 = s1.length ();\n\n    System.out.println (X1);\n\n    String s2 = s1.replace (\" \", \"\");\n\n    int s2_length = s2.length ();\n\n    System.out.println (s2_length);\n\n    System.out.println (\"No of spaces = \" + (X1 - s2_length));\n\n}\n"}
{"idx": 88702, "func": "public static void main (String [] args) {\n\n    String X1 = \"a b c\";\n\n    int i = 0, spaceCount = 0;\n\n    while (i < X1.length ()) {\n\n        if (X1.charAt (i) == ' ') {\n\n            spaceCount ++;\n\n        }\n\n        i ++;\n\n    }\n\n    System.out.println (\"Spaces in string: \" + spaceCount);\n\n}\n"}
{"idx": 88801, "func": "public static void main (String [] args) {\n\n    SendMyFiles sendMyFiles = new SendMyFiles ();\n\n    if (args.length < 1) {\n\n        System.err.println (\"Usage: java \" + sendMyFiles.getClass ().getName () + \" Properties_file File_To_FTP \");\n\n        System.exit (1);\n\n    }\n\n    String propertiesFile = args [0].X1 ();\n\n    String fileToFTP = args [1].X1 ();\n\n    sendMyFiles.startFTP (propertiesFile, fileToFTP);\n\n}\n"}
{"idx": 88802, "func": "public static void main (X1 [] args) throws IOException {\n\n    final SSHClient ssh = new SSHClient ();\n\n    ssh.loadKnownHosts ();\n\n    ssh.connect (\"localhost\");\n\n    try {\n\n        ssh.authPublickey (System.getProperty (\"user.name\"));\n\n        final X1 src = System.getProperty (\"user.home\") + File.separator + \"test_file\";\n\n        final SFTPClient sftp = ssh.newSFTPClient ();\n\n        try {\n\n            sftp.put (new FileSystemFile (src), \"/tmp\");\n\n        } finally {\n\n            sftp.close ();\n\n        }\n\n    } finally {\n\n        ssh.disconnect ();\n\n    }\n\n}\n"}
{"idx": 88901, "func": "public static void main (String [] args) {\n\n    SendMyFiles sendMyFiles = new SendMyFiles ();\n\n    if (args.length < 1) {\n\n        System.err.println (\"Usage: java \" + sendMyFiles.getClass ().getName () + \" Properties_file File_To_FTP \");\n\n        System.exit (1);\n\n    }\n\n    String X1 = args [0].trim ();\n\n    String fileToFTP = args [1].trim ();\n\n    sendMyFiles.startFTP (X1, fileToFTP);\n\n}\n"}
{"idx": 88902, "func": "public static void main (String args []) {\n\n    JSch jsch = new JSch ();\n\n    Session session = null;\n\n    try {\n\n        session = jsch.getSession (\"username\", \"127.0.0.1\", 22);\n\n        session.setConfig (\"StrictHostKeyChecking\", \"no\");\n\n        session.setPassword (\"password\");\n\n        session.connect ();\n\n        Channel channel = session.openChannel (\"sftp\");\n\n        channel.connect ();\n\n        ChannelSftp sftpChannel = (ChannelSftp) channel;\n\n        sftpChannel.get (\"remotefile.txt\", \"localfile.txt\");\n\n        sftpChannel.exit ();\n\n        session.disconnect ();\n\n    } catch (JSchException X1) {\n\n        X1.printStackTrace ();\n\n    } catch (SftpException X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 89001, "func": "public static void main (String [] args) throws IOException {\n\n    final SSHClient X1 = new SSHClient ();\n\n    X1.loadKnownHosts ();\n\n    X1.connect (\"localhost\");\n\n    try {\n\n        X1.authPublickey (System.getProperty (\"user.name\"));\n\n        final String src = System.getProperty (\"user.home\") + File.separator + \"test_file\";\n\n        final SFTPClient sftp = X1.newSFTPClient ();\n\n        try {\n\n            sftp.put (new FileSystemFile (src), \"/tmp\");\n\n        } finally {\n\n            sftp.close ();\n\n        }\n\n    } finally {\n\n        X1.disconnect ();\n\n    }\n\n}\n"}
{"idx": 89002, "func": "public static void main (String args []) {\n\n    JSch jsch = new JSch ();\n\n    Session X1 = null;\n\n    try {\n\n        X1 = jsch.getSession (\"username\", \"127.0.0.1\", 22);\n\n        X1.setConfig (\"StrictHostKeyChecking\", \"no\");\n\n        X1.setPassword (\"password\");\n\n        X1.connect ();\n\n        Channel channel = X1.openChannel (\"sftp\");\n\n        channel.connect ();\n\n        ChannelSftp sftpChannel = (ChannelSftp) channel;\n\n        sftpChannel.get (\"remotefile.txt\", \"localfile.txt\");\n\n        sftpChannel.exit ();\n\n        X1.disconnect ();\n\n    } catch (JSchException e) {\n\n        e.printStackTrace ();\n\n    } catch (SftpException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 8901, "func": "public void type (char c) {\n\n    keyPress (VK_ALT);\n\n    keyPress (VK_NUMPAD0);\n\n    keyRelease (VK_NUMPAD0);\n\n    String X1 = Integer.toString (c);\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        c = (char) (X1.charAt (i) + '0');\n\n        keyPress (c);\n\n        keyRelease (c);\n\n    }\n\n    keyRelease (VK_ALT);\n\n}\n"}
{"idx": 8902, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            doType (VK_A);\n\n            break;\n\n        case 'b' :\n\n            doType (VK_B);\n\n            break;\n\n        case 'c' :\n\n            doType (VK_C);\n\n            break;\n\n        case 'd' :\n\n            doType (VK_D);\n\n            break;\n\n        case 'e' :\n\n            doType (VK_E);\n\n            break;\n\n        case 'f' :\n\n            doType (VK_F);\n\n            break;\n\n        case 'g' :\n\n            doType (VK_G);\n\n            break;\n\n        case 'h' :\n\n            doType (VK_H);\n\n            break;\n\n        case 'i' :\n\n            doType (VK_I);\n\n            break;\n\n        case 'j' :\n\n            doType (VK_J);\n\n            break;\n\n        case 'k' :\n\n            doType (VK_K);\n\n            break;\n\n        case 'l' :\n\n            doType (VK_L);\n\n            break;\n\n        case 'm' :\n\n            doType (X1);\n\n            break;\n\n        case 'n' :\n\n            doType (VK_N);\n\n            break;\n\n        case 'o' :\n\n            doType (VK_O);\n\n            break;\n\n        case 'p' :\n\n            doType (VK_P);\n\n            break;\n\n        case 'q' :\n\n            doType (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            doType (VK_R);\n\n            break;\n\n        case 's' :\n\n            doType (VK_S);\n\n            break;\n\n        case 't' :\n\n            doType (VK_T);\n\n            break;\n\n        case 'u' :\n\n            doType (VK_U);\n\n            break;\n\n        case 'v' :\n\n            doType (VK_V);\n\n            break;\n\n        case 'w' :\n\n            doType (VK_W);\n\n            break;\n\n        case 'x' :\n\n            doType (VK_X);\n\n            break;\n\n        case 'y' :\n\n            doType (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            doType (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            doType (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            doType (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            doType (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            doType (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            doType (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            doType (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            doType (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            doType (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            doType (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            doType (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            doType (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            doType (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            doType (VK_SHIFT, X1);\n\n            break;\n\n        case 'N' :\n\n            doType (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            doType (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            doType (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            doType (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            doType (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            doType (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            doType (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            doType (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            doType (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            doType (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            doType (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            doType (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            doType (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            doType (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            doType (VK_0);\n\n            break;\n\n        case '1' :\n\n            doType (VK_1);\n\n            break;\n\n        case '2' :\n\n            doType (VK_2);\n\n            break;\n\n        case '3' :\n\n            doType (VK_3);\n\n            break;\n\n        case '4' :\n\n            doType (VK_4);\n\n            break;\n\n        case '5' :\n\n            doType (VK_5);\n\n            break;\n\n        case '6' :\n\n            doType (VK_6);\n\n            break;\n\n        case '7' :\n\n            doType (VK_7);\n\n            break;\n\n        case '8' :\n\n            doType (VK_8);\n\n            break;\n\n        case '9' :\n\n            doType (VK_9);\n\n            break;\n\n        case '-' :\n\n            doType (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            doType (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            doType (VK_SHIFT, VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            doType (VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            doType (VK_AT);\n\n            break;\n\n        case '#' :\n\n            doType (VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            doType (VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            doType (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            doType (VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            doType (VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            doType (VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            doType (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            doType (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            doType (VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            doType (VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            doType (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            doType (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            doType (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            doType (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            doType (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            doType (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            doType (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            doType (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            doType (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            doType (VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            doType (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            doType (VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            doType (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            doType (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            doType (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            doType (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            doType (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            doType (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            doType (VK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 89101, "func": "public static String translateToEnglish (String phrase) {\n\n    if (phrase == null) return null;\n\n    boolean threeAtBeginning = false, threeAtEnd = fal;\n\n    if (phrase.charAt (0) == '3' && phrase.charAt (1) == ' ') threeAtBeginning = true;\n\n    int length = phrase.length ();\n\n    if (phrase.charAt (length - 1) == '3' && phrase.charAt (length - 2) == ' ') threeAtEnd = true;\n\n    String finished = phrase.X1 ('4', 'a').X1 ('1', 'l').X1 ('2', 'z').X1 ('5', 's').X1 ('8', 'b').X1 ('0', 'o').X1 ('7', 't').X1 (\"|_|\", \"u\").X1 (\"3\", \"e\");\n\n    finished = finished.X1 (\" e \", \" 3 \");\n\n    if (threeAtBeginning) finished = '3' + finished.substring (1);\n\n    if (threeAtEnd) finished = finished.substring (0, length - 1) + '3';\n\n    return finished;\n\n}\n"}
{"idx": 89102, "func": "public static String translateToEnglish (String X1) {\n\n    if (X1 == null) {\n\n        return null;\n\n    }\n\n    String finished = X1.replace ('4', 'a').replace ('1', 'l').replace ('2', 'z').replace ('5', 's').replace ('8', 'b').replace ('0', 'o').replace ('7', 't').replace (\"|_|\", \"u\").replace (\"3\", \"e\");\n\n    finished = finished.replace (\" e \", \" 3 \");\n\n    if (finished.startsWith (\"e \")) {\n\n        finished = \"3 \" + finished.substring (2);\n\n    }\n\n    if (finished.endsWith (\" e\")) {\n\n        finished = finished.substring (0, finished.length () - 2) + \" 3\";\n\n    }\n\n    return finished;\n\n}\n"}
{"idx": 89201, "func": "@Override\n\npublic void start (Stage X1) throws Exception {\n\n    FXMLLoader loader = new FXMLLoader (getClass ().getResource (\"/sample/screen.fxml\"));\n\n    AnchorPane shadowPane = loader.load ();\n\n    AnchorPane rootPane = (AnchorPane) shadowPane.lookup (\"#rootPane\");\n\n    rootPane.setStyle (\"-fx-effect: dropshadow(gaussian, rgba(0, 0, 0, 0.4), 10, 0.5, 0.0, 0.0);\" + \"-fx-background-color: white;\");\n\n    Scene scene = new Scene (shadowPane);\n\n    X1.setScene (scene);\n\n    shadowPane.setBorder (new Border (new BorderStroke (Color.RED, BorderStrokeStyle.SOLID, null, null)));\n\n    shadowPane.setStyle (\"-fx-background-color: transparent;\");\n\n    scene.setFill (Color.TRANSPARENT);\n\n    X1.initStyle (StageStyle.TRANSPARENT);\n\n    X1.show ();\n\n}\n"}
{"idx": 89202, "func": "public void start (final Stage primaryStage) {\n\n    final WebView webView = new WebView ();\n\n    final ModalDialog dialog = createWebViewPreferenceDialog (primaryStage, webView);\n\n    webView.getEngine ().getLoadWorker ().stateProperty ().addListener (new ChangeListener < Worker.State > () {\n\n        @Override\n\n        public void changed (ObservableValue < ? extends Worker.State > observableValue, Worker.State state, Worker.State X1) {\n\n            if (X1.equals (Worker.State.SUCCEEDED)) {\n\n                dialog.show ();\n\n                dialog.toFront ();\n\n            }\n\n        }}\n\n    );\n\n    webView.getEngine ().load (\"http://docs.oracle.com/javafx/\");\n\n    primaryStage.setTitle (\"Modal Confirm Example\");\n\n    primaryStage.setScene (new Scene (webView));\n\n    primaryStage.show ();\n\n}\n"}
{"idx": 89301, "func": "public void start (Stage X1) {\n\n    try {\n\n        StackPane root = new StackPane ();\n\n        Text text2 = new Text (\"I will be aligned TOPLEFT\");\n\n        Text text = new Text (\" Level 2 \\n\\n\" + \"Press ENTER to start a new game\");\n\n        text.setTextAlignment (TextAlignment.CENTER);\n\n        root.getChildren ().addAll (text2, text);\n\n        StackPane.setAlignment (text2, Pos.TOP_LEFT);\n\n        StackPane.setAlignment (text, Pos.CENTER);\n\n        Scene scene = new Scene (root, 400, 400);\n\n        X1.setScene (scene);\n\n        X1.show ();\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 89302, "func": "public void start (Stage primaryStage) {\n\n    Text waitingForKey = new Text (\"Level 2 \\n\\n\" + \"Press ENTER to start a new game\");\n\n    waitingForKey.setTextAlignment (TextAlignment.CENTER);\n\n    waitingForKey.setFont (new Font (18));\n\n    waitingForKey.setFill (Color.ALICEBLUE);\n\n    StackPane root = new StackPane ();\n\n    root.getChildren ().add (waitingForKey);\n\n    Scene X1 = new Scene (root, 320, 240, Color.BLACK);\n\n    primaryStage.setTitle (\"Test\");\n\n    primaryStage.setScene (X1);\n\n    primaryStage.show ();\n\n}\n"}
{"idx": 89401, "func": "public static void main (String args []) {\n\n    FileReader fr = null;\n\n    FileWriter fw = null;\n\n    try {\n\n        fr = new FileReader (\"1.txt\");\n\n        fw = new FileWriter (\"2.txt\");\n\n        int c = fr.X1 ();\n\n        while (c != - 1) {\n\n            fw.write (c);\n\n            c = fr.X1 ();\n\n        }\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    } finally {\n\n        close (fr);\n\n        close (fw);\n\n    }\n\n}\n"}
{"idx": 89402, "func": "public static void main (String [] args) throws IOException {\n\n    X1 dir = new X1 (\".\");\n\n    String source = dir.getCanonicalPath () + X1.separator + \"Code.txt\";\n\n    String dest = dir.getCanonicalPath () + X1.separator + \"Dest.txt\";\n\n    X1 fin = new X1 (source);\n\n    FileInputStream fis = new FileInputStream (fin);\n\n    BufferedReader in = new BufferedReader (new InputStreamReader (fis));\n\n    FileWriter fstream = new FileWriter (dest, true);\n\n    BufferedWriter out = new BufferedWriter (fstream);\n\n    String aLine = null;\n\n    while ((aLine = in.readLine ()) != null) {\n\n        out.write (aLine);\n\n        out.newLine ();\n\n    }\n\n    in.close ();\n\n    out.close ();\n\n}\n"}
{"idx": 89501, "func": "public static void main (String [] args) {\n\n    CountDownLatch latch = new CountDownLatch (1);\n\n    System.X1.println (\"Start server\");\n\n    ServerModule serverModule = new ServerModule (latch);\n\n    serverModule.start ();\n\n    try {\n\n        latch.await ();\n\n    } catch (InterruptedException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    System.X1.println (\"Server is done\");\n\n}\n"}
{"idx": 89502, "func": "public static void main (String [] args) throws InterruptedException {\n\n    Thread t = new Thread (() -> {\n\n        try {\n\n            Thread.sleep (5000L);\n\n        } catch (InterruptedException e) {\n\n            e.printStackTrace ();\n\n        }\n\n    });\n\n    System.X1.println (\"Starting Server!\");\n\n    t.start ();\n\n    t.join ();\n\n    System.X1.println (\"Server is done!\");\n\n}\n"}
{"idx": 89601, "func": "public boolean onOptionsItemSelected (MenuItem X1) {\n\n    switch (X1.getItemId ()) {\n\n        case android.R.id.home :\n\n            NavUtils.navigateUpFromSameTask (this);\n\n            return true;\n\n        default :\n\n            return super.onOptionsItemSelected (X1);\n\n    }\n\n}\n"}
{"idx": 89602, "func": "@Override\n\npublic boolean X1 (MenuItem item) {\n\n    switch (item.getItemId ()) {\n\n        case android.R.id.home :\n\n            if (getParentActivityIntent () == null) {\n\n                Log.i (TAG, \"You have forgotten to specify the parentActivityName in the AndroidManifest!\");\n\n                onBackPressed ();\n\n            } else {\n\n                NavUtils.navigateUpFromSameTask (this);\n\n            }\n\n            return true;\n\n        default :\n\n            return super.X1 (item);\n\n    }\n\n}\n"}
{"idx": 89701, "func": "public static void main (String [] args) {\n\n    Scanner X1 = new Scanner (System.in);\n\n    int x = 0;\n\n    int [] list1Array = new int [1];\n\n    System.out.println (\"Enter list1: \");\n\n    while (X1.hasNext ()) {\n\n        list1Array [x] = X1.nextInt ();\n\n        x ++;\n\n        int [] temp = new int [list1Array.length + 1];\n\n        for (int i = 0;\n\n        i < list1Array.length; i ++) {\n\n            temp [i] = list1Array [i];\n\n        }\n\n        list1Array = temp;\n\n    }\n\n}\n"}
{"idx": 89702, "func": "public static void main (String [] args) {\n\n    Scanner input = new Scanner (System.in);\n\n    System.out.println (\"Enter elemnt size \");\n\n    int size = input.nextInt ();\n\n    int X1 = 0;\n\n    int [] list1Array = new int [size];\n\n    for (int y = 0;\n\n    y < size; y ++) {\n\n        System.out.println (\"Enter number\");\n\n        list1Array [X1] = input.nextInt ();\n\n        X1 ++;\n\n    }\n\n    System.out.println (Arrays.toString (list1Array));\n\n}\n"}
{"idx": 89801, "func": "public int sqrt (int x) {\n\n    if (x == 0 || x == 1) {\n\n        return x;\n\n    }\n\n    int start = 1, X1 = x / 2;\n\n    while (start <= X1) {\n\n        int mid = start + (X1 - start) / 2;\n\n        if (mid == x / mid) {\n\n            return mid;\n\n        }\n\n        if (mid < x / mid) {\n\n            start = mid + 1;\n\n        } else {\n\n            X1 = mid - 1;\n\n        }\n\n    }\n\n    return start - 1;\n\n}\n"}
{"idx": 89802, "func": "public static double sqrt (int n) {\n\n    double low = 0;\n\n    double high = n;\n\n    double X1 = (high - low) / 2;\n\n    while (Math.abs ((X1 * X1) - n) > 0.000000000001) {\n\n        if ((X1 * X1) > n) {\n\n            high = X1;\n\n            X1 = (high - low) / 2;\n\n        } else {\n\n            low = X1;\n\n            X1 = X1 + ((high - low) / 2);\n\n        }\n\n    }\n\n    return X1;\n\n}\n"}
{"idx": 89901, "func": "private int count8 (int X1) {\n\n    String nString = Integer.toString (X1);\n\n    boolean isPrevChar8 = false;\n\n    int total = 0;\n\n    for (int i = 0;\n\n    i < nString.length (); i ++) {\n\n        char nextChar = nString.charAt (i);\n\n        if (nextChar == '8') {\n\n            total += (isPrevChar8 ? 2 : 1);\n\n            isPrevChar8 = true;\n\n        } else {\n\n            isPrevChar8 = false;\n\n        }\n\n    }\n\n    return total;\n\n}\n"}
{"idx": 89902, "func": "public static int count8 (int X1) {\n\n    int count = 0;\n\n    boolean doubl = false;\n\n    while (true) {\n\n        int n = X1 % 10;\n\n        X1 = X1 / 10;\n\n        if (n == 8) {\n\n            if (doubl) {\n\n                count = count + 2;\n\n            } else {\n\n                count ++;\n\n            }\n\n            doubl = true;\n\n        } else {\n\n            doubl = false;\n\n        }\n\n        if (X1 == 0) break;\n\n    }\n\n    return count;\n\n}\n"}
{"idx": 90001, "func": "public static void main (String [] args) throws InterruptedException {\n\n    int X1 = 1000;\n\n    int tn = 10;\n\n    int from = 1;\n\n    int to;\n\n    int sum = 0;\n\n    Sum [] sumArray = new Sum [tn];\n\n    final CountDownLatch latch = new CountDownLatch (tn);\n\n    for (int i = 0;\n\n    i < tn; i ++) {\n\n        to = from + X1 / tn;\n\n        Sum s = new Sum (from, to, latch);\n\n        sumArray [i] = s;\n\n        s.start ();\n\n        from = to;\n\n    }\n\n    latch.await ();\n\n    for (int i = 0;\n\n    i < tn; i ++) {\n\n        sum += sumArray [i].getSum ();\n\n    }\n\n    System.out.println (sum);\n\n}\n"}
{"idx": 90002, "func": "public static void main (String...args) {\n\n    final CountDownLatch latch = new CountDownLatch (28);\n\n    for (int i = 0;\n\n    i < 28; i ++) {\n\n        X1 t = new X1 (new Runnable () {\n\n            public void run () {\n\n                try {\n\n                } finally {\n\n                    latch.countDown ();\n\n                }\n\n            }}\n\n        );\n\n        t.start ();\n\n    }\n\n    latch.await ();\n\n}\n"}
{"idx": 9001, "func": "public void type (char c) {\n\n    keyPress (VK_ALT);\n\n    keyPress (X1);\n\n    keyRelease (X1);\n\n    String altCode = Integer.toString (c);\n\n    for (int i = 0;\n\n    i < altCode.length (); i ++) {\n\n        c = (char) (altCode.charAt (i) + '0');\n\n        keyPress (c);\n\n        keyRelease (c);\n\n    }\n\n    keyRelease (VK_ALT);\n\n}\n"}
{"idx": 9002, "func": "private void type (char character) {\n\n    handleSpecialCharacter (character);\n\n    if (X1.isLowerCase (character)) {\n\n        typeCharacter (X1.toUpperCase (character));\n\n    }\n\n    if (X1.isUpperCase (character)) {\n\n        typeShiftCharacter (character);\n\n    }\n\n    if (X1.isDigit (character)) {\n\n        typeCharacter (character);\n\n    }\n\n}\n"}
{"idx": 901, "func": "public static boolean longerTF (boolean [] X1) {\n\n    int consecutiveVariableTrue = 0, maxConsecutiveVariableTrue = 0;\n\n    int consecutiveVariableFalse = 0, maxConsecutiveVariableFalse = 0;\n\n    for (int x = 0;\n\n    x < X1.length; x ++) {\n\n        if (X1 [x] == true) {\n\n            consecutiveVariableTrue ++;\n\n            if (maxConsecutiveVariableTrue < consecutiveVariableTrue) maxConsecutiveVariableTrue = consecutiveVariableTrue;\n\n        } else {\n\n            consecutiveVariableTrue = 0;\n\n        }\n\n    }\n\n    for (int x = 0;\n\n    x < X1.length; x ++) {\n\n        if (X1 [x] == false) {\n\n            consecutiveVariableFalse ++;\n\n            if (maxConsecutiveVariableFalse < consecutiveVariableFalse) maxConsecutiveVariableFalse = consecutiveVariableFalse;\n\n        } else {\n\n            consecutiveVariableFalse = 0;\n\n        }\n\n    }\n\n    if (maxConsecutiveVariableTrue >= maxConsecutiveVariableFalse) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n"}
{"idx": 90101, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 = new JFrame (\"test\");\n\n            X1.setSize (800, 600);\n\n            X1.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n            X1.setVisible (true);\n\n            A a = new A ();\n\n        }}\n\n    );\n\n}\n"}
{"idx": 90102, "func": "public static void main (String [] args) {\n\n    SwingUtilities.invokeLater (new Runnable () {\n\n        @Override\n\n        public void run () {\n\n            X1 = new JFrame (\"test\");\n\n            X1.setSize (800, 600);\n\n            X1.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);\n\n            X1.setVisible (true);\n\n            final A a = new A ();\n\n            X1.addWindowListener (new WindowAdapter () {\n\n                @Override\n\n                public void windowDeactivated (WindowEvent e) {\n\n                    a.setAlwaysOnTop (false);\n\n                }@Override\n\n                public void windowActivated (WindowEvent e) {\n\n                    a.setAlwaysOnTop (true);\n\n                }}\n\n            );\n\n        }}\n\n    );\n\n}\n"}
{"idx": 902, "func": "public static boolean longerTF (boolean [] X1) {\n\n    int variableTrue = 0;\n\n    int variableFalse = 0;\n\n    for (int x = 0;\n\n    x < X1.length; x ++) {\n\n        if (X1 [x]) {\n\n            variableTrue ++;\n\n        } else {\n\n            variableFalse ++;\n\n        }\n\n    }\n\n    return variableTrue >= variableFalse;\n\n}\n"}
{"idx": 90201, "func": "public void actionPerformed (ActionEvent actionEvent) {\n\n    doc.setCharacterAttributes (stringIndex, 1, textpane.getStyle (\"Red\"), true);\n\n    stringIndex ++;\n\n    try {\n\n        if (stringIndex >= doc.getLength () || doc.getText (stringIndex, 1).equals (\" \")) {\n\n            index ++;\n\n        }\n\n        if (index < times.size ()) {\n\n            double delay = times.get (index).doubleValue ();\n\n            X1.setDelay ((int) (delay / WORDS [index].length ()));\n\n        } else {\n\n            X1.stop ();\n\n            System.err.println (\"Timer stopped\");\n\n        }\n\n    } catch (BadLocationException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 90202, "func": "public void actionPerformed (ActionEvent ae) {\n\n    startButton.setEnabled (false);\n\n    count = 0;\n\n    final ArrayList < String > chars = new ArrayList < > ();\n\n    final ArrayList < Integer > charsTiming = new ArrayList < > ();\n\n    for (String s : individualWordsToHighlight) {\n\n        for (int i = 0;\n\n        i < s.length (); i ++) {\n\n            chars.X1 (String.valueOf (s.charAt (i)));\n\n            System.out.println (String.valueOf (s.charAt (i)));\n\n        }\n\n    }\n\n    for (int x = 0;\n\n    x < timingsArray.length; x ++) {\n\n        for (int i = 0;\n\n        i < individualWordsToHighlight [x].length (); i ++) {\n\n            charsTiming.X1 (timingsArray [x] / individualWordsToHighlight [x].length ());\n\n            System.out.println (timingsArray [x] / individualWordsToHighlight [x].length ());\n\n        }\n\n    }\n\n    new Timer (1, new AbstractAction () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent ae) {\n\n            if (count < charsTiming.size ()) {\n\n                highlightNextWord ();\n\n                ((Timer) ae.getSource ()).setInitialDelay (charsTiming.get (count));\n\n                ((Timer) ae.getSource ()).restart ();\n\n            } else {\n\n                reset ();\n\n                ((Timer) ae.getSource ()).stop ();\n\n            }\n\n            count ++;\n\n        }}\n\n    ).start ();\n\n}\n"}
{"idx": 90301, "func": "public void actionPerformed (ActionEvent actionEvent) {\n\n    doc.setCharacterAttributes (stringIndex, 1, textpane.getStyle (\"Red\"), true);\n\n    stringIndex ++;\n\n    try {\n\n        if (stringIndex >= doc.getLength () || doc.getText (stringIndex, 1).equals (\" \")) {\n\n            index ++;\n\n        }\n\n        if (index < times.size ()) {\n\n            double delay = times.get (index).doubleValue ();\n\n            X1.setDelay ((int) (delay / WORDS [index].length ()));\n\n        } else {\n\n            X1.stop ();\n\n            System.err.println (\"Timer stopped\");\n\n        }\n\n    } catch (BadLocationException e) {\n\n        e.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 90302, "func": "public void actionPerformed (ActionEvent ae) {\n\n    if (count < charsTiming.size ()) {\n\n        highlightNextWord ();\n\n        ((Timer) ae.X1 ()).setInitialDelay (charsTiming.get (count));\n\n        ((Timer) ae.X1 ()).restart ();\n\n    } else {\n\n        reset ();\n\n        ((Timer) ae.X1 ()).stop ();\n\n    }\n\n    count ++;\n\n}\n"}
{"idx": 90401, "func": "public void actionPerformed (ActionEvent ae) {\n\n    startButton.setEnabled (false);\n\n    count = 0;\n\n    final X1 < String > chars = new X1 < > ();\n\n    final X1 < Integer > charsTiming = new X1 < > ();\n\n    for (String s : individualWordsToHighlight) {\n\n        for (int i = 0;\n\n        i < s.length (); i ++) {\n\n            chars.add (String.valueOf (s.charAt (i)));\n\n            System.out.println (String.valueOf (s.charAt (i)));\n\n        }\n\n    }\n\n    for (int x = 0;\n\n    x < timingsArray.length; x ++) {\n\n        for (int i = 0;\n\n        i < individualWordsToHighlight [x].length (); i ++) {\n\n            charsTiming.add (timingsArray [x] / individualWordsToHighlight [x].length ());\n\n            System.out.println (timingsArray [x] / individualWordsToHighlight [x].length ());\n\n        }\n\n    }\n\n    new Timer (1, new AbstractAction () {\n\n        @Override\n\n        public void actionPerformed (ActionEvent ae) {\n\n            if (count < charsTiming.size ()) {\n\n                highlightNextWord ();\n\n                ((Timer) ae.getSource ()).setInitialDelay (charsTiming.get (count));\n\n                ((Timer) ae.getSource ()).restart ();\n\n            } else {\n\n                reset ();\n\n                ((Timer) ae.getSource ()).stop ();\n\n            }\n\n            count ++;\n\n        }}\n\n    ).start ();\n\n}\n"}
{"idx": 90402, "func": "public void actionPerformed (ActionEvent ae) {\n\n    if (count < charsTiming.size ()) {\n\n        highlightNextWord ();\n\n        ((X1) ae.getSource ()).setInitialDelay (charsTiming.get (count));\n\n        ((X1) ae.getSource ()).restart ();\n\n    } else {\n\n        reset ();\n\n        ((X1) ae.getSource ()).stop ();\n\n    }\n\n    count ++;\n\n}\n"}
{"idx": 90501, "func": "public static void main (String args []) {\n\n    ArrayList < String > keys = new ArrayList < > ();\n\n    ArrayList < String > values = new ArrayList < > ();\n\n    keys.X1 (\"1\");\n\n    keys.X1 (\"1\");\n\n    keys.X1 (\"1\");\n\n    keys.X1 (\"2\");\n\n    keys.X1 (\"2\");\n\n    keys.X1 (\"3\");\n\n    values.X1 (\"2016-06-22 07:18:45\");\n\n    values.X1 (\"2016-06-22 08:18:45\");\n\n    values.X1 (\"2016-06-22 09:18:45\");\n\n    values.X1 (\"2016-06-22 03:18:45\");\n\n    values.X1 (\"2016-06-22 04:18:45\");\n\n    values.X1 (\"2016-06-22 01:18:45\");\n\n    LinkedHashMap < String, String > map = new LinkedHashMap < String, String > ();\n\n    for (int i = 0;\n\n    i < keys.size (); i ++) {\n\n        map.put (keys.get (i), values.get (i));\n\n    }\n\n    System.out.println (map);\n\n}\n"}
{"idx": 90502, "func": "public static void main (String [] args) {\n\n    ArrayList < String > keys = new ArrayList < > (Arrays.asList (\"1\", \"1\", \"1\", \"2\", \"2\", \"3\"));\n\n    ArrayList < String > X1 = new ArrayList < > (Arrays.asList (\"2016-06-22 07:18:45\", \"2016-06-22 08:18:45\", \"2016-06-22 09:18:45\", \"2016-06-22 03:18:45\", \"2016-06-22 04:18:45\", \"2016-06-22 01:18:45\"));\n\n    HashMap < String, String > map = new HashMap < String, String > ();\n\n    for (int i = 0;\n\n    keys.size () == X1.size () && i < keys.size (); i ++) {\n\n        String key = keys.get (i);\n\n        String value = X1.get (i);\n\n        if (! map.containsKey (key) || dateAsNo (value) > dateAsNo (map.get (key))) {\n\n            map.put (key, value);\n\n        }\n\n    }\n\n    System.out.println (map);\n\n}\n"}
{"idx": 90601, "func": "private static void removeDuplicates (char [] X1) {\n\n    if (X1 == null || X1.length < 2) {\n\n        return;\n\n    }\n\n    int tail = 0;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        boolean found = false;\n\n        for (int j = 0;\n\n        j < i; j ++) {\n\n            if (X1 [j] == X1 [i]) {\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (found) {\n\n            continue;\n\n        }\n\n        X1 [tail] = X1 [i];\n\n        tail ++;\n\n    }\n\n    X1 [tail] = '\\0';\n\n}\n"}
{"idx": 90602, "func": "public static void removeDuplicates (char [] X1) {\n\n    int map = 0;\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        if ((map & (1 << (X1 [i] - 'a'))) > 0) X1 [i] = 0;\n\n        else map |= 1 << (X1 [i] - 'a');\n\n    }\n\n}\n"}
{"idx": 90701, "func": "private static void removeDuplicates (char [] str) {\n\n    if (str == null || str.length < 2) {\n\n        return;\n\n    }\n\n    int tail = 0;\n\n    for (int i = 0;\n\n    i < str.length; i ++) {\n\n        boolean found = false;\n\n        for (int X1 = 0;\n\n        X1 < i; X1 ++) {\n\n            if (str [X1] == str [i]) {\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (found) {\n\n            continue;\n\n        }\n\n        str [tail] = str [i];\n\n        tail ++;\n\n    }\n\n    str [tail] = '\\0';\n\n}\n"}
{"idx": 90702, "func": "static String removeDuplicates (String s) {\n\n    StringBuilder noDupes = new StringBuilder ();\n\n    for (int X1 = 0;\n\n    X1 < s.length (); X1 ++) {\n\n        String si = s.substring (X1, X1 + 1);\n\n        if (noDupes.indexOf (si) == - 1) {\n\n            noDupes.append (si);\n\n        }\n\n    }\n\n    return noDupes.toString ();\n\n}\n"}
{"idx": 90801, "func": "public static void removeDuplicates (char [] str) {\n\n    if (str == null) return;\n\n    int len = str.length;\n\n    if (len < 2) return;\n\n    int X1 = 1;\n\n    for (int i = 1;\n\n    i < len; ++ i) {\n\n        int j;\n\n        for (j = 0; j < X1; ++ j) {\n\n            if (str [i] == str [j]) break;\n\n        }\n\n        if (j == X1) {\n\n            str [X1] = str [i];\n\n            ++ X1;\n\n        }\n\n    }\n\n    str [X1] = 0;\n\n}\n"}
{"idx": 90802, "func": "public static void removeDuplicates (char [] str) {\n\n    int X1 = 0;\n\n    for (int i = 0;\n\n    i < str.length; i ++) {\n\n        if ((X1 & (1 << (str [i] - 'a'))) > 0) str [i] = 0;\n\n        else X1 |= 1 << (str [i] - 'a');\n\n    }\n\n}\n"}
{"idx": 90901, "func": "public static void removeDuplicates (char [] str) {\n\n    if (str == null) return;\n\n    int X1 = str.length;\n\n    if (X1 < 2) return;\n\n    int tail = 1;\n\n    for (int i = 1;\n\n    i < X1; ++ i) {\n\n        int j;\n\n        for (j = 0; j < tail; ++ j) {\n\n            if (str [i] == str [j]) break;\n\n        }\n\n        if (j == tail) {\n\n            str [tail] = str [i];\n\n            ++ tail;\n\n        }\n\n    }\n\n    str [tail] = 0;\n\n}\n"}
{"idx": 90902, "func": "static String removeDuplicates (String s) {\n\n    StringBuilder noDupes = new StringBuilder ();\n\n    for (int i = 0;\n\n    i < s.length (); i ++) {\n\n        String X1 = s.substring (i, i + 1);\n\n        if (noDupes.indexOf (X1) == - 1) {\n\n            noDupes.append (X1);\n\n        }\n\n    }\n\n    return noDupes.toString ();\n\n}\n"}
{"idx": 91001, "func": "public static void main (String [] args) {\n\n    char [] X1 = \"127\".toCharArray ();\n\n    char [] num2 = \"32\".toCharArray ();\n\n    int [] intermediate = new int [X1.length];\n\n    for (int i = 0;\n\n    i < X1.length; i ++) {\n\n        for (int j = 0;\n\n        j < num2.length; j ++) {\n\n            int d1 = X1 [X1.length - i - 1] - '0';\n\n            int d2 = num2 [num2.length - j - 1] - '0';\n\n            intermediate [i] += d1 * d2 * (int) Math.pow (10, j);\n\n            System.out.printf (\"  %d X %d = %d\\n\", d1, d2, intermediate [i]);\n\n        }\n\n        intermediate [i] *= (int) Math.pow (10, i);\n\n        System.out.println (\" intermediate : \" + intermediate [i]);\n\n    }\n\n    int sum = 0;\n\n    for (int i : intermediate) {\n\n        sum += i;\n\n    }\n\n    System.out.println (\"Sum is = \" + sum);\n\n}\n"}
{"idx": 91002, "func": "public static void main (String [] args) {\n\n    String number1 = \"108\";\n\n    String number2 = \"84\";\n\n    char [] n1 = number1.toCharArray ();\n\n    char [] n2 = number2.toCharArray ();\n\n    int result = 0;\n\n    for (int i = 0;\n\n    i < n1.X1; i ++) {\n\n        for (int j = 0;\n\n        j < n2.X1; j ++) {\n\n            result += (n1 [i] - '0') * (n2 [j] - '0') * (int) Math.pow (10, n1.X1 + n2.X1 - (i + j + 2));\n\n        }\n\n    }\n\n    System.out.println (result);\n\n}\n"}
{"idx": 9101, "func": "public void type (char c) {\n\n    keyPress (VK_ALT);\n\n    keyPress (VK_NUMPAD0);\n\n    keyRelease (VK_NUMPAD0);\n\n    String X1 = Integer.toString (c);\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        c = (char) (X1.charAt (i) + '0');\n\n        keyPress (c);\n\n        keyRelease (c);\n\n    }\n\n    keyRelease (VK_ALT);\n\n}\n"}
{"idx": 9102, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            X1 (VK_A);\n\n            break;\n\n        case 'b' :\n\n            X1 (VK_B);\n\n            break;\n\n        case 'c' :\n\n            X1 (VK_C);\n\n            break;\n\n        case 'd' :\n\n            X1 (VK_D);\n\n            break;\n\n        case 'e' :\n\n            X1 (VK_E);\n\n            break;\n\n        case 'f' :\n\n            X1 (VK_F);\n\n            break;\n\n        case 'g' :\n\n            X1 (VK_G);\n\n            break;\n\n        case 'h' :\n\n            X1 (VK_H);\n\n            break;\n\n        case 'i' :\n\n            X1 (VK_I);\n\n            break;\n\n        case 'j' :\n\n            X1 (VK_J);\n\n            break;\n\n        case 'k' :\n\n            X1 (VK_K);\n\n            break;\n\n        case 'l' :\n\n            X1 (VK_L);\n\n            break;\n\n        case 'm' :\n\n            X1 (VK_M);\n\n            break;\n\n        case 'n' :\n\n            X1 (VK_N);\n\n            break;\n\n        case 'o' :\n\n            X1 (VK_O);\n\n            break;\n\n        case 'p' :\n\n            X1 (VK_P);\n\n            break;\n\n        case 'q' :\n\n            X1 (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            X1 (VK_R);\n\n            break;\n\n        case 's' :\n\n            X1 (VK_S);\n\n            break;\n\n        case 't' :\n\n            X1 (VK_T);\n\n            break;\n\n        case 'u' :\n\n            X1 (VK_U);\n\n            break;\n\n        case 'v' :\n\n            X1 (VK_V);\n\n            break;\n\n        case 'w' :\n\n            X1 (VK_W);\n\n            break;\n\n        case 'x' :\n\n            X1 (VK_X);\n\n            break;\n\n        case 'y' :\n\n            X1 (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            X1 (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            X1 (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            X1 (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            X1 (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            X1 (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            X1 (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            X1 (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            X1 (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            X1 (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            X1 (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            X1 (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            X1 (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            X1 (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            X1 (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            X1 (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            X1 (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            X1 (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            X1 (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            X1 (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            X1 (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            X1 (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            X1 (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            X1 (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            X1 (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            X1 (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            X1 (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            X1 (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            X1 (VK_0);\n\n            break;\n\n        case '1' :\n\n            X1 (VK_1);\n\n            break;\n\n        case '2' :\n\n            X1 (VK_2);\n\n            break;\n\n        case '3' :\n\n            X1 (VK_3);\n\n            break;\n\n        case '4' :\n\n            X1 (VK_4);\n\n            break;\n\n        case '5' :\n\n            X1 (VK_5);\n\n            break;\n\n        case '6' :\n\n            X1 (VK_6);\n\n            break;\n\n        case '7' :\n\n            X1 (VK_7);\n\n            break;\n\n        case '8' :\n\n            X1 (VK_8);\n\n            break;\n\n        case '9' :\n\n            X1 (VK_9);\n\n            break;\n\n        case '-' :\n\n            X1 (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            X1 (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            X1 (VK_SHIFT, VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            X1 (VK_SHIFT, VK_AT);\n\n            break;\n\n        case '#' :\n\n            X1 (VK_SHIFT, VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            X1 (VK_SHIFT, VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            X1 (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            X1 (VK_SHIFT, VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            X1 (VK_SHIFT, VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            X1 (VK_SHIFT, VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            X1 (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            X1 (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            X1 (VK_SHIFT, VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            X1 (VK_SHIFT, VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            X1 (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            X1 (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            X1 (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            X1 (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            X1 (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            X1 (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            X1 (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            X1 (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            X1 (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            X1 (VK_SHIFT, VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            X1 (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            X1 (VK_SHIFT, VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            X1 (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            X1 (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            X1 (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            X1 (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            X1 (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            X1 (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            X1 (VK_SPACE);\n\n            break;\n\n        case '\\b' :\n\n            X1 (VK_BACK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 91101, "func": "public static final String deriveCurveName (org.bouncycastle.jce.spec.ECParameterSpec ecParameterSpec) throws GeneralSecurityException {\n\n    for (@SuppressWarnings (\"rawtypes\")\n\n    Enumeration names = ECNamedCurveTable.getNames ();\n\n    names.hasMoreElements ();) {\n\n        final String name = (String) names.nextElement ();\n\n        final X9ECParameters params = ECNamedCurveTable.getByName (name);\n\n        if (params.getN ().X1 (ecParameterSpec.getN ()) && params.getH ().X1 (ecParameterSpec.getH ()) && params.getCurve ().X1 (ecParameterSpec.getCurve ()) && params.getG ().X1 (ecParameterSpec.getG ())) {\n\n            return name;\n\n        }\n\n    }\n\n    throw new GeneralSecurityException (\"Could not find name for curve\");\n\n}\n"}
{"idx": 91102, "func": "public static final String deriveCurveName (PublicKey publicKey) throws GeneralSecurityException {\n\n    if (publicKey instanceof java.security.interfaces.X1) {\n\n        final java.security.interfaces.X1 pk = (java.security.interfaces.X1) publicKey;\n\n        final ECParameterSpec params = pk.getParams ();\n\n        return deriveCurveName (EC5Util.convertSpec (params, false));\n\n    } else if (publicKey instanceof org.bouncycastle.jce.interfaces.X1) {\n\n        final org.bouncycastle.jce.interfaces.X1 pk = (org.bouncycastle.jce.interfaces.X1) publicKey;\n\n        return deriveCurveName (pk.getParameters ());\n\n    } else throw new IllegalArgumentException (\"Can only be used with instances of ECPublicKey (either jce or bc implementation)\");\n\n}\n"}
{"idx": 91201, "func": "public static final String deriveCurveName (org.bouncycastle.jce.spec.ECParameterSpec X1) throws GeneralSecurityException {\n\n    for (@SuppressWarnings (\"rawtypes\")\n\n    Enumeration names = ECNamedCurveTable.getNames ();\n\n    names.hasMoreElements ();) {\n\n        final String name = (String) names.nextElement ();\n\n        final X9ECParameters params = ECNamedCurveTable.getByName (name);\n\n        if (params.getN ().equals (X1.getN ()) && params.getH ().equals (X1.getH ()) && params.getCurve ().equals (X1.getCurve ()) && params.getG ().equals (X1.getG ())) {\n\n            return name;\n\n        }\n\n    }\n\n    throw new GeneralSecurityException (\"Could not find name for curve\");\n\n}\n"}
{"idx": 91202, "func": "public static final String deriveCurveName (PrivateKey privateKey) throws GeneralSecurityException {\n\n    if (privateKey instanceof java.security.interfaces.ECPrivateKey) {\n\n        final java.security.interfaces.ECPrivateKey X1 = (java.security.interfaces.ECPrivateKey) privateKey;\n\n        final ECParameterSpec params = X1.getParams ();\n\n        return deriveCurveName (EC5Util.convertSpec (params, false));\n\n    } else if (privateKey instanceof org.bouncycastle.jce.interfaces.ECPrivateKey) {\n\n        final org.bouncycastle.jce.interfaces.ECPrivateKey X1 = (org.bouncycastle.jce.interfaces.ECPrivateKey) privateKey;\n\n        return deriveCurveName (X1.getParameters ());\n\n    } else throw new IllegalArgumentException (\"Can only be used with instances of ECPrivateKey (either jce or bc implementation)\");\n\n}\n"}
{"idx": 91301, "func": "public static String toHexString (byte [] X1) {\n\n    char [] hexArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n    char [] hexChars = new char [10000000];\n\n    int c = 0;\n\n    int v;\n\n    for (j = 0; j < X1.length; j ++) {\n\n        v = X1 [j] & 0xFF;\n\n        hexChars [c] = hexArray [v / 16];\n\n        c ++;\n\n        hexChars [c] = hexArray [v % 16];\n\n        c ++;\n\n    }\n\n    return new String (hexChars, 0, c);\n\n}\n"}
{"idx": 91302, "func": "public static String toHexString (byte bytes []) {\n\n    if (bytes == null) {\n\n        return null;\n\n    }\n\n    StringBuffer X1 = new StringBuffer ();\n\n    for (int iter = 0;\n\n    iter < bytes.length; iter ++) {\n\n        byte high = (byte) ((bytes [iter] & 0xf0)>> 4);\n\n        byte low = (byte) (bytes [iter] & 0x0f);\n\n        X1.append (nibble2char (high));\n\n        X1.append (nibble2char (low));\n\n    }\n\n    return X1.toString ();\n\n}\n"}
{"idx": 91401, "func": "public static String toHexString (byte [] bytes) {\n\n    char [] hexArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n    char [] hexChars = new char [10000000];\n\n    int c = 0;\n\n    int X1;\n\n    for (j = 0; j < bytes.length; j ++) {\n\n        X1 = bytes [j] & 0xFF;\n\n        hexChars [c] = hexArray [X1 / 16];\n\n        c ++;\n\n        hexChars [c] = hexArray [X1 % 16];\n\n        c ++;\n\n    }\n\n    return new String (hexChars, 0, c);\n\n}\n"}
{"idx": 91402, "func": "public static String X1 (byte [] bytes) {\n\n    StringBuilder hexString = new StringBuilder ();\n\n    for (int i = 0;\n\n    i < bytes.length; i ++) {\n\n        String hex = Integer.X1 (0xFF & bytes [i]);\n\n        if (hex.length () == 1) {\n\n            hexString.append ('0');\n\n        }\n\n        hexString.append (hex);\n\n    }\n\n    return hexString.toString ();\n\n}\n"}
{"idx": 91501, "func": "public static String toHexString (byte [] bytes) {\n\n    char [] X1 = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n    char [] hexChars = new char [bytes.length * 2];\n\n    int v;\n\n    for (int j = 0;\n\n    j < bytes.length; j ++) {\n\n        v = bytes [j] & 0xFF;\n\n        hexChars [j * 2] = X1 [v / 16];\n\n        hexChars [j * 2 + 1] = X1 [v % 16];\n\n    }\n\n    return new String (hexChars);\n\n}\n"}
{"idx": 91502, "func": "public static String toHexString (byte X1 []) {\n\n    if (X1 == null) {\n\n        return null;\n\n    }\n\n    StringBuffer sb = new StringBuffer ();\n\n    for (int iter = 0;\n\n    iter < X1.length; iter ++) {\n\n        byte high = (byte) ((X1 [iter] & 0xf0)>> 4);\n\n        byte low = (byte) (X1 [iter] & 0x0f);\n\n        sb.append (nibble2char (high));\n\n        sb.append (nibble2char (low));\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 91601, "func": "public static String toHexString (byte [] bytes) {\n\n    char [] hexArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n    char [] X1 = new char [bytes.length * 2];\n\n    int v;\n\n    for (int j = 0;\n\n    j < bytes.length; j ++) {\n\n        v = bytes [j] & 0xFF;\n\n        X1 [j * 2] = hexArray [v / 16];\n\n        X1 [j * 2 + 1] = hexArray [v % 16];\n\n    }\n\n    return new String (X1);\n\n}\n"}
{"idx": 91602, "func": "public static String toHexString (byte [] bytes) {\n\n    StringBuilder hexString = new StringBuilder ();\n\n    for (int X1 = 0;\n\n    X1 < bytes.length; X1 ++) {\n\n        String hex = Integer.toHexString (0xFF & bytes [X1]);\n\n        if (hex.length () == 1) {\n\n            hexString.append ('0');\n\n        }\n\n        hexString.append (hex);\n\n    }\n\n    return hexString.toString ();\n\n}\n"}
{"idx": 91701, "func": "public static String toHexString (byte X1 []) {\n\n    if (X1 == null) {\n\n        return null;\n\n    }\n\n    StringBuffer sb = new StringBuffer ();\n\n    for (int iter = 0;\n\n    iter < X1.length; iter ++) {\n\n        byte high = (byte) ((X1 [iter] & 0xf0)>> 4);\n\n        byte low = (byte) (X1 [iter] & 0x0f);\n\n        sb.append (nibble2char (high));\n\n        sb.append (nibble2char (low));\n\n    }\n\n    return sb.toString ();\n\n}\n"}
{"idx": 91702, "func": "public static String toHexString (byte [] bytes) {\n\n    X1 hexString = new X1 ();\n\n    for (int i = 0;\n\n    i < bytes.length; i ++) {\n\n        String hex = Integer.toHexString (0xFF & bytes [i]);\n\n        if (hex.length () == 1) {\n\n            hexString.append ('0');\n\n        }\n\n        hexString.append (hex);\n\n    }\n\n    return hexString.toString ();\n\n}\n"}
{"idx": 91801, "func": "@Override\n\npublic void onBindViewHolder (MyViewHolder X1, final int position) {\n\n    AnimalObject animalObject = list.get (position);\n\n    X1.title.setText (animalObject.name);\n\n    X1.itemView.setOnClickListener (new View.OnClickListener () {\n\n        @Override\n\n        public void onClick (View v) {\n\n            AnimalObject animalObject = list.get (position);\n\n            int currentCheckedStatus = animalObject.ischecked ();\n\n            for (int i = 0;\n\n            i < list.size (); i ++) {\n\n                if (i == position) {\n\n                    animalObject.setIschecked (! currentCheckedStatus);\n\n                } else {\n\n                    animalObject.setIschecked (false);\n\n                }\n\n            }\n\n            notifyDataSetChanged ();\n\n        }}\n\n    );\n\n    X1.checkBox.setChecked (animalObject.ischecked ());\n\n}\n"}
{"idx": 91802, "func": "@Override\n\npublic void onBindViewHolder (final Main_Page_Payment_Cash_Adapter.ViewHolder holder, final int position) {\n\n    holder.itemView.setOnClickListener (new View.OnClickListener () {\n\n        @Override\n\n        public void onClick (View v) {\n\n            X1 = position;\n\n            notifyDataSetChanged ();\n\n        }}\n\n    );\n\n    if (X1 == position) {\n\n    } else {\n\n    }\n\n}\n"}
{"idx": 91901, "func": "public String getNextMonth (boolean maxDate) {\n\n    Calendar X1 = Calendar.getInstance ();\n\n    if (maxDate) {\n\n        X1.set (year, monthNo, 1);\n\n    } else {\n\n        X1.set (year, monthNo, day);\n\n    }\n\n    if (monthNo == 11) {\n\n        X1.add (X1.MONTH, 1);\n\n    } else {\n\n        X1.add (X1.MONTH, 1);\n\n    }\n\n    int maxD = X1.getActualMaximum (X1.DAY_OF_MONTH);\n\n    X1.set (year, monthNo, maxD);\n\n}\n"}
{"idx": 91902, "func": "public String getNextMonth (boolean maxDate) {\n\n    Calendar calendar = Calendar.getInstance ();\n\n    calendar.set (year, monthNo, 1);\n\n    calendar.add (Calendar.MONTH, 1);\n\n    if (maxDate) {\n\n        int X1 = calendar.getActualMaximum (Calendar.DAY_OF_MONTH);\n\n        calendar.set (Calendar.DAY_OF_MONTH, X1);\n\n    } else {\n\n        calendar.set (Calendar.DAY_OF_MONTH, day);\n\n    }\n\n    String date = (calendar.get (Calendar.YEAR)) + \"-\" + (calendar.get (Calendar.MONTH) + 1) + \"-\" + calendar.get (Calendar.DAY_OF_MONTH);\n\n    calendar.clear ();\n\n    return date;\n\n}\n"}
{"idx": 92001, "func": "public Serializable generate (SessionImplementor session, Object object) throws HibernateException {\n\n    X1 prefix = \"DEP\";\n\n    Connection connection = session.connection ();\n\n    try {\n\n        Statement statement = connection.createStatement ();\n\n        ResultSet rs = statement.executeQuery (\"select count(Department_Id) as Id from demo.Department\");\n\n        if (rs.next ()) {\n\n            int id = rs.getInt (1) + 101;\n\n            X1 generatedId = prefix + new Integer (id).toString ();\n\n            System.out.println (\"Generated Id: \" + generatedId);\n\n            return generatedId;\n\n        }\n\n    } catch (SQLException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 92002, "func": "public Serializable generate (SessionImplementor session, Object object) throws HibernateException {\n\n    Serializable result = null;\n\n    Connection connection = null;\n\n    Statement statement = null;\n\n    ResultSet resultSet = null;\n\n    String prefix = \"emp\";\n\n    try {\n\n        connection = session.connection ();\n\n        statement = connection.createStatement ();\n\n        try {\n\n            resultSet = statement.X1 (\"SELECT next_val FROM  \" + DEFAULT_SEQUENCE_NAME);\n\n        } catch (Exception e) {\n\n            System.out.println (\"In catch, cause : Table is not available.\");\n\n            statement.execute (\"CREATE table \" + DEFAULT_SEQUENCE_NAME + \" (next_val INT NOT NULL)\");\n\n            statement.executeUpdate (\"INSERT INTO \" + DEFAULT_SEQUENCE_NAME + \" VALUES(0)\");\n\n            statement.executeUpdate (\"UPDATE \" + DEFAULT_SEQUENCE_NAME + \" SET next_val=LAST_INSERT_ID(next_val+1)\");\n\n            resultSet = statement.X1 (\"SELECT next_val FROM  \" + DEFAULT_SEQUENCE_NAME);\n\n        }\n\n        if (resultSet.next ()) {\n\n            int nextValue = resultSet.getInt (1);\n\n            String suffix = String.format (\"%04d\", nextValue);\n\n            result = prefix.concat (suffix);\n\n            System.out.println (\"Custom generated sequence is : \" + result);\n\n        }\n\n    } catch (SQLException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 9201, "func": "public void type (char c) {\n\n    keyPress (VK_ALT);\n\n    keyPress (VK_NUMPAD0);\n\n    keyRelease (VK_NUMPAD0);\n\n    String X1 = Integer.toString (c);\n\n    for (int i = 0;\n\n    i < X1.length (); i ++) {\n\n        c = (char) (X1.charAt (i) + '0');\n\n        keyPress (c);\n\n        keyRelease (c);\n\n    }\n\n    keyRelease (VK_ALT);\n\n}\n"}
{"idx": 9202, "func": "public void type (String text) {\n\n    char c;\n\n    for (int X1 = 0;\n\n    X1 < text.length (); X1 ++) {\n\n        c = text.charAt (X1);\n\n        if (c <= 31 || c == 129) {\n\n            pressControlKey (c);\n\n        } else {\n\n            typeAsciiCode (c);\n\n        }\n\n    }\n\n}\n"}
{"idx": 92101, "func": "public static void main (String [] args) {\n\n    final A a = new A ();\n\n    final B b = new B ();\n\n    NameFuncPair [] fArray = new NameFuncPair [] {new NameFuncPair (\"A\") {\n\n        @X1\n\n        void f (String x) {\n\n            a.g (x);\n\n        }}\n\n    , new NameFuncPair (\"B\") {\n\n        @X1\n\n        void f (String x) {\n\n            b.h (x);\n\n        }}\n\n    ,};\n\n    for (NameFuncPair fInstance : fArray) {\n\n        if (fInstance.name.equals (\"B\")) {\n\n            fInstance.f (fInstance.name + \"(some args)\");\n\n        }\n\n    }\n\n}\n"}
{"idx": 92102, "func": "public static void main (final String [] argv) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n\n    final String X1;\n\n    final Method method;\n\n    final Main main;\n\n    main = new Main ();\n\n    if (argv.length == 0) {\n\n        X1 = \"foo\";\n\n    } else {\n\n        X1 = \"bar\";\n\n    }\n\n    method = Main.class.getDeclaredMethod (X1, int.class);\n\n    main.car (method, 42);\n\n}\n"}
{"idx": 92201, "func": "int solution (int X1 [], int N) {\n\n    int i, leftSum, rightSum, last_minimum, current_min;\n\n    leftSum = X1 [0];\n\n    rightSum = 0;\n\n    i = 1;\n\n    while (i < N) {\n\n        rightSum += X1 [i];\n\n        i ++;\n\n    }\n\n    last_minimum = abs (leftSum - rightSum);\n\n    if (last_minimum == 0) return last_minimum;\n\n    i = 2;\n\n    while (i < N) {\n\n        leftSum += X1 [i - 1];\n\n        rightSum -= X1 [i - 1];\n\n        current_min = abs (leftSum - rightSum);\n\n        if (current_min == 0) return current_min;\n\n        if (last_minimum > current_min) last_minimum = current_min;\n\n        i ++;\n\n    }\n\n    return last_minimum;\n\n}\n"}
{"idx": 92202, "func": "public int solution (int [] A) {\n\n    if (A.length == 2) return Math.abs (A [0] - A [1]);\n\n    int [] s1 = new int [A.length - 1];\n\n    s1 [0] = A [0];\n\n    for (int X1 = 1;\n\n    X1 < A.length - 1; X1 ++) {\n\n        s1 [X1] = s1 [X1 - 1] + A [X1];\n\n    }\n\n    int [] s2 = new int [A.length - 1];\n\n    s2 [A.length - 2] = A [A.length - 1];\n\n    for (int X1 = A.length - 3;\n\n    X1 >= 0; X1 --) {\n\n        s2 [X1] = s2 [X1 + 1] + A [X1 + 1];\n\n    }\n\n    int finalSum = Integer.MAX_VALUE;\n\n    for (int j = 0;\n\n    j < s1.length; j ++) {\n\n        int sum = Math.abs (s1 [j] - s2 [j]);\n\n        if (sum < finalSum) finalSum = sum;\n\n    }\n\n    return finalSum;\n\n}\n"}
{"idx": 92301, "func": "private void initData () {\n\n    testData = new ArrayList < X1 > ();\n\n    testData.add (new X1 (\"Mach-1\", 1476950160000L, 1));\n\n    testData.add (new X1 (\"Mach-1\", 1476952200000L, 2));\n\n    testData.add (new X1 (\"Mach-1\", 1476964800000L, 4));\n\n    testData.add (new X1 (\"Mach-1\", 1476966600000L, 3));\n\n    testData.add (new X1 (\"Mach-2\", 1476943200000L, 1));\n\n    testData.add (new X1 (\"Mach-2\", 1476946800000L, 4));\n\n    testData.add (new X1 (\"Mach-2\", 1476954000000L, 2));\n\n    testData.add (new X1 (\"Mach-2\", 1476955800000L, 1));\n\n    testData.add (new X1 (\"Mach-2\", 1476973800000L, 3));\n\n    testData.add (new X1 (\"Mach-3\", 1476959400000L, 2));\n\n    testData.add (new X1 (\"Mach-3\", 1476966600000L, 1));\n\n    testData.add (new X1 (\"Mach-3\", 1476970200000L, 4));\n\n    testData.add (new X1 (\"Mach-3\", 1476972000000L, 1));\n\n    testData.add (new X1 (\"Mach-3\", 1476986400000L, 2));\n\n}\n"}
{"idx": 92302, "func": "private void initData () {\n\n    testData = new ArrayList < EventStatus > ();\n\n    testData.add (new EventStatus (\"Mach-1\", 1477468500000L, 1, 0));\n\n    testData.add (new EventStatus (\"Mach-1\", 1477472100000L, 2, 0));\n\n    testData.add (new EventStatus (\"Mach-1\", 1477474200000L, 5, 0));\n\n    testData.add (new EventStatus (\"Mach-1\", 1477476000000L, 3, 0));\n\n    testData.add (new EventStatus (\"Mach-1\", 1477479600000L, 4, 0));\n\n    testData.add (new EventStatus (\"Mach-1\", 1477486800000L, 1, 0));\n\n    testData.add (new EventStatus (\"Mach-2\", 1477465200000L, 3, 1));\n\n    testData.add (new EventStatus (\"Mach-2\", 1477472400000L, 2, 1));\n\n    testData.add (new EventStatus (\"Mach-2\", 1477474200000L, 5, 1));\n\n    testData.add (new EventStatus (\"Mach-2\", 1477476000000L, 2, 1));\n\n    testData.add (new EventStatus (\"Mach-2\", 1477479600000L, 3, 1));\n\n    testData.add (new EventStatus (\"Mach-2\", 1477486800000L, 4, 1));\n\n    ArrayList < String > list = new ArrayList < > ();\n\n    for (EventStatus eventStatus : testData) {\n\n        if (list.contains (eventStatus.X1 ())) continue;\n\n        else list.add (eventStatus.X1 ());\n\n    }\n\n    catArray = new String [list.size ()];\n\n    catArray = list.toArray (catArray);\n\n}\n"}
{"idx": 92401, "func": "public static void main (String [] args) {\n\n    ScottishPerson scottishPerson = new ScottishPerson ();\n\n    BritishPerson britishPerson = new BritishPerson ();\n\n    BritishPerson britishPersonUpcasted = new ScottishPerson (\"Another scottish name\");\n\n    scottishPerson.salute ();\n\n    scottishPerson.warcry ();\n\n    X1.out.println (scottishPerson.name);\n\n    X1.out.println (scottishPerson.clanName);\n\n    britishPerson.salute ();\n\n    X1.out.println (britishPerson.name);\n\n    britishPersonUpcasted.salute ();\n\n    X1.out.println (britishPersonUpcasted.name);\n\n}\n"}
{"idx": 92402, "func": "public static void main (String [] args) {\n\n    Dog dog = new Dog ();\n\n    Horse horse = new Horse ();\n\n    Animal animal = dog;\n\n    Animal horseAnimal = new Horse ();\n\n    Dog X1 = upcastToDog (animal);\n\n    dog.saySomething ();\n\n    dog.getTheBall ();\n\n    X1.saySomething ();\n\n    X1.getTheBall ();\n\n    horse.saySomething ();\n\n    horse.getTheBall ();\n\n    try {\n\n        Dog upcastedDog = upcastToDog (horseAnimal);\n\n    } catch (Exception ex) {\n\n        System.out.println (ex.getClass ().getSimpleName () + \": Obviously a horse is not a dog!\");\n\n    }\n\n}\n"}
{"idx": 92501, "func": "public static boolean isPrime (int num) {\n\n    for (int X1 = 2;\n\n    X1 <= num / X1; X1 ++) {\n\n        if (num % X1 == 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return num > 1;\n\n}\n"}
{"idx": 92502, "func": "public static boolean isPrime (int X1) {\n\n    if ((X1 & 1) == 0) {\n\n        return X1 == 2;\n\n    }\n\n    if (X1 < 9) {\n\n        return X1 > 1;\n\n    }\n\n    return isStrongProbablePrime (X1, 2) && isStrongProbablePrime (X1, 7) && isStrongProbablePrime (X1, 61);\n\n}\n"}
{"idx": 92601, "func": "public static void main (String args []) {\n\n    Scanner sc = new Scanner (System.in);\n\n    ArrayList < Integer > X1 = new ArrayList < Integer > ();\n\n    System.out.println (\"enter the item in list\");\n\n    while (sc.hasNextInt ()) {\n\n        X1.add (sc.nextInt ());\n\n    }\n\n    Iterator it1 = X1.iterator ();\n\n    while (it1.hasNext ()) {\n\n        System.out.println (it1.next ());\n\n    }\n\n}\n"}
{"idx": 92602, "func": "public static void main (String [] args) {\n\n    Scanner scan = new Scanner (X1.in);\n\n    ArrayList < Integer > list = new ArrayList < Integer > ();\n\n    X1.out.print (\"Enter integers please \");\n\n    X1.out.println (\"(EOF or non-integer to terminate): \");\n\n    while (scan.hasNextInt ()) {\n\n        list.add (scan.nextInt ());\n\n    }\n\n    Integer [] nums = list.toArray (new Integer [0]);\n\n    for (int i = 0;\n\n    i < nums.length; i ++) {\n\n        X1.out.println (nums [i]);\n\n    }\n\n}\n"}
{"idx": 92701, "func": "public void invoke (Request request, Response response) throws IOException, ServletException {\n\n    getNext ().invoke (request, response);\n\n    Session session = null;\n\n    try {\n\n        session = request.getSessionInternal ();\n\n    } catch (Throwable e) {\n\n        log.error (X1 () + \": Unable to perform replication request.\", e);\n\n    }\n\n    String context = request.getContext ().getName ();\n\n    String task = request.getPathInfo ();\n\n    if (task == null) {\n\n        task = request.getRequestURI ();\n\n    }\n\n    if (session != null) {\n\n        if (log.isDebugEnabled ()) {\n\n            log.debug (X1 () + \": [session=\" + session.getId () + \", instanceof=\" + session.getClass ().getName () + \", context=\" + context + \", request=\" + task + \"]\");\n\n        }\n\n        List < String > cycledNames = new LinkedList < String > ();\n\n        HttpSession deltaSession = (HttpSession) session;\n\n        for (Enumeration < String > names = deltaSession.getAttributeNames ();\n\n        names.hasMoreElements ();) {\n\n            String name = names.nextElement ();\n\n            deltaSession.setAttribute (name, deltaSession.getAttribute (name));\n\n            cycledNames.add (name);\n\n        }\n\n        if (log.isDebugEnabled ()) {\n\n            log.debug (X1 () + \": [session=\" + session.getId () + \", context=\" + context + \", request=\" + task + \"] cycled atrributes=\" + cycledNames + \"\");\n\n        }\n\n    } else {\n\n        String id = request.getRequestedSessionId ();\n\n        log.warn (X1 () + \": [session=\" + id + \", context=\" + context + \", request=\" + task + \"] Session not available, unable to send session over cluster.\");\n\n    }\n\n}\n"}
{"idx": 92702, "func": "public void X1 (Request request, Response response) throws IOException, ServletException {\n\n    getNext ().X1 (request, response);\n\n    Session session = null;\n\n    try {\n\n        session = request.getSessionInternal ();\n\n    } catch (Throwable e) {\n\n        log.error (getInfo () + \": Unable to perform replication request.\", e);\n\n    }\n\n    String context = request.getContext ().getName ();\n\n    String task = request.getPathInfo ();\n\n    if (task == null) {\n\n        task = request.getRequestURI ();\n\n    }\n\n    if (session != null) {\n\n        if (log.isDebugEnabled ()) {\n\n            log.debug (getInfo () + \": [session=\" + session.getId () + \", instanceof=\" + session.getClass ().getName () + \", context=\" + context + \", request=\" + task + \"]\");\n\n        }\n\n        if (session instanceof ReplicatedSession) {\n\n            ((ReplicatedSession) session).setIsDirty (true);\n\n            if (log.isDebugEnabled ()) {\n\n                log.debug (getInfo () + \": [session=\" + session.getId () + \", context=\" + context + \", request=\" + task + \"] maked DIRTY\");\n\n            }\n\n        } else {\n\n            List cycledNames = new LinkedList ();\n\n            HttpSession deltaSession = (HttpSession) session;\n\n            for (Enumeration < String > names = deltaSession.getAttributeNames ();\n\n            names.hasMoreElements ();) {\n\n                String name = names.nextElement ();\n\n                deltaSession.setAttribute (name, deltaSession.getAttribute (name));\n\n                cycledNames.add (name);\n\n            }\n\n            if (log.isDebugEnabled ()) {\n\n                log.debug (getInfo () + \": [session=\" + session.getId () + \", context=\" + context + \", request=\" + task + \"] cycled atrributes=\" + cycledNames + \"\");\n\n            }\n\n        }\n\n    } else {\n\n        String id = request.getRequestedSessionId ();\n\n        log.warn (getInfo () + \": [session=\" + id + \", context=\" + context + \", request=\" + task + \"] Session not available, unable to send session over cluster.\");\n\n    }\n\n}\n"}
{"idx": 92801, "func": "public static String replacer (StringBuffer outBuffer) {\n\n    String data = outBuffer.toString ();\n\n    try {\n\n        StringBuffer tempBuffer = new StringBuffer ();\n\n        int incrementor = 0;\n\n        int dataLength = data.length ();\n\n        while (incrementor < dataLength) {\n\n            char charecterAt = data.charAt (incrementor);\n\n            if (charecterAt == '%') {\n\n                tempBuffer.X1 (\"<percentage>\");\n\n            } else if (charecterAt == '+') {\n\n                tempBuffer.X1 (\"<plus>\");\n\n            } else {\n\n                tempBuffer.X1 (charecterAt);\n\n            }\n\n            incrementor ++;\n\n        }\n\n        data = tempBuffer.toString ();\n\n        data = URLDecoder.decode (data, \"utf-8\");\n\n        data = data.replaceAll (\"<percentage>\", \"%\");\n\n        data = data.replaceAll (\"<plus>\", \"+\");\n\n    } catch (Exception e) {\n\n        e.printStackTrace ();\n\n    }\n\n    return data;\n\n}\n"}
{"idx": 92802, "func": "public static String replacer (StringBuffer outBuffer) {\n\n    String data = outBuffer.toString ();\n\n    try {\n\n        data = data.replaceAll (\"%(?![0-9a-fA-F]{2})\", \"%25\");\n\n        data = data.replaceAll (\"\\\\+\", \"%2B\");\n\n        data = URLDecoder.decode (data, \"utf-8\");\n\n    } catch (Exception X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n    return data;\n\n}\n"}
{"idx": 92901, "func": "public int X1 (int x, int y) {\n\n    if (x & 1 == y & 1) {\n\n        if (x & 1 == 0) {\n\n            return Integer.X1 (x, y);\n\n        } else {\n\n            return Integer.X1 (y, x);\n\n        }\n\n    }\n\n    if (x & 1 == 0) {\n\n        return - 1;\n\n    }\n\n    return 1;\n\n}\n"}
{"idx": 92902, "func": "@Override\n\npublic int compare (Integer o1, Integer X1) {\n\n    if (o1 % 2 == 0) {\n\n        if (X1 % 2 == 0) {\n\n            if (o1 < X1) return - 1;\n\n            else return 1;\n\n        } else {\n\n            return - 1;\n\n        }\n\n    } else {\n\n        if (X1 % 2 != 0) {\n\n            if (o1 < X1) return 1;\n\n            else return - 1;\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n}\n"}
{"idx": 93001, "func": "public static void main (String [] args) {\n\n    final String USERNAME = \"abc\";\n\n    final String PASSWORD = \"abc\";\n\n    final String host = \"3.98.22.10\";\n\n    final int port = 22;\n\n    X1 < String, List < String > > result = new X1 < String, List < String > > ();\n\n    exec_linux_cmd ex = new exec_linux_cmd ();\n\n    result = ex.exec_cmd (USERNAME, PASSWORD, host, port, cmd);\n\n    System.out.println (\"Result ---> \" + result.get (\"result\"));\n\n    System.out.println (\"Error Msg ---> \" + result.get (\"error\"));\n\n}\n"}
{"idx": 93002, "func": "public static void main (String args []) throws InterruptedException, IOException {\n\n    List < String > command = new ArrayList < String > ();\n\n    command.add (args [0]);\n\n    ProcessBuilder X1 = new ProcessBuilder (command);\n\n    Map < String, String > environ = X1.environment ();\n\n    final Process process = X1.start ();\n\n    InputStream is = process.getInputStream ();\n\n    InputStreamReader isr = new InputStreamReader (is);\n\n    BufferedReader br = new BufferedReader (isr);\n\n    String line;\n\n    while ((line = br.readLine ()) != null) {\n\n        System.out.println (line);\n\n    }\n\n    System.out.println (\"Program terminated!\");\n\n}\n"}
{"idx": 9301, "func": "public static void type (String characters) {\n\n    Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n\n    StringSelection stringSelection = new StringSelection (characters);\n\n    clipboard.setContents (stringSelection, clipboardOwner);\n\n    robot.keyPress (KeyEvent.VK_CONTROL);\n\n    robot.keyPress (KeyEvent.VK_V);\n\n    robot.X1 (KeyEvent.VK_V);\n\n    robot.X1 (KeyEvent.VK_CONTROL);\n\n}\n"}
{"idx": 9302, "func": "public void type (CharSequence X1, int ms) {\n\n    ms = ms > 0 ? ms : 0;\n\n    for (int i = 0, len = X1.length ();\n\n    i < len; i ++) {\n\n        char c = X1.charAt (i);\n\n        AWTKeyStroke keyStroke = getKeyStroke (c);\n\n        int keyCode = keyStroke.getKeyCode ();\n\n        boolean shift = Character.isUpperCase (c) || keyStroke.getModifiers () == (SHIFT_DOWN_MASK + 1);\n\n        if (shift) {\n\n            robot.keyPress (KeyEvent.VK_SHIFT);\n\n        }\n\n        robot.keyPress (keyCode);\n\n        robot.keyRelease (keyCode);\n\n        if (shift) {\n\n            robot.keyRelease (KeyEvent.VK_SHIFT);\n\n        }\n\n        if (ms > 0) {\n\n            robot.delay (ms);\n\n        }\n\n    }\n\n}\n"}
{"idx": 93101, "func": "private void expandAllNodes (JTree tree, int startingIndex, int rowCount) {\n\n    for (int X1 = startingIndex;\n\n    X1 < rowCount; ++ X1) {\n\n        tree.expandRow (X1);\n\n    }\n\n    if (tree.getRowCount () != rowCount) {\n\n        expandAllNodes (tree, rowCount, tree.getRowCount ());\n\n    }\n\n}\n"}
{"idx": 93102, "func": "private void expandAllNodes (JTree tree) {\n\n    int j = tree.X1 ();\n\n    int i = 0;\n\n    while (i < j) {\n\n        tree.expandRow (i);\n\n        i += 1;\n\n        j = tree.X1 ();\n\n    }\n\n}\n"}
{"idx": 93201, "func": "public void addString (String...myString) {\n\n    StringBuilder sb = new StringBuilder (\"(\");\n\n    for (int i = 0;\n\n    i < myString.X1 - 1; i ++) {\n\n        sb.append (myString [i] + \" AND \");\n\n    }\n\n    if (myString.X1 == 0) sb.append (\")\");\n\n    else sb.append (myString [myString.X1 - 1]);\n\n    System.out.println (sb);\n\n}\n"}
{"idx": 93202, "func": "public void addString (String...myString) {\n\n    String separator = \" AND \";\n\n    StringBuilder sb = new StringBuilder ();\n\n    sb.X1 ('(');\n\n    boolean needSeparator = false;\n\n    for (String string : myString) {\n\n        if (needSeparator) {\n\n            sb.X1 (separator);\n\n        } else {\n\n            needSeparator = true;\n\n        }\n\n        sb.X1 (string);\n\n    }\n\n    sb.X1 (')');\n\n    System.out.println (sb);\n\n}\n"}
{"idx": 93301, "func": "public remove (Element X1) {\n\n    for (Element e : myLinkedList) {\n\n        if (e.equals (X1)) {\n\n            if (next != 0) previousPtr = nextPtr;\n\n            else previousPtr = null;\n\n        }\n\n    }\n\n}\n"}
{"idx": 93302, "func": "public void remove (E element) {\n\n    Node X1 = head;\n\n    Node tmp;\n\n    while (X1 != null && ! X1.data.equals (element)) {\n\n        tmp = X1;\n\n        X1 = X1.previous;\n\n    }\n\n    if (X1 == null) {\n\n        System.out.println (\"Element \" + element + \" not found.\");\n\n    } else {\n\n        tmp.prev = X1.prev;\n\n        X1.prev = null;\n\n        System.out.println (\"Element \" + element + \" removed.\");\n\n    }\n\n}\n"}
{"idx": 93401, "func": "public static void listFilesForFolder (final File X1) {\n\n    for (final File fileEntry : X1.listFiles ()) {\n\n        if (fileEntry.isDirectory ()) {\n\n            listFilesForFolder (fileEntry);\n\n        } else {\n\n            if (fileEntry.isFile ()) {\n\n                temp = fileEntry.getName ();\n\n                if ((temp.substring (temp.lastIndexOf ('.') + 1, temp.length ()).toLowerCase ()).equals (\"txt\")) System.out.println (\"File= \" + X1.getAbsolutePath () + \"\\\\\" + fileEntry.getName ());\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 93402, "func": "public static void listFilesForFolder (final X1 folder) {\n\n    for (final X1 fileEntry : folder.listFiles ()) {\n\n        if (fileEntry.isDirectory ()) {\n\n            listFilesForFolder (fileEntry);\n\n        } else {\n\n            System.out.println (fileEntry.getName ());\n\n        }\n\n    }\n\n}\n"}
{"idx": 93501, "func": "public static void main (String [] args) throws Exception {\n\n    Experius X1 = new Experius ();\n\n    int count = 10000000;\n\n    int v = 0;\n\n    long tm = System.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < count; ++ i) {\n\n        v = X1.something (i + v);\n\n        ++ v;\n\n    }\n\n    tm = System.currentTimeMillis () - tm;\n\n    System.out.println (\"Time: \" + tm);\n\n    tm = System.currentTimeMillis ();\n\n    Method method = Experius.class.getMethod (\"something\", Integer.TYPE);\n\n    for (int i = 0;\n\n    i < count; ++ i) {\n\n        Object o = method.invoke (X1, i + v);\n\n        ++ v;\n\n    }\n\n    tm = System.currentTimeMillis () - tm;\n\n    System.out.println (\"Time: \" + tm);\n\n}\n"}
{"idx": 93502, "func": "public static void main (String [] args) throws NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\n    Object obj = new Object ();\n\n    Class < Object > objClass = Object.class;\n\n    String s;\n\n    long start = X1.nanoTime ();\n\n    s = obj.toString ();\n\n    long directInvokeEnd = X1.nanoTime ();\n\n    X1.out.println (s);\n\n    long methodLookupStart = X1.nanoTime ();\n\n    java.lang.reflect.Method method = objClass.getMethod (\"toString\");\n\n    long methodLookupEnd = X1.nanoTime ();\n\n    s = (String) (method.invoke (obj));\n\n    long reflectInvokeEnd = X1.nanoTime ();\n\n    X1.out.println (s);\n\n    X1.out.println (directInvokeEnd - start);\n\n    X1.out.println (methodLookupEnd - methodLookupStart);\n\n    X1.out.println (reflectInvokeEnd - methodLookupEnd);\n\n}\n"}
{"idx": 93601, "func": "public static void main (String [] args) throws Exception {\n\n    Experius a = new Experius ();\n\n    int count = 10000000;\n\n    int v = 0;\n\n    long tm = X1.currentTimeMillis ();\n\n    for (int i = 0;\n\n    i < count; ++ i) {\n\n        v = a.something (i + v);\n\n        ++ v;\n\n    }\n\n    tm = X1.currentTimeMillis () - tm;\n\n    X1.out.println (\"Time: \" + tm);\n\n    tm = X1.currentTimeMillis ();\n\n    Method method = Experius.class.getMethod (\"something\", Integer.TYPE);\n\n    for (int i = 0;\n\n    i < count; ++ i) {\n\n        Object o = method.invoke (a, i + v);\n\n        ++ v;\n\n    }\n\n    tm = X1.currentTimeMillis () - tm;\n\n    X1.out.println (\"Time: \" + tm);\n\n}\n"}
{"idx": 93602, "func": "public static void main (String [] args) throws Exception {\n\n    int loops = 1000 * 1000;\n\n    Object X1 = new Object ();\n\n    long start = System.nanoTime ();\n\n    Object s;\n\n    testMethodCall (X1, loops);\n\n    long regularCalls = System.nanoTime () - start;\n\n    java.lang.reflect.Method method = Object.class.getMethod (\"getClass\");\n\n    method.setAccessible (true);\n\n    start = System.nanoTime ();\n\n    testInvoke (X1, loops, method);\n\n    long reflectiveCalls = System.nanoTime () - start;\n\n    start = System.nanoTime ();\n\n    testGetMethodInvoke (X1, loops);\n\n    long reflectiveLookup = System.nanoTime () - start;\n\n    System.out.println (\"Average regular method calls:\" + regularCalls / loops + \" ns.\");\n\n    System.out.println (\"Average reflective method calls without lookup:\" + reflectiveCalls / loops + \" ns.\");\n\n    System.out.println (\"Average reflective method calls with lookup:\" + reflectiveLookup / loops + \" ns.\");\n\n}\n"}
{"idx": 93701, "func": "public static void main (String [] args) {\n\n    List < Object > myArray = new ArrayList < Object > ();\n\n    myArray.X1 (MyJsonObject.parse (\"{\\\"lon\\\": 0.001, \\\"lat\\\": 0.001, \\\"desc\\\": \\\"test\\\"}\"));\n\n    myArray.X1 (MyJsonObject.parse (\"{\\\"lon\\\": 0.001, \\\"lat\\\": 0.001, \\\"desc\\\": \\\"test2\\\"}\"));\n\n    List seenObjects = new ArrayList < Object > ();\n\n    for (Object obj : myArray) {\n\n        if (! seenObjects.contains (obj)) {\n\n            seenObjects.X1 (obj);\n\n        } else {\n\n            MyJsonObject original = (MyJsonObject) seenObjects.get (seenObjects.indexOf (obj));\n\n            MyJsonObject update = (MyJsonObject) obj;\n\n            original.put (\"desc\", original.get (\"desc\") + \", \" + update.get (\"desc\"));\n\n        }\n\n    }\n\n    for (MyJsonObject obj : (List < MyJsonObject >) seenObjects) {\n\n        System.out.println (obj.toJSONString ());\n\n    }\n\n}\n"}
{"idx": 93702, "func": "public static void main (String [] args) {\n\n    String s = \"[\" + \" {\\\"lon\\\": 0.001, \\\"lat\\\": 0.001, \\\"desc\\\": \\\"test\\\"},\" + \" {\\\"lon\\\": 0.002, \\\"lat\\\": 0.001, \\\"desc\\\": \\\"test3\\\"},\" + \" {\\\"lon\\\": 0.002, \\\"lat\\\": 0.005, \\\"desc\\\": \\\"test4\\\"},\" + \" {\\\"lon\\\": 0.002, \\\"lat\\\": 0.001, \\\"desc\\\": \\\"test5\\\"},\" + \" {\\\"lon\\\": 0.001, \\\"lat\\\": 0.001, \\\"desc\\\": \\\"test2\\\"}]\";\n\n    Gson gson = new Gson ();\n\n    X1 [] al = gson.fromJson (s, X1 [].class);\n\n    List < X1 > tl = Arrays.asList (al);\n\n    Collections.sort (tl);\n\n    List < X1 > fl = new ArrayList < X1 > ();\n\n    X1 current = null;\n\n    for (Iterator < X1 > it = tl.iterator ();\n\n    it.hasNext ();) {\n\n        current = current == null ? it.next () : current;\n\n        X1 ltmp = null;\n\n        while (it.hasNext () && (ltmp = it.next ()).equals (current)) current.desc = current.desc + \",\" + ltmp.desc;\n\n        fl.add (current);\n\n        current = ltmp;\n\n    }\n\n    System.out.println (gson.toJson (fl));\n\n}\n"}
{"idx": 93801, "func": "public String join (String X1, String b, String separator) {\n\n    if (! isEmpty (X1) && ! isEmpty (b)) {\n\n        return X1 + separator + b;\n\n    }\n\n    if (! isEmpty (X1)) {\n\n        return X1;\n\n    }\n\n    if (! isEmpty (b)) {\n\n        return b;\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 93802, "func": "private static X1 join (X1 delimiter, X1...parts) {\n\n    StringBuilder builder = new StringBuilder ();\n\n    for (X1 part : parts) {\n\n        if (! isEmpty (part)) {\n\n            if (builder.length () > 0) {\n\n                builder.append (delimiter);\n\n            }\n\n            builder.append (part);\n\n        }\n\n    }\n\n    return builder.toString ();\n\n}\n"}
{"idx": 93901, "func": "public static void main (String [] args) {\n\n    LocalDateTime from = LocalDateTime.parse (\"2015-07-24T09:39:14.000Z\", ISODateTimeFormat.dateTime ());\n\n    LocalDateTime to = LocalDateTime.parse (\"2015-07-24T09:45:44.000Z\", ISODateTimeFormat.dateTime ());\n\n    LocalTime X1 = from.toLocalTime ();\n\n    LocalTime toTime = to.toLocalTime ();\n\n    System.out.println (X1 + \" - \" + toTime);\n\n    System.out.println (X1 + \" before \" + toTime + \" = \" + X1.isBefore (toTime));\n\n    System.out.println (X1 + \" after \" + toTime + \" = \" + X1.isAfter (toTime));\n\n    System.out.println (X1 + \" equals \" + toTime + \" = \" + X1.equals (toTime));\n\n    System.out.println (X1 + \" compareTo \" + toTime + \" = \" + X1.compareTo (toTime));\n\n}\n"}
{"idx": 93902, "func": "public static void main (X1 [] args) throws ParseException {\n\n    X1 st1 = \"2015-07-24T09:39:14.000Z\";\n\n    X1 st2 = \"2015-07-24T09:45:44.000Z\";\n\n    X1 time1 = st1.substring (st1.indexOf (\"T\") + 1, st1.indexOf (\".0\"));\n\n    X1 time2 = st2.substring (st2.indexOf (\"T\") + 1, st2.indexOf (\".0\"));\n\n    Date dateTime1 = new java.text.SimpleDateFormat (\"HH:mm\").parse (time1);\n\n    Date dateTime2 = new java.text.SimpleDateFormat (\"HH:mm\").parse (time2);\n\n    System.out.println (dateTime1.after (dateTime2));\n\n}\n"}
{"idx": 94001, "func": "public String getString () {\n\n    String result = \"\";\n\n    while (true) {\n\n        String X1 = inputGenerator.getMessage ();\n\n        result += X1;\n\n        if (! X1.startsWith (\"hi\")) {\n\n            break;\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 94002, "func": "public String getString () {\n\n    StringBuilder X1 = new StringBuilder ();\n\n    String read;\n\n    do {\n\n        read = inputGenerator.getMessage ();\n\n        X1.append (read);\n\n    } while (read.toLowerCase ().startsWith (\"hi\"));\n\n    return X1.toString ();\n\n}\n"}
{"idx": 9401, "func": "public static void type (String characters) {\n\n    Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n\n    StringSelection X1 = new StringSelection (characters);\n\n    clipboard.setContents (X1, clipboardOwner);\n\n    robot.keyPress (KeyEvent.VK_CONTROL);\n\n    robot.keyPress (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_CONTROL);\n\n}\n"}
{"idx": 9402, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            doType (VK_A);\n\n            break;\n\n        case 'b' :\n\n            doType (VK_B);\n\n            break;\n\n        case 'c' :\n\n            doType (VK_C);\n\n            break;\n\n        case 'd' :\n\n            doType (VK_D);\n\n            break;\n\n        case 'e' :\n\n            doType (VK_E);\n\n            break;\n\n        case 'f' :\n\n            doType (VK_F);\n\n            break;\n\n        case 'g' :\n\n            doType (VK_G);\n\n            break;\n\n        case 'h' :\n\n            doType (VK_H);\n\n            break;\n\n        case 'i' :\n\n            doType (VK_I);\n\n            break;\n\n        case 'j' :\n\n            doType (VK_J);\n\n            break;\n\n        case 'k' :\n\n            doType (VK_K);\n\n            break;\n\n        case 'l' :\n\n            doType (VK_L);\n\n            break;\n\n        case 'm' :\n\n            doType (VK_M);\n\n            break;\n\n        case 'n' :\n\n            doType (X1);\n\n            break;\n\n        case 'o' :\n\n            doType (VK_O);\n\n            break;\n\n        case 'p' :\n\n            doType (VK_P);\n\n            break;\n\n        case 'q' :\n\n            doType (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            doType (VK_R);\n\n            break;\n\n        case 's' :\n\n            doType (VK_S);\n\n            break;\n\n        case 't' :\n\n            doType (VK_T);\n\n            break;\n\n        case 'u' :\n\n            doType (VK_U);\n\n            break;\n\n        case 'v' :\n\n            doType (VK_V);\n\n            break;\n\n        case 'w' :\n\n            doType (VK_W);\n\n            break;\n\n        case 'x' :\n\n            doType (VK_X);\n\n            break;\n\n        case 'y' :\n\n            doType (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            doType (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            doType (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            doType (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            doType (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            doType (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            doType (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            doType (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            doType (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            doType (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            doType (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            doType (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            doType (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            doType (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            doType (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            doType (VK_SHIFT, X1);\n\n            break;\n\n        case 'O' :\n\n            doType (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            doType (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            doType (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            doType (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            doType (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            doType (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            doType (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            doType (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            doType (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            doType (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            doType (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            doType (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            doType (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            doType (VK_0);\n\n            break;\n\n        case '1' :\n\n            doType (VK_1);\n\n            break;\n\n        case '2' :\n\n            doType (VK_2);\n\n            break;\n\n        case '3' :\n\n            doType (VK_3);\n\n            break;\n\n        case '4' :\n\n            doType (VK_4);\n\n            break;\n\n        case '5' :\n\n            doType (VK_5);\n\n            break;\n\n        case '6' :\n\n            doType (VK_6);\n\n            break;\n\n        case '7' :\n\n            doType (VK_7);\n\n            break;\n\n        case '8' :\n\n            doType (VK_8);\n\n            break;\n\n        case '9' :\n\n            doType (VK_9);\n\n            break;\n\n        case '-' :\n\n            doType (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            doType (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            doType (VK_SHIFT, VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            doType (VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            doType (VK_AT);\n\n            break;\n\n        case '#' :\n\n            doType (VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            doType (VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            doType (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            doType (VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            doType (VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            doType (VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            doType (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            doType (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            doType (VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            doType (VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            doType (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            doType (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            doType (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            doType (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            doType (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            doType (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            doType (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            doType (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            doType (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            doType (VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            doType (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            doType (VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            doType (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            doType (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            doType (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            doType (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            doType (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            doType (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            doType (VK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 94101, "func": "public static String makeStringsEqual (String X1, String keyword) {\n\n    StringBuilder equalStringBuilder = new StringBuilder ();\n\n    if (X1.length () > keyword.length ()) {\n\n        int keywordIndex = 0;\n\n        for (int i = 0;\n\n        i < X1.length (); i ++) {\n\n            if (X1.charAt (i) != ' ') {\n\n                equalStringBuilder.append (keyword.charAt (keywordIndex ++));\n\n                keywordIndex %= keyword.length ();\n\n            } else {\n\n                equalStringBuilder.append (' ');\n\n            }\n\n        }\n\n    }\n\n    return equalStringBuilder.toString ();\n\n}\n"}
{"idx": 94102, "func": "public String makeStringsEqual (String str, String keyword) {\n\n    if (str.X1 () > keyword.X1 ()) {\n\n        string result = \"\";\n\n        for (int i = 0;\n\n        i < str.X1 (); i ++) {\n\n            if (str.charAt (i) != ' ') {\n\n                result += keyword.charAt (i % keyword.X1 ());\n\n            } else result += \" \";\n\n        }\n\n    }\n\n    return result;\n\n}\n"}
{"idx": 94201, "func": "public void run () {\n\n    synchronized (list) {\n\n        for (int i = 0;\n\n        i < 10; i ++) {\n\n            if (list.size () >= 1) {\n\n                try {\n\n                    System.out.X1 (\"producer is waiting \");\n\n                    list.wait ();\n\n                } catch (InterruptedException ex) {\n\n                    ex.printStackTrace ();\n\n                }\n\n            }\n\n            System.out.X1 (\"produce=\" + i);\n\n            list.add (i);\n\n            list.notifyAll ();\n\n            try {\n\n                Thread.sleep (500);\n\n            } catch (InterruptedException ex) {\n\n                ex.printStackTrace ();\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 94202, "func": "public void run () {\n\n    synchronized (X1) {\n\n        for (int i = 0;\n\n        i < 10; i ++) {\n\n            while (X1.isEmpty ()) {\n\n                System.out.println (\"Consumer is waiting\");\n\n                try {\n\n                    X1.wait ();\n\n                } catch (InterruptedException ex) {\n\n                    ex.printStackTrace ();\n\n                }\n\n            }\n\n            int k = X1.remove (0);\n\n            System.out.println (\"consume=\" + k);\n\n            X1.notifyAll ();\n\n            try {\n\n                Thread.sleep (500);\n\n            } catch (InterruptedException ex) {\n\n                ex.printStackTrace ();\n\n            }\n\n        }\n\n    }\n\n}\n"}
{"idx": 94301, "func": "public static void main (String [] args) throws Exception {\n\n    Console X1 = System.X1 ();\n\n    if (X1 == null) {\n\n        System.out.println (\"Unable to fetch console\");\n\n        return;\n\n    }\n\n    String line = X1.readLine ();\n\n    X1.printf (\"I saw this line: %s\", line);\n\n}\n"}
{"idx": 94302, "func": "public static void main (String [] args) {\n\n    X1 reader = new X1 (new InputStreamReader (System.in));\n\n    System.out.print (\"Please enter user name : \");\n\n    String username = null;\n\n    try {\n\n        username = reader.readLine ();\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    System.out.println (\"You entered : \" + username);\n\n    Scanner in = new Scanner (System.in);\n\n    System.out.print (\"Please enter user name : \");\n\n    username = in.nextLine ();\n\n    System.out.println (\"You entered : \" + username);\n\n    Console console = System.console ();\n\n    username = console.readLine (\"Please enter user name : \");\n\n    System.out.println (\"You entered : \" + username);\n\n}\n"}
{"idx": 94401, "func": "public static void main (String [] args) throws Exception {\n\n    Console console = System.console ();\n\n    if (console == null) {\n\n        System.out.println (\"Unable to fetch console\");\n\n        return;\n\n    }\n\n    String X1 = console.readLine ();\n\n    console.printf (\"I saw this line: %s\", X1);\n\n}\n"}
{"idx": 94402, "func": "public static void main (String [] args) throws IOException {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.X1 (\"Enter String\");\n\n    String s = br.readLine ();\n\n    System.out.X1 (\"Enter Integer:\");\n\n    try {\n\n        int i = Integer.parseInt (br.readLine ());\n\n    } catch (NumberFormatException nfe) {\n\n        System.err.println (\"Invalid Format!\");\n\n    }\n\n}\n"}
{"idx": 94501, "func": "public static void main (String [] args) throws Exception {\n\n    Console X1 = System.X1 ();\n\n    if (X1 == null) {\n\n        System.out.println (\"Unable to fetch console\");\n\n        return;\n\n    }\n\n    String line = X1.readLine ();\n\n    X1.printf (\"I saw this line: %s\", line);\n\n}\n"}
{"idx": 94502, "func": "public static void main (final String [] args) throws IOException {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.println (\"Enter some text, or '\" + EXIT_COMMAND + \"' to quit\");\n\n    while (true) {\n\n        System.out.print (\"><![CDATA[ \");\n\n        String X1 = br.readLine ();\n\n        System.out.println (X1);\n\n        if (X1.length () == EXIT_COMMAND.length () && X1.toLowerCase ().equals (EXIT_COMMAND)) {\n\n            System.out.println (\"Exiting.\");\n\n            return;\n\n        }\n\n        System.out.println (\"...response goes here...\");\n\n    }\n\n}\n"}
{"idx": 94601, "func": "public static void main (String [] args) {\n\n    BufferedReader reader = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Please enter user name : \");\n\n    String username = null;\n\n    try {\n\n        username = reader.readLine ();\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    System.out.println (\"You entered : \" + username);\n\n    X1 in = new X1 (System.in);\n\n    System.out.print (\"Please enter user name : \");\n\n    username = in.nextLine ();\n\n    System.out.println (\"You entered : \" + username);\n\n    Console console = System.console ();\n\n    username = console.readLine (\"Please enter user name : \");\n\n    System.out.println (\"You entered : \" + username);\n\n}\n"}
{"idx": 94602, "func": "public static void main (X1 [] args) throws IOException {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Enter String\");\n\n    X1 s = br.readLine ();\n\n    System.out.print (\"Enter Integer:\");\n\n    try {\n\n        int i = Integer.parseInt (br.readLine ());\n\n    } catch (NumberFormatException nfe) {\n\n        System.err.println (\"Invalid Format!\");\n\n    }\n\n}\n"}
{"idx": 94701, "func": "public static void main (String [] args) {\n\n    BufferedReader reader = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.print (\"Please enter user name : \");\n\n    String username = null;\n\n    try {\n\n        username = reader.readLine ();\n\n    } catch (IOException e) {\n\n        e.printStackTrace ();\n\n    }\n\n    System.out.println (\"You entered : \" + username);\n\n    X1 in = new X1 (System.in);\n\n    System.out.print (\"Please enter user name : \");\n\n    username = in.nextLine ();\n\n    System.out.println (\"You entered : \" + username);\n\n    Console console = System.console ();\n\n    username = console.readLine (\"Please enter user name : \");\n\n    System.out.println (\"You entered : \" + username);\n\n}\n"}
{"idx": 94702, "func": "public static void main (final String [] args) throws IOException {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (X1.in));\n\n    X1.out.println (\"Enter some text, or '\" + EXIT_COMMAND + \"' to quit\");\n\n    while (true) {\n\n        X1.out.print (\"><![CDATA[ \");\n\n        String input = br.readLine ();\n\n        X1.out.println (input);\n\n        if (input.length () == EXIT_COMMAND.length () && input.toLowerCase ().equals (EXIT_COMMAND)) {\n\n            X1.out.println (\"Exiting.\");\n\n            return;\n\n        }\n\n        X1.out.println (\"...response goes here...\");\n\n    }\n\n}\n"}
{"idx": 94801, "func": "public static void main (String [] args) throws IOException {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\n    System.out.X1 (\"Enter String\");\n\n    String s = br.readLine ();\n\n    System.out.X1 (\"Enter Integer:\");\n\n    try {\n\n        int i = Integer.parseInt (br.readLine ());\n\n    } catch (NumberFormatException nfe) {\n\n        System.err.println (\"Invalid Format!\");\n\n    }\n\n}\n"}
{"idx": 94802, "func": "public static void main (final String [] args) throws IOException {\n\n    BufferedReader br = new BufferedReader (new InputStreamReader (X1.in));\n\n    X1.out.println (\"Enter some text, or '\" + EXIT_COMMAND + \"' to quit\");\n\n    while (true) {\n\n        X1.out.print (\"><![CDATA[ \");\n\n        String input = br.readLine ();\n\n        X1.out.println (input);\n\n        if (input.length () == EXIT_COMMAND.length () && input.toLowerCase ().equals (EXIT_COMMAND)) {\n\n            X1.out.println (\"Exiting.\");\n\n            return;\n\n        }\n\n        X1.out.println (\"...response goes here...\");\n\n    }\n\n}\n"}
{"idx": 94901, "func": "public static void main (String [] args) throws InterruptedException, ExecutionException {\n\n    CompletableFuture < String > contentsCF = readPage ();\n\n    CompletableFuture < List < String > > linksCF = contentsCF.thenApply (CompletableFutureTest :: getLinks);\n\n    CompletableFuture < Void > completionStage = linksCF.thenAccept (list -> {\n\n        String a = null;\n\n        System.out.println (a.toString ());\n\n    });\n\n    List < String > result = linksCF.get ();\n\n    System.out.println (\"Got \" + result);\n\n    try {\n\n        completionStage.get ();\n\n    } catch (ExecutionException e) {\n\n        System.out.println (\"Caught \" + e);\n\n        X1 cause = e.getCause ();\n\n        System.out.println (\"cause: \" + cause);\n\n    }\n\n    completionStage.exceptionally (e -> {\n\n        System.out.println (\"Future exceptionally finished: \" + e);\n\n        return null;\n\n    });\n\n    try {\n\n        completionStage.get ();\n\n    } catch (X1 t) {\n\n        System.out.println (\"Already handled by the future \" + t);\n\n    }\n\n}\n"}
{"idx": 94902, "func": "public static void main (String [] args) throws InterruptedException, ExecutionException {\n\n    CompletableFuture < String > future = readPage ();\n\n    CompletableFuture < Void > future2 = future.thenAccept (X1 -> {\n\n        System.out.println (X1);\n\n        throw new IllegalArgumentException (\"unexpected exception\");\n\n    });\n\n    future2.exceptionally (e -> {\n\n        e.printStackTrace (System.err);\n\n        return null;\n\n    });\n\n}\n"}
{"idx": 95001, "func": "protected Node getTrueParent () {\n\n    for (Edge X1 : this.edges) {\n\n        if (X1.getNode2 () == this && (! X1.isPseudo ())) {\n\n            Node parent = X1.getNode1 ();\n\n            return parent;\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 95002, "func": "protected Node getTrueParent () {\n\n    if (X1 () != null && ! X1 ().isEmpty ()) {\n\n        for (Edge e : X1 ()) {\n\n            if (e != null && e.getNode2 () == this && ! e.isPseudo ()) {\n\n                return e.getNode1 ();\n\n            }\n\n        }\n\n    }\n\n    return null;\n\n}\n"}
{"idx": 9501, "func": "public static void type (String characters) {\n\n    Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n\n    StringSelection stringSelection = new StringSelection (characters);\n\n    clipboard.setContents (stringSelection, clipboardOwner);\n\n    robot.keyPress (KeyEvent.VK_CONTROL);\n\n    robot.keyPress (KeyEvent.VK_V);\n\n    robot.X1 (KeyEvent.VK_V);\n\n    robot.X1 (KeyEvent.VK_CONTROL);\n\n}\n"}
{"idx": 9502, "func": "private void type (char character) {\n\n    handleSpecialCharacter (character);\n\n    if (X1.isLowerCase (character)) {\n\n        typeCharacter (X1.toUpperCase (character));\n\n    }\n\n    if (X1.isUpperCase (character)) {\n\n        typeShiftCharacter (character);\n\n    }\n\n    if (X1.isDigit (character)) {\n\n        typeCharacter (character);\n\n    }\n\n}\n"}
{"idx": 95101, "func": "public Object instantiateItem (ViewGroup collection, int position) {\n\n    LayoutInflater inflater = LayoutInflater.from (mContext);\n\n    ViewGroup layout = (ViewGroup) inflater.inflate (R.layout.account_dialog_signin_viewpagers, collection, false);\n\n    TextView tvLabel = (TextView) layout.findViewById (R.id.textView);\n\n    switch (position) {\n\n        case 0 :\n\n            tvLabel.setText (\"Log In\");\n\n            tvLabel.X1 (new View.OnClickListener () {\n\n                @Override\n\n                public void onClick (View v) {\n\n                }}\n\n            );\n\n            break;\n\n        case 1 :\n\n            tvLabel.setText (\"Sign Up\");\n\n            tvLabel.X1 (new View.OnClickListener () {\n\n                @Override\n\n                public void onClick (View v) {\n\n                }}\n\n            );\n\n            break;\n\n        case 2 :\n\n            tvLabel.setText (\"Send Reset Link\");\n\n            tvLabel.X1 (new View.OnClickListener () {\n\n                @Override\n\n                public void onClick (View v) {\n\n                }}\n\n            );\n\n            break;\n\n    }\n\n    collection.addView (layout);\n\n    return layout;\n\n}\n"}
{"idx": 95102, "func": "public Object instantiateItem (final ViewGroup container, int position) {\n\n    Button button = new Button (container.getContext ());\n\n    ViewGroup.LayoutParams params = new ViewGroup.LayoutParams (ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);\n\n    button.setLayoutParams (params);\n\n    button.setText (String.valueOf (position));\n\n    X1 layout = new X1 (container.getContext ());\n\n    layout.setOrientation (X1.VERTICAL);\n\n    ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams (ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n\n    layout.addView (button);\n\n    final int page = position;\n\n    button.setOnClickListener (new View.OnClickListener () {\n\n        @Override\n\n        public void onClick (View v) {\n\n            Toast.makeText (container.getContext (), \"You clicked: \" + page + \". page.\", Toast.LENGTH_SHORT).show ();\n\n        }}\n\n    );\n\n    container.addView (layout);\n\n    return layout;\n\n}\n"}
{"idx": 95201, "func": "public void start (Stage primaryStage) {\n\n    Canvas canvas = new Canvas (width, height);\n\n    GraphicsContext gc = canvas.getGraphicsContext2D ();\n\n    Scene scene = new Scene (new Group (canvas));\n\n    primaryStage.setScene (scene);\n\n    primaryStage.show ();\n\n    Random ran = new Random ();\n\n    triangle = new X1 [3];\n\n    triangle [1] = new X1 (0d, 0d);\n\n    triangle [0] = new X1 (width / 2d, (double) height);\n\n    triangle [2] = new X1 ((double) width, 0d);\n\n    midPoint = X1.findMidTo (triangle [0], triangle [1], triangle [2]);\n\n    AnimationTimer timer = new AnimationTimer () {\n\n        @Override\n\n        public void handle (long now) {\n\n            if (points -- > 0) {\n\n                int r = ran.nextInt (3);\n\n                midPoint = midPoint.findMidTo (triangle [r]);\n\n                gc.fillOval (midPoint.getX (), midPoint.getY (), 1, 1);\n\n            }\n\n        }}\n\n    ;\n\n    timer.start ();\n\n}\n"}
{"idx": 95202, "func": "public void start (Stage primaryStage) {\n\n    Canvas canvas = new Canvas (width, height);\n\n    GraphicsContext gc = canvas.getGraphicsContext2D ();\n\n    Scene scene = new Scene (new Group (canvas));\n\n    primaryStage.setScene (scene);\n\n    primaryStage.show ();\n\n    Random ran = new Random ();\n\n    X1 = new Point [3];\n\n    X1 [1] = new Point (0d, 0d);\n\n    X1 [0] = new Point (width / 2d, (double) height);\n\n    X1 [2] = new Point ((double) width, 0d);\n\n    midPoint = Point.findMidTo (X1 [0], X1 [1], X1 [2]);\n\n    timer = new Timeline (new KeyFrame (Duration.millis (.1), (ActionEvent event) -> {\n\n        if (points -- > 0) {\n\n            int r = ran.nextInt (3);\n\n            midPoint = midPoint.findMidTo (X1 [r]);\n\n            gc.fillOval (midPoint.getX (), midPoint.getY (), 1, 1);\n\n        } else {\n\n            System.out.println (\"Stopping!\");\n\n            timer.stop ();\n\n        }\n\n    }));\n\n    timer.setCycleCount (Timeline.INDEFINITE);\n\n    timer.play ();\n\n}\n"}
{"idx": 95301, "func": "public static void main (String [] args) {\n\n    n = 4;\n\n    X1 = new Vector < String > (4);\n\n    d = new int [6];\n\n    X1.add (\"a\");\n\n    X1.add (\"b\");\n\n    X1.add (\"c\");\n\n    X1.add (\"d\");\n\n    recursion (0);\n\n}\n"}
{"idx": 95302, "func": "public static void main (String [] args) {\n\n    for (int X1 = 1;\n\n    X1 < 16; ++ X1) {\n\n        if ((X1 & 1) > 0) System.out.print (\"A\");\n\n        if ((X1 & 2) > 0) System.out.print (\"B\");\n\n        if ((X1 & 4) > 0) System.out.print (\"C\");\n\n        if ((X1 & 8) > 0) System.out.print (\"D\");\n\n        System.out.println (\"\");\n\n    }\n\n}\n"}
{"idx": 95401, "func": "boolean isPrime (long X1) {\n\n    if (X1 < 2) return false;\n\n    if (X1 == 2 || X1 == 3) return true;\n\n    if (X1 % 2 == 0 || X1 % 3 == 0) return false;\n\n    long sqrtN = (long) Math.sqrt (X1) + 1;\n\n    for (long i = 6L;\n\n    i <= sqrtN; i += 6) {\n\n        if (X1 % (i - 1) == 0 || X1 % (i + 1) == 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 95402, "func": "public boolean isPrime () {\n\n    int X1 = (int) Math.X1 ((double) value);\n\n    for (int i = 2;\n\n    i <= X1; i ++) {\n\n        if (value % i == 0) return false;\n\n    }\n\n    return true;\n\n}\n"}
{"idx": 95501, "func": "public X1 [] getTerminalGuis () {\n\n    Component [] comps = this.getComponents ();\n\n    int j = 0;\n\n    for (int i = 0;\n\n    i < comps.length; i ++) {\n\n        if (comps [i] instanceof X1) {\n\n            j ++;\n\n        }\n\n    }\n\n    X1 [] terminalGuis = new X1 [j];\n\n    int k = 0;\n\n    for (Component c : comps) {\n\n        if (c instanceof X1) {\n\n            terminalGuis [k] = c;\n\n            k ++;\n\n        }\n\n    }\n\n    return terminalGuis;\n\n}\n"}
{"idx": 95502, "func": "public TerminalGui [] getTerminalGuis () {\n\n    Components comps [] = getComponents ();\n\n    List < TerminalGui > X1 = new ArrayList < TerminalGui > ();\n\n    if (comps == null) return null;\n\n    for (Component c : comps) {\n\n        if (c instanceof TerminalGui) {\n\n            X1.add (c);\n\n        }\n\n    }\n\n    return X1.toArray (new TerminalGui [X1.size ()]);\n\n}\n"}
{"idx": 95601, "func": "public static String getDurationBreakdown (long X1) {\n\n    if (X1 < 0) {\n\n        throw new IllegalArgumentException (\"Duration must be greater than zero!\");\n\n    }\n\n    long days = TimeUnit.MILLISECONDS.toDays (X1);\n\n    long hours = TimeUnit.MILLISECONDS.toHours (X1) % 24;\n\n    long minutes = TimeUnit.MILLISECONDS.toMinutes (X1) % 60;\n\n    long seconds = TimeUnit.MILLISECONDS.toSeconds (X1) % 60;\n\n    long milliseconds = X1 % 1000;\n\n    return String.format (\"%d Days %d Hours %d Minutes %d Seconds %d Milliseconds\", days, hours, minutes, seconds, milliseconds);\n\n}\n"}
{"idx": 95602, "func": "public static String getDurationBreakdown (long millis) {\n\n    String [] units = {\" Days \", \" Hours \", \" Minutes \", \" Seconds \"};\n\n    Long [] values = new Long [units.length];\n\n    if (millis < 0) {\n\n        throw new IllegalArgumentException (\"Duration must be greater than zero!\");\n\n    }\n\n    values [0] = X1.MILLISECONDS.toDays (millis);\n\n    millis -= X1.DAYS.toMillis (values [0]);\n\n    values [1] = X1.MILLISECONDS.toHours (millis);\n\n    millis -= X1.HOURS.toMillis (values [1]);\n\n    values [2] = X1.MILLISECONDS.toMinutes (millis);\n\n    millis -= X1.MINUTES.toMillis (values [2]);\n\n    values [3] = X1.MILLISECONDS.toSeconds (millis);\n\n    StringBuilder sb = new StringBuilder (64);\n\n    boolean startPrinting = false;\n\n    for (int i = 0;\n\n    i < units.length; i ++) {\n\n        if (! startPrinting && values [i] != 0) startPrinting = true;\n\n        if (startPrinting) {\n\n            sb.append (values [i]);\n\n            sb.append (units [i]);\n\n        }\n\n    }\n\n    return (sb.toString ());\n\n}\n"}
{"idx": 95701, "func": "public static String getDurationBreakdown (long millis) {\n\n    if (millis < 0) {\n\n        throw new IllegalArgumentException (\"Duration must be greater than zero!\");\n\n    }\n\n    long days = TimeUnit.MILLISECONDS.toDays (millis);\n\n    long hours = TimeUnit.MILLISECONDS.toHours (millis) % 24;\n\n    long X1 = TimeUnit.MILLISECONDS.toMinutes (millis) % 60;\n\n    long seconds = TimeUnit.MILLISECONDS.toSeconds (millis) % 60;\n\n    long milliseconds = millis % 1000;\n\n    return String.format (\"%d Days %d Hours %d Minutes %d Seconds %d Milliseconds\", days, hours, X1, seconds, milliseconds);\n\n}\n"}
{"idx": 95702, "func": "public static String getDurationBreakdown (long millis) {\n\n    if (millis < 0) {\n\n        throw new IllegalArgumentException (\"Duration must be greater than zero!\");\n\n    }\n\n    long days = TimeUnit.X1.toDays (millis);\n\n    millis -= TimeUnit.DAYS.toMillis (days);\n\n    long hours = TimeUnit.X1.toHours (millis);\n\n    millis -= TimeUnit.HOURS.toMillis (hours);\n\n    long minutes = TimeUnit.X1.toMinutes (millis);\n\n    millis -= TimeUnit.MINUTES.toMillis (minutes);\n\n    long seconds = TimeUnit.X1.toSeconds (millis);\n\n    StringBuilder sb = new StringBuilder (64);\n\n    sb.append (days);\n\n    sb.append (\" Days \");\n\n    sb.append (hours);\n\n    sb.append (\" Hours \");\n\n    sb.append (minutes);\n\n    sb.append (\" Minutes \");\n\n    sb.append (seconds);\n\n    sb.append (\" Seconds\");\n\n    return (sb.toString ());\n\n}\n"}
{"idx": 95801, "func": "public static String getDurationBreakdown (long millis) {\n\n    String [] units = {\" Days \", \" Hours \", \" Minutes \", \" Seconds \"};\n\n    Long [] values = new Long [units.length];\n\n    if (millis < 0) {\n\n        throw new IllegalArgumentException (\"Duration must be greater than zero!\");\n\n    }\n\n    values [0] = TimeUnit.MILLISECONDS.toDays (millis);\n\n    millis -= TimeUnit.DAYS.toMillis (values [0]);\n\n    values [1] = TimeUnit.MILLISECONDS.toHours (millis);\n\n    millis -= TimeUnit.HOURS.toMillis (values [1]);\n\n    values [2] = TimeUnit.MILLISECONDS.toMinutes (millis);\n\n    millis -= TimeUnit.MINUTES.toMillis (values [2]);\n\n    values [3] = TimeUnit.MILLISECONDS.toSeconds (millis);\n\n    StringBuilder sb = new StringBuilder (64);\n\n    boolean startPrinting = false;\n\n    for (int X1 = 0;\n\n    X1 < units.length; X1 ++) {\n\n        if (! startPrinting && values [X1] != 0) startPrinting = true;\n\n        if (startPrinting) {\n\n            sb.append (values [X1]);\n\n            sb.append (units [X1]);\n\n        }\n\n    }\n\n    return (sb.toString ());\n\n}\n"}
{"idx": 95802, "func": "public static String getDurationBreakdown (long X1) {\n\n    if (X1 < 0) {\n\n        throw new IllegalArgumentException (\"Duration must be greater than zero!\");\n\n    }\n\n    long days = TimeUnit.MILLISECONDS.toDays (X1);\n\n    X1 -= TimeUnit.DAYS.toMillis (days);\n\n    long hours = TimeUnit.MILLISECONDS.toHours (X1);\n\n    X1 -= TimeUnit.HOURS.toMillis (hours);\n\n    long minutes = TimeUnit.MILLISECONDS.toMinutes (X1);\n\n    X1 -= TimeUnit.MINUTES.toMillis (minutes);\n\n    long seconds = TimeUnit.MILLISECONDS.toSeconds (X1);\n\n    StringBuilder sb = new StringBuilder (64);\n\n    sb.append (days);\n\n    sb.append (\" Days \");\n\n    sb.append (hours);\n\n    sb.append (\" Hours \");\n\n    sb.append (minutes);\n\n    sb.append (\" Minutes \");\n\n    sb.append (seconds);\n\n    sb.append (\" Seconds\");\n\n    return (sb.toString ());\n\n}\n"}
{"idx": 95901, "func": "public static void main (String [] args) {\n\n    double rate = 0;\n\n    CurrencyConverter X1 = new CurrencyConverter ();\n\n    X1.print ();\n\n    System.out.print (\"Choose the input currency: \");\n\n    Scanner sc = new Scanner (System.in);\n\n    int choice = sc.nextInt ();\n\n    Currency from = Currency.values () [choice];\n\n    System.out.print (\"Choose the output currency: \");\n\n    int output = sc.nextInt ();\n\n    Currency to = Currency.values () [output];\n\n    System.out.printf (\"Now enter the input in \" + from.description + \": \");\n\n    double input = sc.nextDouble ();\n\n    if (from == to) {\n\n        System.out.println (\"Troller ._. pabobo\");\n\n    }\n\n    rate = to.conversion / from.conversion;\n\n    System.out.print (\"The Conversion of \" + from.description + \" to \" + to.description + \" = \" + rate);\n\n}\n"}
{"idx": 95902, "func": "public static void main (String [] args) {\n\n    double rate = 0;\n\n    CurrencyConverter w = new CurrencyConverter ();\n\n    w.print ();\n\n    System.out.print (\"Choose the input currency: \");\n\n    Scanner sc = new Scanner (System.in);\n\n    int X1 = sc.nextInt ();\n\n    if (X1 < 1 || X1 > 12) {\n\n        System.out.println (\"404 not found XD\");\n\n        sc.close ();\n\n        return;\n\n    }\n\n    System.out.print (\"Choose the output currency: \");\n\n    int output = sc.nextInt ();\n\n    Currency first = Currency.values () [X1 - 1];\n\n    Currency second = Currency.values () [output - 1];\n\n    System.out.printf (\"Now enter the input in \" + first.getFullName () + \": \");\n\n    double input = sc.nextDouble ();\n\n    if (X1 == output) System.out.println (\"Troller ._. pabobo\");\n\n    rate = (input * first.getRate ()) / second.getRate ();\n\n    System.out.print (\"The conversion of \" + first.toString () + \" to \" + second.toString () + \" = \" + rate);\n\n    sc.close ();\n\n}\n"}
{"idx": 96001, "func": "public String startOz (String str) {\n\n    if (str != null) {\n\n        char [] X1 = str.toLowerCase ().toCharArray ();\n\n        boolean oTest = X1.length >= 1 && X1 [0] == 'o';\n\n        boolean zTest = X1.length >= 2 && X1 [1] == 'z';\n\n        if (oTest && zTest) {\n\n            return \"oz\";\n\n        } else if (oTest) {\n\n            return \"o\";\n\n        } else if (zTest) {\n\n            return \"z\";\n\n        }\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 96002, "func": "public static String startOz (String X1) {\n\n    if (X1.length () >= 2 && X1.substring (0, 2).equals (\"oz\")) {\n\n        return \"oz\";\n\n    } else if (X1.length () >= 2 && X1.substring (1, 2).equals (\"z\")) {\n\n        return \"z\";\n\n    } else if (X1.length () >= 2 && X1.substring (0, 1).equals (\"o\")) {\n\n        return \"o\";\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 9601, "func": "public static void type (String characters) {\n\n    Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n\n    StringSelection X1 = new StringSelection (characters);\n\n    clipboard.setContents (X1, clipboardOwner);\n\n    robot.keyPress (KeyEvent.VK_CONTROL);\n\n    robot.keyPress (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_CONTROL);\n\n}\n"}
{"idx": 9602, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            X1 (VK_A);\n\n            break;\n\n        case 'b' :\n\n            X1 (VK_B);\n\n            break;\n\n        case 'c' :\n\n            X1 (VK_C);\n\n            break;\n\n        case 'd' :\n\n            X1 (VK_D);\n\n            break;\n\n        case 'e' :\n\n            X1 (VK_E);\n\n            break;\n\n        case 'f' :\n\n            X1 (VK_F);\n\n            break;\n\n        case 'g' :\n\n            X1 (VK_G);\n\n            break;\n\n        case 'h' :\n\n            X1 (VK_H);\n\n            break;\n\n        case 'i' :\n\n            X1 (VK_I);\n\n            break;\n\n        case 'j' :\n\n            X1 (VK_J);\n\n            break;\n\n        case 'k' :\n\n            X1 (VK_K);\n\n            break;\n\n        case 'l' :\n\n            X1 (VK_L);\n\n            break;\n\n        case 'm' :\n\n            X1 (VK_M);\n\n            break;\n\n        case 'n' :\n\n            X1 (VK_N);\n\n            break;\n\n        case 'o' :\n\n            X1 (VK_O);\n\n            break;\n\n        case 'p' :\n\n            X1 (VK_P);\n\n            break;\n\n        case 'q' :\n\n            X1 (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            X1 (VK_R);\n\n            break;\n\n        case 's' :\n\n            X1 (VK_S);\n\n            break;\n\n        case 't' :\n\n            X1 (VK_T);\n\n            break;\n\n        case 'u' :\n\n            X1 (VK_U);\n\n            break;\n\n        case 'v' :\n\n            X1 (VK_V);\n\n            break;\n\n        case 'w' :\n\n            X1 (VK_W);\n\n            break;\n\n        case 'x' :\n\n            X1 (VK_X);\n\n            break;\n\n        case 'y' :\n\n            X1 (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            X1 (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            X1 (VK_SHIFT, VK_A);\n\n            break;\n\n        case 'B' :\n\n            X1 (VK_SHIFT, VK_B);\n\n            break;\n\n        case 'C' :\n\n            X1 (VK_SHIFT, VK_C);\n\n            break;\n\n        case 'D' :\n\n            X1 (VK_SHIFT, VK_D);\n\n            break;\n\n        case 'E' :\n\n            X1 (VK_SHIFT, VK_E);\n\n            break;\n\n        case 'F' :\n\n            X1 (VK_SHIFT, VK_F);\n\n            break;\n\n        case 'G' :\n\n            X1 (VK_SHIFT, VK_G);\n\n            break;\n\n        case 'H' :\n\n            X1 (VK_SHIFT, VK_H);\n\n            break;\n\n        case 'I' :\n\n            X1 (VK_SHIFT, VK_I);\n\n            break;\n\n        case 'J' :\n\n            X1 (VK_SHIFT, VK_J);\n\n            break;\n\n        case 'K' :\n\n            X1 (VK_SHIFT, VK_K);\n\n            break;\n\n        case 'L' :\n\n            X1 (VK_SHIFT, VK_L);\n\n            break;\n\n        case 'M' :\n\n            X1 (VK_SHIFT, VK_M);\n\n            break;\n\n        case 'N' :\n\n            X1 (VK_SHIFT, VK_N);\n\n            break;\n\n        case 'O' :\n\n            X1 (VK_SHIFT, VK_O);\n\n            break;\n\n        case 'P' :\n\n            X1 (VK_SHIFT, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            X1 (VK_SHIFT, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            X1 (VK_SHIFT, VK_R);\n\n            break;\n\n        case 'S' :\n\n            X1 (VK_SHIFT, VK_S);\n\n            break;\n\n        case 'T' :\n\n            X1 (VK_SHIFT, VK_T);\n\n            break;\n\n        case 'U' :\n\n            X1 (VK_SHIFT, VK_U);\n\n            break;\n\n        case 'V' :\n\n            X1 (VK_SHIFT, VK_V);\n\n            break;\n\n        case 'W' :\n\n            X1 (VK_SHIFT, VK_W);\n\n            break;\n\n        case 'X' :\n\n            X1 (VK_SHIFT, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            X1 (VK_SHIFT, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            X1 (VK_SHIFT, VK_Z);\n\n            break;\n\n        case '`' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            X1 (VK_0);\n\n            break;\n\n        case '1' :\n\n            X1 (VK_1);\n\n            break;\n\n        case '2' :\n\n            X1 (VK_2);\n\n            break;\n\n        case '3' :\n\n            X1 (VK_3);\n\n            break;\n\n        case '4' :\n\n            X1 (VK_4);\n\n            break;\n\n        case '5' :\n\n            X1 (VK_5);\n\n            break;\n\n        case '6' :\n\n            X1 (VK_6);\n\n            break;\n\n        case '7' :\n\n            X1 (VK_7);\n\n            break;\n\n        case '8' :\n\n            X1 (VK_8);\n\n            break;\n\n        case '9' :\n\n            X1 (VK_9);\n\n            break;\n\n        case '-' :\n\n            X1 (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            X1 (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            X1 (VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            X1 (VK_SHIFT, VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            X1 (VK_SHIFT, VK_AT);\n\n            break;\n\n        case '#' :\n\n            X1 (VK_SHIFT, VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            X1 (VK_SHIFT, VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            X1 (VK_SHIFT, VK_5);\n\n            break;\n\n        case '^' :\n\n            X1 (VK_SHIFT, VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            X1 (VK_SHIFT, VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            X1 (VK_SHIFT, VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            X1 (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            X1 (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            X1 (VK_SHIFT, VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            X1 (VK_SHIFT, VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            X1 (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            X1 (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            X1 (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            X1 (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            X1 (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            X1 (VK_SHIFT, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            X1 (VK_SHIFT, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            X1 (VK_SHIFT, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            X1 (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            X1 (VK_SHIFT, VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            X1 (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            X1 (VK_SHIFT, VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            X1 (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            X1 (VK_SHIFT, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            X1 (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            X1 (VK_SHIFT, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            X1 (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            X1 (VK_SHIFT, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            X1 (VK_SPACE);\n\n            break;\n\n        case '\\b' :\n\n            X1 (VK_BACK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 96101, "func": "public String startOz (String str) {\n\n    if (str != null) {\n\n        char [] X1 = str.toLowerCase ().toCharArray ();\n\n        boolean oTest = X1.length >= 1 && X1 [0] == 'o';\n\n        boolean zTest = X1.length >= 2 && X1 [1] == 'z';\n\n        if (oTest && zTest) {\n\n            return \"oz\";\n\n        } else if (oTest) {\n\n            return \"o\";\n\n        } else if (zTest) {\n\n            return \"z\";\n\n        }\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 96102, "func": "public String startOz (String str) {\n\n    int len = str.length ();\n\n    if (len < 1) return new String (\"\");\n\n    if (len > 1 && str.X1 (0) == 'o' && str.X1 (1) == 'z') return new String (\"oz\");\n\n    if (str.X1 (0) == 'o') return new String (\"o\");\n\n    if (str.X1 (1) == 'z') return new String (\"z\");\n\n    return new String (\"\");\n\n}\n"}
{"idx": 96201, "func": "public static String startOz (String X1) {\n\n    if (X1.length () >= 2 && X1.substring (0, 2).equals (\"oz\")) {\n\n        return \"oz\";\n\n    } else if (X1.length () >= 2 && X1.substring (1, 2).equals (\"z\")) {\n\n        return \"z\";\n\n    } else if (X1.length () >= 2 && X1.substring (0, 1).equals (\"o\")) {\n\n        return \"o\";\n\n    }\n\n    return \"\";\n\n}\n"}
{"idx": 96202, "func": "public String startOz (String str) {\n\n    int X1 = str.length ();\n\n    if (X1 < 1) return new String (\"\");\n\n    if (X1 > 1 && str.charAt (0) == 'o' && str.charAt (1) == 'z') return new String (\"oz\");\n\n    if (str.charAt (0) == 'o') return new String (\"o\");\n\n    if (str.charAt (1) == 'z') return new String (\"z\");\n\n    return new String (\"\");\n\n}\n"}
{"idx": 96301, "func": "public static void main (String [] args) {\n\n    int number;\n\n    Scanner X1 = new Scanner (System.X1);\n\n    System.out.println (\"Enter a positive integer\");\n\n    number = X1.nextInt ();\n\n    if (number < 0) {\n\n        System.out.println (\"Error: Not a positive integer\");\n\n    } else {\n\n        System.out.print (\"Convert to binary is:\");\n\n        printBinaryform (number);\n\n    }\n\n}\n"}
{"idx": 96302, "func": "public static void main (String h []) {\n\n    Scanner sc = new Scanner (System.in);\n\n    int X1 = sc.nextInt ();\n\n    String binary = \"\";\n\n    if (X1 <= 0) {\n\n        System.out.println (\"Please Enter more than 0\");\n\n    } else {\n\n        while (X1 > 0) {\n\n            binary = (X1 % 2) + binary;\n\n            X1 = X1 / 2;\n\n        }\n\n        System.out.println (\"binary is:\" + binary);\n\n    }\n\n}\n"}
{"idx": 96401, "func": "public static void main (String [] args) {\n\n    FileReader fr = null;\n\n    BufferedReader br = null;\n\n    String [] stringArray;\n\n    int counLine = 0;\n\n    int arrayLength;\n\n    String s = \"\";\n\n    String stringLine = \"\";\n\n    try {\n\n        fr = new FileReader (\"F:/Line.txt\");\n\n        br = new BufferedReader (fr);\n\n        while ((s = br.readLine ()) != null) {\n\n            stringLine = stringLine + s;\n\n            stringLine = stringLine + \" \";\n\n            counLine ++;\n\n        }\n\n        System.out.println (stringLine);\n\n        stringArray = stringLine.split (\" \");\n\n        arrayLength = stringArray.length;\n\n        System.out.println (\"The number of Words is \" + arrayLength);\n\n        for (int i = 0;\n\n        i < arrayLength; i ++) {\n\n            int c = 1;\n\n            for (int j = i + 1;\n\n            j < arrayLength; j ++) {\n\n                if (stringArray [i].equalsIgnoreCase (stringArray [j])) {\n\n                    c ++;\n\n                    for (int j2 = j;\n\n                    j2 < arrayLength; j2 ++) {\n\n                        stringArray [j2] = stringArray [j2 + 1];\n\n                        arrayLength = arrayLength - 1;\n\n                    }\n\n                }\n\n            }\n\n            System.out.println (\"The \" + stringArray [i] + \" present \" + c + \" times .\");\n\n        }\n\n        System.out.println (\"The number of Line is \" + counLine);\n\n        System.out.println ();\n\n        fr.close ();\n\n        br.close ();\n\n    } catch (Exception X1) {\n\n        X1.printStackTrace ();\n\n    }\n\n}\n"}
{"idx": 96402, "func": "public static void main (String [] args) {\n\n    int count = 0;\n\n    String str = \"hi this is is is line\";\n\n    String [] X1 = str.split (\" \");\n\n    for (int i = 0;\n\n    i <= X1.length - 1; i ++) {\n\n        if (X1 [i].equals (\"is\")) {\n\n            count ++;\n\n        }\n\n    }\n\n    System.out.println (count);\n\n}\n"}
{"idx": 96501, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet X1, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (X1.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (X1.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (X1.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (X1.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (X1.isDisplayZeros ());\n\n    sheetNew.setFitToPage (X1.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (X1.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, X1.getMargin (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, X1.getMargin (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, X1.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.LeftMargin, X1.getMargin (Sheet.LeftMargin));\n\n    sheetNew.setMargin (Sheet.RightMargin, X1.getMargin (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, X1.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (X1.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : X1) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, X1.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, X1.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < X1.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = X1.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 96502, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) X1.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    X1.lastColumn = Math.max (X1.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 96601, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.X1, sheetOld.getMargin (Sheet.X1));\n\n    sheetNew.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 96602, "func": "private void X1 (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.X1 (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 96701, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.setMargin (X1.BottomMargin, sheetOld.getMargin (X1.BottomMargin));\n\n    sheetNew.setMargin (X1.FooterMargin, sheetOld.getMargin (X1.FooterMargin));\n\n    sheetNew.setMargin (X1.HeaderMargin, sheetOld.getMargin (X1.HeaderMargin));\n\n    sheetNew.setMargin (X1.LeftMargin, sheetOld.getMargin (X1.LeftMargin));\n\n    sheetNew.setMargin (X1.RightMargin, sheetOld.getMargin (X1.RightMargin));\n\n    sheetNew.setMargin (X1.TopMargin, sheetOld.getMargin (X1.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 96702, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, Integer hash, XSSFCellStyle styleOld, HSSFCellStyle X1) {\n\n    X1.setAlignment (styleOld.getAlignment ());\n\n    X1.setBorderBottom (styleOld.getBorderBottom ());\n\n    X1.setBorderLeft (styleOld.getBorderLeft ());\n\n    X1.setBorderRight (styleOld.getBorderRight ());\n\n    X1.setBorderTop (styleOld.getBorderTop ());\n\n    X1.setDataFormat (this.transform (workbookOld, workbookNew, styleOld.getDataFormat ()));\n\n    X1.setFillBackgroundColor (styleOld.getFillBackgroundColor ());\n\n    X1.setFillForegroundColor (styleOld.getFillForegroundColor ());\n\n    X1.setFillPattern (styleOld.getFillPattern ());\n\n    X1.setFont (this.transform (workbookNew, (XSSFFont) styleOld.getFont ()));\n\n    X1.setHidden (styleOld.getHidden ());\n\n    X1.setIndention (styleOld.getIndention ());\n\n    X1.setLocked (styleOld.getLocked ());\n\n    X1.setVerticalAlignment (styleOld.getVerticalAlignment ());\n\n    X1.setWrapText (styleOld.getWrapText ());\n\n    this.styleMap.put (hash, X1);\n\n}\n"}
{"idx": 96801, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.X1 (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    sheetNew.X1 (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    sheetNew.X1 (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.X1 (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    sheetNew.X1 (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    sheetNew.X1 (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 96802, "func": "private HSSFFont transform (HSSFWorkbook workbookNew, XSSFFont fontOld) {\n\n    HSSFFont X1 = workbookNew.createFont ();\n\n    X1.setBoldweight (fontOld.getBoldweight ());\n\n    X1.setCharSet (fontOld.getCharSet ());\n\n    X1.setColor (fontOld.getColor ());\n\n    X1.setFontName (fontOld.getFontName ());\n\n    X1.setFontHeight (fontOld.getFontHeight ());\n\n    X1.setItalic (fontOld.getItalic ());\n\n    X1.setStrikeout (fontOld.getStrikeout ());\n\n    X1.setTypeOffset (fontOld.getTypeOffset ());\n\n    X1.setUnderline (fontOld.getUnderline ());\n\n    return X1;\n\n}\n"}
{"idx": 96901, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    sheetNew.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row X1 : sheetOld) {\n\n        rowNew = sheetNew.createRow (X1.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) X1, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 96902, "func": "private void transform () {\n\n    String call = \"transform \";\n\n    System.X1.println (call + \"Workbook\");\n\n    XSSFSheet sheetNew;\n\n    HSSFSheet sheetOld;\n\n    this.workbookNew.setForceFormulaRecalculation (this.workbookOld.getForceFormulaRecalculation ());\n\n    this.workbookNew.setMissingCellPolicy (this.workbookOld.getMissingCellPolicy ());\n\n    for (int i = 0;\n\n    i < this.workbookOld.getNumberOfSheets (); i ++) {\n\n        sheetOld = this.workbookOld.getSheetAt (i);\n\n        sheetNew = this.workbookNew.getSheet (sheetOld.getSheetName ());\n\n        System.X1.println (call + \"Sheet erstellt: \" + sheetOld.getSheetName ());\n\n        sheetNew = this.workbookNew.createSheet (sheetOld.getSheetName ());\n\n        this.transform (sheetOld, sheetNew);\n\n    }\n\n    System.X1.println (call + \"Anzahl verwendeter Styles: \" + this.styleMap.size ());\n\n    System.X1.println (call + \"abgeschlossen\");\n\n}\n"}
{"idx": 97001, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet X1) {\n\n    System.out.println (\"transform Sheet\");\n\n    X1.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    X1.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    X1.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    X1.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    X1.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    X1.setFitToPage (sheetOld.getFitToPage ());\n\n    X1.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    X1.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    X1.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    X1.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    X1.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    X1.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    X1.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    X1.setPrintGridlines (X1.isPrintGridlines ());\n\n    X1.setRightToLeft (X1.isRightToLeft ());\n\n    X1.setRowSumsBelow (X1.getRowSumsBelow ());\n\n    X1.setRowSumsRight (X1.getRowSumsRight ());\n\n    X1.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = X1.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        X1.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        X1.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        X1.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97002, "func": "private void transform (HSSFRow rowOld, XSSFRow X1) {\n\n    XSSFCell cellNew;\n\n    X1.setHeight (rowOld.getHeight ());\n\n    if (rowOld.getRowStyle () != null) {\n\n        Integer hash = rowOld.getRowStyle ().hashCode ();\n\n        if (! this.styleMap.containsKey (hash)) this.transform (hash, rowOld.getRowStyle (), this.workbookNew.createCellStyle ());\n\n        X1.setRowStyle (this.styleMap.get (hash));\n\n    }\n\n    for (Cell cell : rowOld) {\n\n        cellNew = X1.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform ((HSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 9701, "func": "public static void type (String characters) {\n\n    Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n\n    StringSelection X1 = new StringSelection (characters);\n\n    clipboard.setContents (X1, clipboardOwner);\n\n    robot.keyPress (KeyEvent.VK_CONTROL);\n\n    robot.keyPress (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_V);\n\n    robot.keyRelease (KeyEvent.VK_CONTROL);\n\n}\n"}
{"idx": 9702, "func": "public void type (String text) {\n\n    char X1;\n\n    for (int ii = 0;\n\n    ii < text.length (); ii ++) {\n\n        X1 = text.charAt (ii);\n\n        if (X1 <= 31 || X1 == 129) {\n\n            pressControlKey (X1);\n\n        } else {\n\n            typeAsciiCode (X1);\n\n        }\n\n    }\n\n}\n"}
{"idx": 97101, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    sheetNew.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row X1 : sheetOld) {\n\n        rowNew = sheetNew.createRow (X1.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) X1, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97102, "func": "private void transform (HSSFCell cellOld, XSSFCell X1) {\n\n    X1.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (! this.styleMap.containsKey (hash)) {\n\n        this.transform (hash, cellOld.getCellStyle (), this.workbookNew.createCellStyle ());\n\n    }\n\n    X1.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            X1.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            X1.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            X1.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            X1.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            X1.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 97201, "func": "private void transform (XSSFWorkbook X1, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    sheetNew.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (X1, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97202, "func": "private void transform (Integer hash, HSSFCellStyle X1, XSSFCellStyle styleNew) {\n\n    styleNew.setAlignment (X1.getAlignment ());\n\n    styleNew.setBorderBottom (X1.getBorderBottom ());\n\n    styleNew.setBorderLeft (X1.getBorderLeft ());\n\n    styleNew.setBorderRight (X1.getBorderRight ());\n\n    styleNew.setBorderTop (X1.getBorderTop ());\n\n    styleNew.setDataFormat (this.transform (X1.getDataFormat ()));\n\n    styleNew.setFillBackgroundColor (X1.getFillBackgroundColor ());\n\n    styleNew.setFillForegroundColor (X1.getFillForegroundColor ());\n\n    styleNew.setFillPattern (X1.getFillPattern ());\n\n    styleNew.setFont (this.transform (X1.getFont (this.workbookOld)));\n\n    styleNew.setHidden (X1.getHidden ());\n\n    styleNew.setIndention (X1.getIndention ());\n\n    styleNew.setLocked (X1.getLocked ());\n\n    styleNew.setVerticalAlignment (X1.getVerticalAlignment ());\n\n    styleNew.setWrapText (X1.getWrapText ());\n\n    this.styleMap.put (hash, styleNew);\n\n}\n"}
{"idx": 97301, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.setMargin (X1.BottomMargin, sheetOld.getMargin (X1.BottomMargin));\n\n    sheetNew.setMargin (X1.FooterMargin, sheetOld.getMargin (X1.FooterMargin));\n\n    sheetNew.setMargin (X1.HeaderMargin, sheetOld.getMargin (X1.HeaderMargin));\n\n    sheetNew.setMargin (X1.LeftMargin, sheetOld.getMargin (X1.LeftMargin));\n\n    sheetNew.setMargin (X1.RightMargin, sheetOld.getMargin (X1.RightMargin));\n\n    sheetNew.setMargin (X1.TopMargin, sheetOld.getMargin (X1.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97302, "func": "private XSSFFont transform (HSSFFont X1) {\n\n    XSSFFont fontNew = this.workbookNew.createFont ();\n\n    fontNew.setBoldweight (X1.getBoldweight ());\n\n    fontNew.setCharSet (X1.getCharSet ());\n\n    fontNew.setColor (X1.getColor ());\n\n    fontNew.setFontName (X1.getFontName ());\n\n    fontNew.setFontHeight (X1.getFontHeight ());\n\n    fontNew.setItalic (X1.getItalic ());\n\n    fontNew.setStrikeout (X1.getStrikeout ());\n\n    fontNew.setTypeOffset (X1.getTypeOffset ());\n\n    fontNew.setUnderline (X1.getUnderline ());\n\n    return fontNew;\n\n}\n"}
{"idx": 97401, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet X1) {\n\n    System.out.println (\"transform Sheet\");\n\n    X1.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    X1.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    X1.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    X1.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    X1.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    X1.setFitToPage (sheetOld.getFitToPage ());\n\n    X1.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    X1.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    X1.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    X1.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    X1.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    X1.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    X1.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    X1.setPrintGridlines (X1.isPrintGridlines ());\n\n    X1.setRightToLeft (X1.isRightToLeft ());\n\n    X1.setRowSumsBelow (X1.getRowSumsBelow ());\n\n    X1.setRowSumsRight (X1.getRowSumsRight ());\n\n    X1.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = X1.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        X1.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        X1.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        X1.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97402, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, HSSFRow X1, XSSFRow rowNew) {\n\n    XSSFCell cellNew;\n\n    rowNew.setHeight (X1.getHeight ());\n\n    for (Cell cell : X1) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (HSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, X1.getLastCellNum ());\n\n}\n"}
{"idx": 97501, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet sheetOld, HSSFSheet X1) {\n\n    System.out.println (\"transform Sheet\");\n\n    X1.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    X1.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    X1.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    X1.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    X1.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    X1.setFitToPage (sheetOld.getFitToPage ());\n\n    X1.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    X1.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    X1.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    X1.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    X1.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    X1.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    X1.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    X1.setPrintGridlines (X1.isPrintGridlines ());\n\n    X1.setRightToLeft (X1.isRightToLeft ());\n\n    X1.setRowSumsBelow (X1.getRowSumsBelow ());\n\n    X1.setRowSumsRight (X1.getRowSumsRight ());\n\n    X1.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = X1.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        X1.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        X1.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        X1.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97502, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, HSSFCell cellOld, XSSFCell X1) {\n\n    X1.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (XSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    X1.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            X1.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            X1.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            X1.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            X1.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            X1.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 97601, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet X1, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (X1.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (X1.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (X1.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (X1.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (X1.isDisplayZeros ());\n\n    sheetNew.setFitToPage (X1.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (X1.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, X1.getMargin (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, X1.getMargin (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, X1.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.LeftMargin, X1.getMargin (Sheet.LeftMargin));\n\n    sheetNew.setMargin (Sheet.RightMargin, X1.getMargin (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, X1.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (X1.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : X1) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, X1.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, X1.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < X1.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = X1.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97602, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, Integer hash, HSSFCellStyle styleOld, XSSFCellStyle X1) {\n\n    X1.setAlignment (styleOld.getAlignment ());\n\n    X1.setBorderBottom (styleOld.getBorderBottom ());\n\n    X1.setBorderLeft (styleOld.getBorderLeft ());\n\n    X1.setBorderRight (styleOld.getBorderRight ());\n\n    X1.setBorderTop (styleOld.getBorderTop ());\n\n    X1.setDataFormat (this.transform (workbookOld, workbookNew, styleOld.getDataFormat ()));\n\n    X1.setFillBackgroundColor (styleOld.getFillBackgroundColor ());\n\n    X1.setFillForegroundColor (styleOld.getFillForegroundColor ());\n\n    X1.setFillPattern (styleOld.getFillPattern ());\n\n    X1.setFont (this.transform (workbookNew, styleOld.getFont (workbookOld)));\n\n    X1.setHidden (styleOld.getHidden ());\n\n    X1.setIndention (styleOld.getIndention ());\n\n    X1.setLocked (styleOld.getLocked ());\n\n    X1.setVerticalAlignment (styleOld.getVerticalAlignment ());\n\n    X1.setWrapText (styleOld.getWrapText ());\n\n    this.styleMap.put (hash, X1);\n\n}\n"}
{"idx": 97701, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFSheet X1, HSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (X1.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (X1.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (X1.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (X1.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (X1.isDisplayZeros ());\n\n    sheetNew.setFitToPage (X1.getFitToPage ());\n\n    sheetNew.setHorizontallyCenter (X1.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, X1.getMargin (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, X1.getMargin (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, X1.getMargin (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.LeftMargin, X1.getMargin (Sheet.LeftMargin));\n\n    sheetNew.setMargin (Sheet.RightMargin, X1.getMargin (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, X1.getMargin (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (X1.getVerticallyCenter ());\n\n    HSSFRow rowNew;\n\n    for (Row row : X1) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (XSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, X1.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, X1.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < X1.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = X1.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 97702, "func": "private XSSFFont transform (XSSFWorkbook workbookNew, HSSFFont fontOld) {\n\n    XSSFFont X1 = workbookNew.createFont ();\n\n    X1.setBoldweight (fontOld.getBoldweight ());\n\n    X1.setCharSet (fontOld.getCharSet ());\n\n    X1.setColor (fontOld.getColor ());\n\n    X1.setFontName (fontOld.getFontName ());\n\n    X1.setFontHeight (fontOld.getFontHeight ());\n\n    X1.setItalic (fontOld.getItalic ());\n\n    X1.setStrikeout (fontOld.getStrikeout ());\n\n    X1.setTypeOffset (fontOld.getTypeOffset ());\n\n    X1.setUnderline (fontOld.getUnderline ());\n\n    return X1;\n\n}\n"}
{"idx": 97801, "func": "private void X1 (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.X1 (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 97802, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case X1.CELL_TYPE_BLANK :\n\n            break;\n\n        case X1.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case X1.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case X1.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case X1.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case X1.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 97901, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell X1 : rowOld) {\n\n        cellNew = rowNew.createCell (X1.getColumnIndex (), X1.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) X1, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 97902, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, Integer hash, XSSFCellStyle X1, HSSFCellStyle styleNew) {\n\n    styleNew.setAlignment (X1.getAlignment ());\n\n    styleNew.setBorderBottom (X1.getBorderBottom ());\n\n    styleNew.setBorderLeft (X1.getBorderLeft ());\n\n    styleNew.setBorderRight (X1.getBorderRight ());\n\n    styleNew.setBorderTop (X1.getBorderTop ());\n\n    styleNew.setDataFormat (this.transform (workbookOld, workbookNew, X1.getDataFormat ()));\n\n    styleNew.setFillBackgroundColor (X1.getFillBackgroundColor ());\n\n    styleNew.setFillForegroundColor (X1.getFillForegroundColor ());\n\n    styleNew.setFillPattern (X1.getFillPattern ());\n\n    styleNew.setFont (this.transform (workbookNew, (XSSFFont) X1.getFont ()));\n\n    styleNew.setHidden (X1.getHidden ());\n\n    styleNew.setIndention (X1.getIndention ());\n\n    styleNew.setLocked (X1.getLocked ());\n\n    styleNew.setVerticalAlignment (X1.getVerticalAlignment ());\n\n    styleNew.setWrapText (X1.getWrapText ());\n\n    this.styleMap.put (hash, styleNew);\n\n}\n"}
{"idx": 98001, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) X1.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    X1.lastColumn = Math.max (X1.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 98002, "func": "private HSSFFont transform (HSSFWorkbook workbookNew, XSSFFont fontOld) {\n\n    HSSFFont X1 = workbookNew.createFont ();\n\n    X1.setBoldweight (fontOld.getBoldweight ());\n\n    X1.setCharSet (fontOld.getCharSet ());\n\n    X1.setColor (fontOld.getColor ());\n\n    X1.setFontName (fontOld.getFontName ());\n\n    X1.setFontHeight (fontOld.getFontHeight ());\n\n    X1.setItalic (fontOld.getItalic ());\n\n    X1.setStrikeout (fontOld.getStrikeout ());\n\n    X1.setTypeOffset (fontOld.getTypeOffset ());\n\n    X1.setUnderline (fontOld.getUnderline ());\n\n    return X1;\n\n}\n"}
{"idx": 9801, "func": "public void type (CharSequence chars, int ms) {\n\n    ms = ms > 0 ? ms : 0;\n\n    for (int i = 0, len = chars.length ();\n\n    i < len; i ++) {\n\n        char c = chars.charAt (i);\n\n        AWTKeyStroke keyStroke = getKeyStroke (c);\n\n        int keyCode = keyStroke.getKeyCode ();\n\n        boolean shift = Character.isUpperCase (c) || keyStroke.getModifiers () == (SHIFT_DOWN_MASK + 1);\n\n        if (shift) {\n\n            robot.keyPress (KeyEvent.VK_SHIFT);\n\n        }\n\n        robot.keyPress (keyCode);\n\n        robot.X1 (keyCode);\n\n        if (shift) {\n\n            robot.X1 (KeyEvent.VK_SHIFT);\n\n        }\n\n        if (ms > 0) {\n\n            robot.delay (ms);\n\n        }\n\n    }\n\n}\n"}
{"idx": 9802, "func": "public void type (char character) {\n\n    switch (character) {\n\n        case 'a' :\n\n            doType (VK_A);\n\n            break;\n\n        case 'b' :\n\n            doType (VK_B);\n\n            break;\n\n        case 'c' :\n\n            doType (VK_C);\n\n            break;\n\n        case 'd' :\n\n            doType (VK_D);\n\n            break;\n\n        case 'e' :\n\n            doType (VK_E);\n\n            break;\n\n        case 'f' :\n\n            doType (VK_F);\n\n            break;\n\n        case 'g' :\n\n            doType (VK_G);\n\n            break;\n\n        case 'h' :\n\n            doType (VK_H);\n\n            break;\n\n        case 'i' :\n\n            doType (VK_I);\n\n            break;\n\n        case 'j' :\n\n            doType (VK_J);\n\n            break;\n\n        case 'k' :\n\n            doType (VK_K);\n\n            break;\n\n        case 'l' :\n\n            doType (VK_L);\n\n            break;\n\n        case 'm' :\n\n            doType (VK_M);\n\n            break;\n\n        case 'n' :\n\n            doType (VK_N);\n\n            break;\n\n        case 'o' :\n\n            doType (VK_O);\n\n            break;\n\n        case 'p' :\n\n            doType (VK_P);\n\n            break;\n\n        case 'q' :\n\n            doType (VK_Q);\n\n            break;\n\n        case 'r' :\n\n            doType (VK_R);\n\n            break;\n\n        case 's' :\n\n            doType (VK_S);\n\n            break;\n\n        case 't' :\n\n            doType (VK_T);\n\n            break;\n\n        case 'u' :\n\n            doType (VK_U);\n\n            break;\n\n        case 'v' :\n\n            doType (VK_V);\n\n            break;\n\n        case 'w' :\n\n            doType (VK_W);\n\n            break;\n\n        case 'x' :\n\n            doType (VK_X);\n\n            break;\n\n        case 'y' :\n\n            doType (VK_Y);\n\n            break;\n\n        case 'z' :\n\n            doType (VK_Z);\n\n            break;\n\n        case 'A' :\n\n            doType (X1, VK_A);\n\n            break;\n\n        case 'B' :\n\n            doType (X1, VK_B);\n\n            break;\n\n        case 'C' :\n\n            doType (X1, VK_C);\n\n            break;\n\n        case 'D' :\n\n            doType (X1, VK_D);\n\n            break;\n\n        case 'E' :\n\n            doType (X1, VK_E);\n\n            break;\n\n        case 'F' :\n\n            doType (X1, VK_F);\n\n            break;\n\n        case 'G' :\n\n            doType (X1, VK_G);\n\n            break;\n\n        case 'H' :\n\n            doType (X1, VK_H);\n\n            break;\n\n        case 'I' :\n\n            doType (X1, VK_I);\n\n            break;\n\n        case 'J' :\n\n            doType (X1, VK_J);\n\n            break;\n\n        case 'K' :\n\n            doType (X1, VK_K);\n\n            break;\n\n        case 'L' :\n\n            doType (X1, VK_L);\n\n            break;\n\n        case 'M' :\n\n            doType (X1, VK_M);\n\n            break;\n\n        case 'N' :\n\n            doType (X1, VK_N);\n\n            break;\n\n        case 'O' :\n\n            doType (X1, VK_O);\n\n            break;\n\n        case 'P' :\n\n            doType (X1, VK_P);\n\n            break;\n\n        case 'Q' :\n\n            doType (X1, VK_Q);\n\n            break;\n\n        case 'R' :\n\n            doType (X1, VK_R);\n\n            break;\n\n        case 'S' :\n\n            doType (X1, VK_S);\n\n            break;\n\n        case 'T' :\n\n            doType (X1, VK_T);\n\n            break;\n\n        case 'U' :\n\n            doType (X1, VK_U);\n\n            break;\n\n        case 'V' :\n\n            doType (X1, VK_V);\n\n            break;\n\n        case 'W' :\n\n            doType (X1, VK_W);\n\n            break;\n\n        case 'X' :\n\n            doType (X1, VK_X);\n\n            break;\n\n        case 'Y' :\n\n            doType (X1, VK_Y);\n\n            break;\n\n        case 'Z' :\n\n            doType (X1, VK_Z);\n\n            break;\n\n        case '`' :\n\n            doType (VK_BACK_QUOTE);\n\n            break;\n\n        case '0' :\n\n            doType (VK_0);\n\n            break;\n\n        case '1' :\n\n            doType (VK_1);\n\n            break;\n\n        case '2' :\n\n            doType (VK_2);\n\n            break;\n\n        case '3' :\n\n            doType (VK_3);\n\n            break;\n\n        case '4' :\n\n            doType (VK_4);\n\n            break;\n\n        case '5' :\n\n            doType (VK_5);\n\n            break;\n\n        case '6' :\n\n            doType (VK_6);\n\n            break;\n\n        case '7' :\n\n            doType (VK_7);\n\n            break;\n\n        case '8' :\n\n            doType (VK_8);\n\n            break;\n\n        case '9' :\n\n            doType (VK_9);\n\n            break;\n\n        case '-' :\n\n            doType (VK_MINUS);\n\n            break;\n\n        case '=' :\n\n            doType (VK_EQUALS);\n\n            break;\n\n        case '~' :\n\n            doType (X1, VK_BACK_QUOTE);\n\n            break;\n\n        case '!' :\n\n            doType (VK_EXCLAMATION_MARK);\n\n            break;\n\n        case '@' :\n\n            doType (VK_AT);\n\n            break;\n\n        case '#' :\n\n            doType (VK_NUMBER_SIGN);\n\n            break;\n\n        case '$' :\n\n            doType (VK_DOLLAR);\n\n            break;\n\n        case '%' :\n\n            doType (X1, VK_5);\n\n            break;\n\n        case '^' :\n\n            doType (VK_CIRCUMFLEX);\n\n            break;\n\n        case '&' :\n\n            doType (VK_AMPERSAND);\n\n            break;\n\n        case '*' :\n\n            doType (VK_ASTERISK);\n\n            break;\n\n        case '(' :\n\n            doType (VK_LEFT_PARENTHESIS);\n\n            break;\n\n        case ')' :\n\n            doType (VK_RIGHT_PARENTHESIS);\n\n            break;\n\n        case '_' :\n\n            doType (VK_UNDERSCORE);\n\n            break;\n\n        case '+' :\n\n            doType (VK_PLUS);\n\n            break;\n\n        case '\\t' :\n\n            doType (VK_TAB);\n\n            break;\n\n        case '\\n' :\n\n            doType (VK_ENTER);\n\n            break;\n\n        case '[' :\n\n            doType (VK_OPEN_BRACKET);\n\n            break;\n\n        case ']' :\n\n            doType (VK_CLOSE_BRACKET);\n\n            break;\n\n        case '\\\\' :\n\n            doType (VK_BACK_SLASH);\n\n            break;\n\n        case '{' :\n\n            doType (X1, VK_OPEN_BRACKET);\n\n            break;\n\n        case '}' :\n\n            doType (X1, VK_CLOSE_BRACKET);\n\n            break;\n\n        case '|' :\n\n            doType (X1, VK_BACK_SLASH);\n\n            break;\n\n        case ';' :\n\n            doType (VK_SEMICOLON);\n\n            break;\n\n        case ':' :\n\n            doType (VK_COLON);\n\n            break;\n\n        case '\\'' :\n\n            doType (VK_QUOTE);\n\n            break;\n\n        case '\"' :\n\n            doType (VK_QUOTEDBL);\n\n            break;\n\n        case ',' :\n\n            doType (VK_COMMA);\n\n            break;\n\n        case '<' :\n\n            doType (X1, VK_COMMA);\n\n            break;\n\n        case '.' :\n\n            doType (VK_PERIOD);\n\n            break;\n\n        case '>' :\n\n            doType (X1, VK_PERIOD);\n\n            break;\n\n        case '/' :\n\n            doType (VK_SLASH);\n\n            break;\n\n        case '?' :\n\n            doType (X1, VK_SLASH);\n\n            break;\n\n        case ' ' :\n\n            doType (VK_SPACE);\n\n            break;\n\n        default :\n\n            throw new IllegalArgumentException (\"Cannot type character \" + character);\n\n    }\n\n}\n"}
{"idx": 98101, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell X1 : rowOld) {\n\n        cellNew = rowNew.createCell (X1.getColumnIndex (), X1.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) X1, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 98102, "func": "private void transform () {\n\n    String call = \"transform \";\n\n    System.out.println (call + \"Workbook\");\n\n    XSSFSheet sheetNew;\n\n    HSSFSheet sheetOld;\n\n    this.workbookNew.setForceFormulaRecalculation (this.X1.getForceFormulaRecalculation ());\n\n    this.workbookNew.setMissingCellPolicy (this.X1.getMissingCellPolicy ());\n\n    for (int i = 0;\n\n    i < this.X1.getNumberOfSheets (); i ++) {\n\n        sheetOld = this.X1.getSheetAt (i);\n\n        sheetNew = this.workbookNew.getSheet (sheetOld.getSheetName ());\n\n        System.out.println (call + \"Sheet erstellt: \" + sheetOld.getSheetName ());\n\n        sheetNew = this.workbookNew.createSheet (sheetOld.getSheetName ());\n\n        this.transform (sheetOld, sheetNew);\n\n    }\n\n    System.out.println (call + \"Anzahl verwendeter Styles: \" + this.styleMap.size ());\n\n    System.out.println (call + \"abgeschlossen\");\n\n}\n"}
{"idx": 98201, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow X1, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (X1.getHeight ());\n\n    for (Cell cell : X1) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, X1.getLastCellNum ());\n\n}\n"}
{"idx": 98202, "func": "private void transform (HSSFSheet sheetOld, XSSFSheet sheetNew) {\n\n    System.out.println (\"transform Sheet\");\n\n    sheetNew.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    sheetNew.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    sheetNew.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    sheetNew.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    sheetNew.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    sheetNew.setFitToPage (sheetOld.getFitToPage ());\n\n    sheetNew.setForceFormulaRecalculation (sheetOld.getForceFormulaRecalculation ());\n\n    sheetNew.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    sheetNew.setMargin (Sheet.BottomMargin, sheetOld.X1 (Sheet.BottomMargin));\n\n    sheetNew.setMargin (Sheet.FooterMargin, sheetOld.X1 (Sheet.FooterMargin));\n\n    sheetNew.setMargin (Sheet.HeaderMargin, sheetOld.X1 (Sheet.HeaderMargin));\n\n    sheetNew.setMargin (Sheet.LeftMargin, sheetOld.X1 (Sheet.LeftMargin));\n\n    sheetNew.setMargin (Sheet.RightMargin, sheetOld.X1 (Sheet.RightMargin));\n\n    sheetNew.setMargin (Sheet.TopMargin, sheetOld.X1 (Sheet.TopMargin));\n\n    sheetNew.setPrintGridlines (sheetNew.isPrintGridlines ());\n\n    sheetNew.setRightToLeft (sheetNew.isRightToLeft ());\n\n    sheetNew.setRowSumsBelow (sheetNew.getRowSumsBelow ());\n\n    sheetNew.setRowSumsRight (sheetNew.getRowSumsRight ());\n\n    sheetNew.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    XSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = sheetNew.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform ((HSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        sheetNew.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        sheetNew.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        sheetNew.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 98301, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow X1) {\n\n    HSSFCell cellNew;\n\n    X1.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = X1.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 98302, "func": "private void transform (HSSFRow X1, XSSFRow rowNew) {\n\n    XSSFCell cellNew;\n\n    rowNew.setHeight (X1.getHeight ());\n\n    if (X1.getRowStyle () != null) {\n\n        Integer hash = X1.getRowStyle ().hashCode ();\n\n        if (! this.styleMap.containsKey (hash)) this.transform (hash, X1.getRowStyle (), this.workbookNew.createCellStyle ());\n\n        rowNew.setRowStyle (this.styleMap.get (hash));\n\n    }\n\n    for (Cell cell : X1) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform ((HSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, X1.getLastCellNum ());\n\n}\n"}
{"idx": 98401, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.X1 = Math.max (this.X1, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 98402, "func": "private void transform (HSSFCell cellOld, XSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (! X1.styleMap.containsKey (hash)) {\n\n        X1.transform (hash, cellOld.getCellStyle (), X1.workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (X1.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 98501, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow X1) {\n\n    HSSFCell cellNew;\n\n    X1.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = X1.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 98502, "func": "private void transform (Integer hash, HSSFCellStyle styleOld, XSSFCellStyle styleNew) {\n\n    styleNew.setAlignment (styleOld.getAlignment ());\n\n    styleNew.setBorderBottom (styleOld.getBorderBottom ());\n\n    styleNew.setBorderLeft (styleOld.getBorderLeft ());\n\n    styleNew.setBorderRight (styleOld.getBorderRight ());\n\n    styleNew.setBorderTop (styleOld.getBorderTop ());\n\n    styleNew.setDataFormat (X1.transform (styleOld.getDataFormat ()));\n\n    styleNew.setFillBackgroundColor (styleOld.getFillBackgroundColor ());\n\n    styleNew.setFillForegroundColor (styleOld.getFillForegroundColor ());\n\n    styleNew.setFillPattern (styleOld.getFillPattern ());\n\n    styleNew.setFont (X1.transform (styleOld.getFont (X1.workbookOld)));\n\n    styleNew.setHidden (styleOld.getHidden ());\n\n    styleNew.setIndention (styleOld.getIndention ());\n\n    styleNew.setLocked (styleOld.getLocked ());\n\n    styleNew.setVerticalAlignment (styleOld.getVerticalAlignment ());\n\n    styleNew.setWrapText (styleOld.getWrapText ());\n\n    X1.styleMap.put (hash, styleNew);\n\n}\n"}
{"idx": 98601, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow X1, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (X1.getHeight ());\n\n    for (Cell cell : X1) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, X1.getLastCellNum ());\n\n}\n"}
{"idx": 98602, "func": "private XSSFFont transform (HSSFFont X1) {\n\n    XSSFFont fontNew = this.workbookNew.createFont ();\n\n    fontNew.setBoldweight (X1.getBoldweight ());\n\n    fontNew.setCharSet (X1.getCharSet ());\n\n    fontNew.setColor (X1.getColor ());\n\n    fontNew.setFontName (X1.getFontName ());\n\n    fontNew.setFontHeight (X1.getFontHeight ());\n\n    fontNew.setItalic (X1.getItalic ());\n\n    fontNew.setStrikeout (X1.getStrikeout ());\n\n    fontNew.setTypeOffset (X1.getTypeOffset ());\n\n    fontNew.setUnderline (X1.getUnderline ());\n\n    return fontNew;\n\n}\n"}
{"idx": 98701, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow X1, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (X1.getHeight ());\n\n    for (Cell cell : X1) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, X1.getLastCellNum ());\n\n}\n"}
{"idx": 98702, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, HSSFSheet sheetOld, XSSFSheet X1) {\n\n    System.out.println (\"transform Sheet\");\n\n    X1.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    X1.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    X1.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    X1.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    X1.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    X1.setFitToPage (sheetOld.getFitToPage ());\n\n    X1.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    X1.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    X1.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    X1.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    X1.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    X1.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    X1.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    X1.setPrintGridlines (X1.isPrintGridlines ());\n\n    X1.setRowSumsBelow (X1.getRowSumsBelow ());\n\n    X1.setRowSumsRight (X1.getRowSumsRight ());\n\n    X1.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    XSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = X1.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (HSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        X1.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        X1.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        X1.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 98801, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell X1;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        X1 = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (X1 != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, X1);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 98802, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, HSSFCell cellOld, XSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (X1.styleMap != null && ! X1.styleMap.containsKey (hash)) {\n\n        X1.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (XSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (X1.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 98901, "func": "private void X1 (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.X1 (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 98902, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, Integer hash, HSSFCellStyle styleOld, XSSFCellStyle styleNew) {\n\n    styleNew.setAlignment (styleOld.getAlignment ());\n\n    styleNew.setBorderBottom (styleOld.getBorderBottom ());\n\n    styleNew.setBorderLeft (styleOld.getBorderLeft ());\n\n    styleNew.setBorderRight (styleOld.getBorderRight ());\n\n    styleNew.setBorderTop (styleOld.getBorderTop ());\n\n    styleNew.setDataFormat (X1.transform (workbookOld, workbookNew, styleOld.getDataFormat ()));\n\n    styleNew.setFillBackgroundColor (styleOld.getFillBackgroundColor ());\n\n    styleNew.setFillForegroundColor (styleOld.getFillForegroundColor ());\n\n    styleNew.setFillPattern (styleOld.getFillPattern ());\n\n    styleNew.setFont (X1.transform (workbookNew, styleOld.getFont (workbookOld)));\n\n    styleNew.setHidden (styleOld.getHidden ());\n\n    styleNew.setIndention (styleOld.getIndention ());\n\n    styleNew.setLocked (styleOld.getLocked ());\n\n    styleNew.setVerticalAlignment (styleOld.getVerticalAlignment ());\n\n    styleNew.setWrapText (styleOld.getWrapText ());\n\n    X1.styleMap.put (hash, styleNew);\n\n}\n"}
{"idx": 99001, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFRow rowOld, HSSFRow rowNew) {\n\n    HSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (XSSFCell) cell, cellNew);\n\n    }\n\n    this.X1 = Math.max (this.X1, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 99002, "func": "private X1 transform (XSSFWorkbook workbookNew, HSSFFont fontOld) {\n\n    X1 fontNew = workbookNew.createFont ();\n\n    fontNew.setBoldweight (fontOld.getBoldweight ());\n\n    fontNew.setCharSet (fontOld.getCharSet ());\n\n    fontNew.setColor (fontOld.getColor ());\n\n    fontNew.setFontName (fontOld.getFontName ());\n\n    fontNew.setFontHeight (fontOld.getFontHeight ());\n\n    fontNew.setItalic (fontOld.getItalic ());\n\n    fontNew.setStrikeout (fontOld.getStrikeout ());\n\n    fontNew.setTypeOffset (fontOld.getTypeOffset ());\n\n    fontNew.setUnderline (fontOld.getUnderline ());\n\n    return fontNew;\n\n}\n"}
{"idx": 9901, "func": "public void type (CharSequence chars, int ms) {\n\n    ms = ms > 0 ? ms : 0;\n\n    for (int X1 = 0, len = chars.length ();\n\n    X1 < len; X1 ++) {\n\n        char c = chars.charAt (X1);\n\n        AWTKeyStroke keyStroke = getKeyStroke (c);\n\n        int keyCode = keyStroke.getKeyCode ();\n\n        boolean shift = Character.isUpperCase (c) || keyStroke.getModifiers () == (SHIFT_DOWN_MASK + 1);\n\n        if (shift) {\n\n            robot.keyPress (KeyEvent.VK_SHIFT);\n\n        }\n\n        robot.keyPress (keyCode);\n\n        robot.keyRelease (keyCode);\n\n        if (shift) {\n\n            robot.keyRelease (KeyEvent.VK_SHIFT);\n\n        }\n\n        if (ms > 0) {\n\n            robot.delay (ms);\n\n        }\n\n    }\n\n}\n"}
{"idx": 9902, "func": "private void type (char character) {\n\n    handleSpecialCharacter (character);\n\n    if (X1.isLowerCase (character)) {\n\n        typeCharacter (X1.toUpperCase (character));\n\n    }\n\n    if (X1.isUpperCase (character)) {\n\n        typeShiftCharacter (character);\n\n    }\n\n    if (X1.isDigit (character)) {\n\n        typeCharacter (character);\n\n    }\n\n}\n"}
{"idx": 99101, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell X1) {\n\n    X1.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    X1.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            X1.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            X1.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            X1.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            X1.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            X1.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99102, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, Integer hash, XSSFCellStyle styleOld, HSSFCellStyle styleNew) {\n\n    styleNew.setAlignment (styleOld.getAlignment ());\n\n    styleNew.setBorderBottom (styleOld.getBorderBottom ());\n\n    styleNew.setBorderLeft (styleOld.getBorderLeft ());\n\n    styleNew.setBorderRight (styleOld.getBorderRight ());\n\n    styleNew.setBorderTop (styleOld.getBorderTop ());\n\n    styleNew.setDataFormat (X1.transform (workbookOld, workbookNew, styleOld.getDataFormat ()));\n\n    styleNew.setFillBackgroundColor (styleOld.getFillBackgroundColor ());\n\n    styleNew.setFillForegroundColor (styleOld.getFillForegroundColor ());\n\n    styleNew.setFillPattern (styleOld.getFillPattern ());\n\n    styleNew.setFont (X1.transform (workbookNew, (XSSFFont) styleOld.getFont ()));\n\n    styleNew.setHidden (styleOld.getHidden ());\n\n    styleNew.setIndention (styleOld.getIndention ());\n\n    styleNew.setLocked (styleOld.getLocked ());\n\n    styleNew.setVerticalAlignment (styleOld.getVerticalAlignment ());\n\n    styleNew.setWrapText (styleOld.getWrapText ());\n\n    X1.styleMap.put (hash, styleNew);\n\n}\n"}
{"idx": 99201, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.X1 (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.X1 (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.X1 (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.X1 (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.X1 (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99202, "func": "private HSSFFont transform (HSSFWorkbook workbookNew, XSSFFont X1) {\n\n    HSSFFont fontNew = workbookNew.createFont ();\n\n    fontNew.setBoldweight (X1.getBoldweight ());\n\n    fontNew.setCharSet (X1.getCharSet ());\n\n    fontNew.setColor (X1.getColor ());\n\n    fontNew.setFontName (X1.getFontName ());\n\n    fontNew.setFontHeight (X1.getFontHeight ());\n\n    fontNew.setItalic (X1.getItalic ());\n\n    fontNew.setStrikeout (X1.getStrikeout ());\n\n    fontNew.setTypeOffset (X1.getTypeOffset ());\n\n    fontNew.setUnderline (X1.getUnderline ());\n\n    return fontNew;\n\n}\n"}
{"idx": 99301, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer X1 = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (X1)) {\n\n        this.transform (workbookOld, workbookNew, X1, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.styleMap.get (X1));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99302, "func": "private void transform () {\n\n    String call = \"transform \";\n\n    System.out.println (call + \"Workbook\");\n\n    XSSFSheet sheetNew;\n\n    HSSFSheet sheetOld;\n\n    X1.workbookNew.setForceFormulaRecalculation (X1.workbookOld.getForceFormulaRecalculation ());\n\n    X1.workbookNew.setMissingCellPolicy (X1.workbookOld.getMissingCellPolicy ());\n\n    for (int i = 0;\n\n    i < X1.workbookOld.getNumberOfSheets (); i ++) {\n\n        sheetOld = X1.workbookOld.getSheetAt (i);\n\n        sheetNew = X1.workbookNew.getSheet (sheetOld.getSheetName ());\n\n        System.out.println (call + \"Sheet erstellt: \" + sheetOld.getSheetName ());\n\n        sheetNew = X1.workbookNew.createSheet (sheetOld.getSheetName ());\n\n        X1.transform (sheetOld, sheetNew);\n\n    }\n\n    System.out.println (call + \"Anzahl verwendeter Styles: \" + X1.styleMap.size ());\n\n    System.out.println (call + \"abgeschlossen\");\n\n}\n"}
{"idx": 99401, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell X1, HSSFCell cellNew) {\n\n    cellNew.setCellComment (X1.getCellComment ());\n\n    Integer hash = X1.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, X1.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.styleMap.get (hash));\n\n    switch (X1.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (X1.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (X1.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (X1.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (X1.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (X1.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + X1.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99402, "func": "private void transform (HSSFSheet sheetOld, XSSFSheet X1) {\n\n    System.out.println (\"transform Sheet\");\n\n    X1.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    X1.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    X1.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    X1.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    X1.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    X1.setFitToPage (sheetOld.getFitToPage ());\n\n    X1.setForceFormulaRecalculation (sheetOld.getForceFormulaRecalculation ());\n\n    X1.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    X1.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    X1.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    X1.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    X1.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    X1.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    X1.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    X1.setPrintGridlines (X1.isPrintGridlines ());\n\n    X1.setRightToLeft (X1.isRightToLeft ());\n\n    X1.setRowSumsBelow (X1.getRowSumsBelow ());\n\n    X1.setRowSumsRight (X1.getRowSumsRight ());\n\n    X1.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    XSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = X1.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform ((HSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        X1.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        X1.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        X1.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 99501, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell X1) {\n\n    X1.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    X1.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            X1.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            X1.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            X1.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            X1.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            X1.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99502, "func": "private void X1 (HSSFRow rowOld, XSSFRow rowNew) {\n\n    XSSFCell cellNew;\n\n    rowNew.setHeight (rowOld.getHeight ());\n\n    if (rowOld.getRowStyle () != null) {\n\n        Integer hash = rowOld.getRowStyle ().hashCode ();\n\n        if (! this.styleMap.containsKey (hash)) this.X1 (hash, rowOld.getRowStyle (), this.workbookNew.createCellStyle ());\n\n        rowNew.setRowStyle (this.styleMap.get (hash));\n\n    }\n\n    for (Cell cell : rowOld) {\n\n        cellNew = rowNew.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.X1 ((HSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
{"idx": 99601, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer X1 = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (X1)) {\n\n        this.transform (workbookOld, workbookNew, X1, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.styleMap.get (X1));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99602, "func": "private void transform (Integer hash, HSSFCellStyle styleOld, XSSFCellStyle X1) {\n\n    X1.setAlignment (styleOld.getAlignment ());\n\n    X1.setBorderBottom (styleOld.getBorderBottom ());\n\n    X1.setBorderLeft (styleOld.getBorderLeft ());\n\n    X1.setBorderRight (styleOld.getBorderRight ());\n\n    X1.setBorderTop (styleOld.getBorderTop ());\n\n    X1.setDataFormat (this.transform (styleOld.getDataFormat ()));\n\n    X1.setFillBackgroundColor (styleOld.getFillBackgroundColor ());\n\n    X1.setFillForegroundColor (styleOld.getFillForegroundColor ());\n\n    X1.setFillPattern (styleOld.getFillPattern ());\n\n    X1.setFont (this.transform (styleOld.getFont (this.workbookOld)));\n\n    X1.setHidden (styleOld.getHidden ());\n\n    X1.setIndention (styleOld.getIndention ());\n\n    X1.setLocked (styleOld.getLocked ());\n\n    X1.setVerticalAlignment (styleOld.getVerticalAlignment ());\n\n    X1.setWrapText (styleOld.getWrapText ());\n\n    this.styleMap.put (hash, X1);\n\n}\n"}
{"idx": 99701, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell X1) {\n\n    X1.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    X1.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            X1.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            X1.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            X1.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            X1.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            X1.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99702, "func": "private XSSFFont transform (HSSFFont X1) {\n\n    XSSFFont fontNew = this.workbookNew.createFont ();\n\n    fontNew.setBoldweight (X1.getBoldweight ());\n\n    fontNew.setCharSet (X1.getCharSet ());\n\n    fontNew.setColor (X1.getColor ());\n\n    fontNew.setFontName (X1.getFontName ());\n\n    fontNew.setFontHeight (X1.getFontHeight ());\n\n    fontNew.setItalic (X1.getItalic ());\n\n    fontNew.setStrikeout (X1.getStrikeout ());\n\n    fontNew.setTypeOffset (X1.getTypeOffset ());\n\n    fontNew.setUnderline (X1.getUnderline ());\n\n    return fontNew;\n\n}\n"}
{"idx": 99801, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.X1 != null && ! this.X1.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.X1.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.setCellValue (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.setCellValue (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.setCellValue (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.setCellValue (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.setCellValue (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99802, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, HSSFSheet sheetOld, XSSFSheet X1) {\n\n    System.out.println (\"transform Sheet\");\n\n    X1.setDisplayFormulas (sheetOld.isDisplayFormulas ());\n\n    X1.setDisplayGridlines (sheetOld.isDisplayGridlines ());\n\n    X1.setDisplayGuts (sheetOld.getDisplayGuts ());\n\n    X1.setDisplayRowColHeadings (sheetOld.isDisplayRowColHeadings ());\n\n    X1.setDisplayZeros (sheetOld.isDisplayZeros ());\n\n    X1.setFitToPage (sheetOld.getFitToPage ());\n\n    X1.setHorizontallyCenter (sheetOld.getHorizontallyCenter ());\n\n    X1.setMargin (Sheet.BottomMargin, sheetOld.getMargin (Sheet.BottomMargin));\n\n    X1.setMargin (Sheet.FooterMargin, sheetOld.getMargin (Sheet.FooterMargin));\n\n    X1.setMargin (Sheet.HeaderMargin, sheetOld.getMargin (Sheet.HeaderMargin));\n\n    X1.setMargin (Sheet.LeftMargin, sheetOld.getMargin (Sheet.LeftMargin));\n\n    X1.setMargin (Sheet.RightMargin, sheetOld.getMargin (Sheet.RightMargin));\n\n    X1.setMargin (Sheet.TopMargin, sheetOld.getMargin (Sheet.TopMargin));\n\n    X1.setPrintGridlines (X1.isPrintGridlines ());\n\n    X1.setRowSumsBelow (X1.getRowSumsBelow ());\n\n    X1.setRowSumsRight (X1.getRowSumsRight ());\n\n    X1.setVerticallyCenter (sheetOld.getVerticallyCenter ());\n\n    XSSFRow rowNew;\n\n    for (Row row : sheetOld) {\n\n        rowNew = X1.createRow (row.getRowNum ());\n\n        if (rowNew != null) this.transform (workbookOld, workbookNew, (HSSFRow) row, rowNew);\n\n    }\n\n    for (int i = 0;\n\n    i < this.lastColumn; i ++) {\n\n        X1.setColumnWidth (i, sheetOld.getColumnWidth (i));\n\n        X1.setColumnHidden (i, sheetOld.isColumnHidden (i));\n\n    }\n\n    for (int i = 0;\n\n    i < sheetOld.getNumMergedRegions (); i ++) {\n\n        CellRangeAddress merged = sheetOld.getMergedRegion (i);\n\n        X1.addMergedRegion (merged);\n\n    }\n\n}\n"}
{"idx": 99901, "func": "private void transform (XSSFWorkbook workbookOld, HSSFWorkbook workbookNew, XSSFCell cellOld, HSSFCell cellNew) {\n\n    cellNew.setCellComment (cellOld.getCellComment ());\n\n    Integer hash = cellOld.getCellStyle ().hashCode ();\n\n    if (this.styleMap != null && ! this.styleMap.containsKey (hash)) {\n\n        this.transform (workbookOld, workbookNew, hash, cellOld.getCellStyle (), (HSSFCellStyle) workbookNew.createCellStyle ());\n\n    }\n\n    cellNew.setCellStyle (this.styleMap.get (hash));\n\n    switch (cellOld.getCellType ()) {\n\n        case Cell.CELL_TYPE_BLANK :\n\n            break;\n\n        case Cell.CELL_TYPE_BOOLEAN :\n\n            cellNew.X1 (cellOld.getBooleanCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_ERROR :\n\n            cellNew.X1 (cellOld.getErrorCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_FORMULA :\n\n            cellNew.X1 (cellOld.getCellFormula ());\n\n            break;\n\n        case Cell.CELL_TYPE_NUMERIC :\n\n            cellNew.X1 (cellOld.getNumericCellValue ());\n\n            break;\n\n        case Cell.CELL_TYPE_STRING :\n\n            cellNew.X1 (cellOld.getStringCellValue ());\n\n            break;\n\n        default :\n\n            System.out.println (\"transform: Unbekannter Zellentyp \" + cellOld.getCellType ());\n\n    }\n\n}\n"}
{"idx": 99902, "func": "private void transform (HSSFWorkbook workbookOld, XSSFWorkbook workbookNew, HSSFRow rowOld, XSSFRow X1) {\n\n    XSSFCell cellNew;\n\n    X1.setHeight (rowOld.getHeight ());\n\n    for (Cell cell : rowOld) {\n\n        cellNew = X1.createCell (cell.getColumnIndex (), cell.getCellType ());\n\n        if (cellNew != null) this.transform (workbookOld, workbookNew, (HSSFCell) cell, cellNew);\n\n    }\n\n    this.lastColumn = Math.max (this.lastColumn, rowOld.getLastCellNum ());\n\n}\n"}
